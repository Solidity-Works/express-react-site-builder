{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\nvar _Object$defineProperty = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\nvar _getIterator2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js/get-iterator\"));\nvar _isArray = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/array/is-array\"));\nvar _getIteratorMethod2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js/get-iterator-method\"));\nvar _symbol = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/symbol\"));\nvar _from = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/array/from\"));\nvar _concat = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/concat\"));\nvar _indexOf = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/index-of\"));\nvar _create = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/object/create\"));\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/slicedToArray\"));\nvar _forEach = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/for-each\"));\nvar _includes = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/includes\"));\nvar _parseInt2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/parse-int\"));\nvar _slice = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/slice\"));\nvar _sort = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/sort\"));\nvar _flags = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/flags\"));\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n  if (typeof _symbol[\"default\"] === \"undefined\" || (0, _getIteratorMethod2[\"default\"])(o) == null) {\n    if ((0, _isArray[\"default\"])(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      var F = function F() {};\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true,\n    didErr = false,\n    err;\n  return {\n    s: function s() {\n      it = (0, _getIterator2[\"default\"])(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  var _context9;\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = (0, _slice[\"default\"])(_context9 = Object.prototype.toString.call(o)).call(_context9, 8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return (0, _from[\"default\"])(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\n\n/*!\n * XRegExp 4.4.1\n * <xregexp.com>\n * Steven Levithan (c) 2007-present MIT License\n */\n\n/**\n * XRegExp provides augmented, extensible regular expressions. You get additional regex syntax and\n * flags, beyond what browsers support natively. XRegExp is also a regex utility belt with tools to\n * make your client-side grepping simpler and more powerful, while freeing you from related\n * cross-browser inconsistencies.\n */\n// ==--------------------------==\n// Private stuff\n// ==--------------------------==\n// Property name used for extended regex instance data\nvar REGEX_DATA = 'xregexp'; // Optional features that can be installed and uninstalled\n\nvar features = {\n  astral: false,\n  namespacing: false\n}; // Native methods to use and restore ('native' is an ES3 reserved keyword)\n\nvar nativ = {\n  exec: RegExp.prototype.exec,\n  test: RegExp.prototype.test,\n  match: String.prototype.match,\n  replace: String.prototype.replace,\n  split: String.prototype.split\n}; // Storage for fixed/extended native methods\n\nvar fixed = {}; // Storage for regexes cached by `XRegExp.cache`\n\nvar regexCache = {}; // Storage for pattern details cached by the `XRegExp` constructor\n\nvar patternCache = {}; // Storage for regex syntax tokens added internally or by `XRegExp.addToken`\n\nvar tokens = []; // Token scopes\n\nvar defaultScope = 'default';\nvar classScope = 'class'; // Regexes that match native regex syntax, including octals\n\nvar nativeTokens = {\n  // Any native multicharacter token in default scope, or any single character\n  'default': /\\\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9]\\d*|x[\\dA-Fa-f]{2}|u(?:[\\dA-Fa-f]{4}|{[\\dA-Fa-f]+})|c[A-Za-z]|[\\s\\S])|\\(\\?(?:[:=!]|<[=!])|[?*+]\\?|{\\d+(?:,\\d*)?}\\??|[\\s\\S]/,\n  // Any native multicharacter token in character class scope, or any single character\n  'class': /\\\\(?:[0-3][0-7]{0,2}|[4-7][0-7]?|x[\\dA-Fa-f]{2}|u(?:[\\dA-Fa-f]{4}|{[\\dA-Fa-f]+})|c[A-Za-z]|[\\s\\S])|[\\s\\S]/\n}; // Any backreference or dollar-prefixed character in replacement strings\n\nvar replacementToken = /\\$(?:{([\\w$]+)}|<([\\w$]+)>|(\\d\\d?|[\\s\\S]))/g; // Check for correct `exec` handling of nonparticipating capturing groups\n\nvar correctExecNpcg = nativ.exec.call(/()??/, '')[1] === undefined; // Check for ES6 `flags` prop support\n\nvar hasFlagsProp = (0, _flags[\"default\"])(/x/) !== undefined; // Shortcut to `Object.prototype.toString`\n\nvar _ref = {},\n  toString = _ref.toString;\nfunction hasNativeFlag(flag) {\n  // Can't check based on the presence of properties/getters since browsers might support such\n  // properties even when they don't support the corresponding flag in regex construction (tested\n  // in Chrome 48, where `'unicode' in /x/` is true but trying to construct a regex with flag `u`\n  // throws an error)\n  var isSupported = true;\n  try {\n    // Can't use regex literals for testing even in a `try` because regex literals with\n    // unsupported flags cause a compilation error in IE\n    new RegExp('', flag); // Work around a broken/incomplete IE11 polyfill for sticky introduced in core-js 3.6.0\n\n    if (flag === 'y') {\n      // Using function to avoid babel transform to regex literal\n      var gy = function () {\n        return 'gy';\n      }();\n      var incompleteY = '.a'.replace(new RegExp('a', gy), '.') === '..';\n      if (incompleteY) {\n        isSupported = false;\n      }\n    }\n  } catch (exception) {\n    isSupported = false;\n  }\n  return isSupported;\n} // Check for ES6 `u` flag support\n\nvar hasNativeU = hasNativeFlag('u'); // Check for ES6 `y` flag support\n\nvar hasNativeY = hasNativeFlag('y'); // Tracker for known flags, including addon flags\n\nvar registeredFlags = {\n  g: true,\n  i: true,\n  m: true,\n  u: hasNativeU,\n  y: hasNativeY\n};\n/**\n * Attaches extended data and `XRegExp.prototype` properties to a regex object.\n *\n * @private\n * @param {RegExp} regex Regex to augment.\n * @param {Array} captureNames Array with capture names, or `null`.\n * @param {String} xSource XRegExp pattern used to generate `regex`, or `null` if N/A.\n * @param {String} xFlags XRegExp flags used to generate `regex`, or `null` if N/A.\n * @param {Boolean} [isInternalOnly=false] Whether the regex will be used only for internal\n *   operations, and never exposed to users. For internal-only regexes, we can improve perf by\n *   skipping some operations like attaching `XRegExp.prototype` properties.\n * @returns {!RegExp} Augmented regex.\n */\n\nfunction augment(regex, captureNames, xSource, xFlags, isInternalOnly) {\n  var _context;\n  regex[REGEX_DATA] = {\n    captureNames: captureNames\n  };\n  if (isInternalOnly) {\n    return regex;\n  } // Can't auto-inherit these since the XRegExp constructor returns a nonprimitive value\n\n  if (regex.__proto__) {\n    regex.__proto__ = XRegExp.prototype;\n  } else {\n    for (var p in XRegExp.prototype) {\n      // An `XRegExp.prototype.hasOwnProperty(p)` check wouldn't be worth it here, since this\n      // is performance sensitive, and enumerable `Object.prototype` or `RegExp.prototype`\n      // extensions exist on `regex.prototype` anyway\n      regex[p] = XRegExp.prototype[p];\n    }\n  }\n  regex[REGEX_DATA].source = xSource; // Emulate the ES6 `flags` prop by ensuring flags are in alphabetical order\n\n  regex[REGEX_DATA].flags = xFlags ? (0, _sort[\"default\"])(_context = xFlags.split('')).call(_context).join('') : xFlags;\n  return regex;\n}\n/**\n * Removes any duplicate characters from the provided string.\n *\n * @private\n * @param {String} str String to remove duplicate characters from.\n * @returns {string} String with any duplicate characters removed.\n */\n\nfunction clipDuplicates(str) {\n  return nativ.replace.call(str, /([\\s\\S])(?=[\\s\\S]*\\1)/g, '');\n}\n/**\n * Copies a regex object while preserving extended data and augmenting with `XRegExp.prototype`\n * properties. The copy has a fresh `lastIndex` property (set to zero). Allows adding and removing\n * flags g and y while copying the regex.\n *\n * @private\n * @param {RegExp} regex Regex to copy.\n * @param {Object} [options] Options object with optional properties:\n *   - `addG` {Boolean} Add flag g while copying the regex.\n *   - `addY` {Boolean} Add flag y while copying the regex.\n *   - `removeG` {Boolean} Remove flag g while copying the regex.\n *   - `removeY` {Boolean} Remove flag y while copying the regex.\n *   - `isInternalOnly` {Boolean} Whether the copied regex will be used only for internal\n *     operations, and never exposed to users. For internal-only regexes, we can improve perf by\n *     skipping some operations like attaching `XRegExp.prototype` properties.\n *   - `source` {String} Overrides `<regex>.source`, for special cases.\n * @returns {RegExp} Copy of the provided regex, possibly with modified flags.\n */\n\nfunction copyRegex(regex, options) {\n  var _context2;\n  if (!XRegExp.isRegExp(regex)) {\n    throw new TypeError('Type RegExp expected');\n  }\n  var xData = regex[REGEX_DATA] || {};\n  var flags = getNativeFlags(regex);\n  var flagsToAdd = '';\n  var flagsToRemove = '';\n  var xregexpSource = null;\n  var xregexpFlags = null;\n  options = options || {};\n  if (options.removeG) {\n    flagsToRemove += 'g';\n  }\n  if (options.removeY) {\n    flagsToRemove += 'y';\n  }\n  if (flagsToRemove) {\n    flags = nativ.replace.call(flags, new RegExp(\"[\".concat(flagsToRemove, \"]+\"), 'g'), '');\n  }\n  if (options.addG) {\n    flagsToAdd += 'g';\n  }\n  if (options.addY) {\n    flagsToAdd += 'y';\n  }\n  if (flagsToAdd) {\n    flags = clipDuplicates(flags + flagsToAdd);\n  }\n  if (!options.isInternalOnly) {\n    if (xData.source !== undefined) {\n      xregexpSource = xData.source;\n    } // null or undefined; don't want to add to `flags` if the previous value was null, since\n    // that indicates we're not tracking original precompilation flags\n\n    if ((0, _flags[\"default\"])(xData) != null) {\n      // Flags are only added for non-internal regexes by `XRegExp.globalize`. Flags are never\n      // removed for non-internal regexes, so don't need to handle it\n      xregexpFlags = flagsToAdd ? clipDuplicates((0, _flags[\"default\"])(xData) + flagsToAdd) : (0, _flags[\"default\"])(xData);\n    }\n  } // Augment with `XRegExp.prototype` properties, but use the native `RegExp` constructor to avoid\n  // searching for special tokens. That would be wrong for regexes constructed by `RegExp`, and\n  // unnecessary for regexes constructed by `XRegExp` because the regex has already undergone the\n  // translation to native regex syntax\n\n  regex = augment(new RegExp(options.source || regex.source, flags), hasNamedCapture(regex) ? (0, _slice[\"default\"])(_context2 = xData.captureNames).call(_context2, 0) : null, xregexpSource, xregexpFlags, options.isInternalOnly);\n  return regex;\n}\n/**\n * Converts hexadecimal to decimal.\n *\n * @private\n * @param {String} hex\n * @returns {number}\n */\n\nfunction dec(hex) {\n  return (0, _parseInt2[\"default\"])(hex, 16);\n}\n/**\n * Returns a pattern that can be used in a native RegExp in place of an ignorable token such as an\n * inline comment or whitespace with flag x. This is used directly as a token handler function\n * passed to `XRegExp.addToken`.\n *\n * @private\n * @param {String} match Match arg of `XRegExp.addToken` handler\n * @param {String} scope Scope arg of `XRegExp.addToken` handler\n * @param {String} flags Flags arg of `XRegExp.addToken` handler\n * @returns {string} Either '' or '(?:)', depending on which is needed in the context of the match.\n */\n\nfunction getContextualTokenSeparator(match, scope, flags) {\n  if (\n  // No need to separate tokens if at the beginning or end of a group\n  match.input[match.index - 1] === '(' || match.input[match.index + match[0].length] === ')' ||\n  // No need to separate tokens if before or after a `|`\n  match.input[match.index - 1] === '|' || match.input[match.index + match[0].length] === '|' ||\n  // No need to separate tokens if at the beginning or end of the pattern\n  match.index < 1 || match.index + match[0].length >= match.input.length ||\n  // No need to separate tokens if at the beginning of a noncapturing group or lookahead.\n  // The way this is written relies on:\n  // - The search regex matching only 3-char strings.\n  // - Although `substr` gives chars from the end of the string if given a negative index,\n  //   the resulting substring will be too short to match. Ex: `'abcd'.substr(-1, 3) === 'd'`\n  nativ.test.call(/^\\(\\?[:=!]/, match.input.substr(match.index - 3, 3)) ||\n  // Avoid separating tokens when the following token is a quantifier\n  isQuantifierNext(match.input, match.index + match[0].length, flags)) {\n    return '';\n  } // Keep tokens separated. This avoids e.g. inadvertedly changing `\\1 1` or `\\1(?#)1` to `\\11`.\n  // This also ensures all tokens remain as discrete atoms, e.g. it avoids converting the syntax\n  // error `(? :` into `(?:`.\n\n  return '(?:)';\n}\n/**\n * Returns native `RegExp` flags used by a regex object.\n *\n * @private\n * @param {RegExp} regex Regex to check.\n * @returns {string} Native flags in use.\n */\n\nfunction getNativeFlags(regex) {\n  return hasFlagsProp ? (0, _flags[\"default\"])(regex) :\n  // Explicitly using `RegExp.prototype.toString` (rather than e.g. `String` or concatenation\n  // with an empty string) allows this to continue working predictably when\n  // `XRegExp.proptotype.toString` is overridden\n  nativ.exec.call(/\\/([a-z]*)$/i, RegExp.prototype.toString.call(regex))[1];\n}\n/**\n * Determines whether a regex has extended instance data used to track capture names.\n *\n * @private\n * @param {RegExp} regex Regex to check.\n * @returns {boolean} Whether the regex uses named capture.\n */\n\nfunction hasNamedCapture(regex) {\n  return !!(regex[REGEX_DATA] && regex[REGEX_DATA].captureNames);\n}\n/**\n * Converts decimal to hexadecimal.\n *\n * @private\n * @param {Number|String} dec\n * @returns {string}\n */\n\nfunction hex(dec) {\n  return (0, _parseInt2[\"default\"])(dec, 10).toString(16);\n}\n/**\n * Checks whether the next nonignorable token after the specified position is a quantifier.\n *\n * @private\n * @param {String} pattern Pattern to search within.\n * @param {Number} pos Index in `pattern` to search at.\n * @param {String} flags Flags used by the pattern.\n * @returns {Boolean} Whether the next nonignorable token is a quantifier.\n */\n\nfunction isQuantifierNext(pattern, pos, flags) {\n  var inlineCommentPattern = '\\\\(\\\\?#[^)]*\\\\)';\n  var lineCommentPattern = '#[^#\\\\n]*';\n  var quantifierPattern = '[?*+]|{\\\\d+(?:,\\\\d*)?}';\n  return nativ.test.call((0, _includes[\"default\"])(flags).call(flags, 'x') ?\n  // Ignore any leading whitespace, line comments, and inline comments\n  /^(?:\\s|#[^#\\n]*|\\(\\?#[^)]*\\))*(?:[?*+]|{\\d+(?:,\\d*)?})/ :\n  // Ignore any leading inline comments\n  /^(?:\\(\\?#[^)]*\\))*(?:[?*+]|{\\d+(?:,\\d*)?})/, (0, _slice[\"default\"])(pattern).call(pattern, pos));\n}\n/**\n * Determines whether a value is of the specified type, by resolving its internal [[Class]].\n *\n * @private\n * @param {*} value Object to check.\n * @param {String} type Type to check for, in TitleCase.\n * @returns {boolean} Whether the object matches the type.\n */\n\nfunction isType(value, type) {\n  return toString.call(value) === \"[object \".concat(type, \"]\");\n}\n/**\n * Adds leading zeros if shorter than four characters. Used for fixed-length hexadecimal values.\n *\n * @private\n * @param {String} str\n * @returns {string}\n */\n\nfunction pad4(str) {\n  while (str.length < 4) {\n    str = \"0\".concat(str);\n  }\n  return str;\n}\n/**\n * Checks for flag-related errors, and strips/applies flags in a leading mode modifier. Offloads\n * the flag preparation logic from the `XRegExp` constructor.\n *\n * @private\n * @param {String} pattern Regex pattern, possibly with a leading mode modifier.\n * @param {String} flags Any combination of flags.\n * @returns {!Object} Object with properties `pattern` and `flags`.\n */\n\nfunction prepareFlags(pattern, flags) {\n  // Recent browsers throw on duplicate flags, so copy this behavior for nonnative flags\n  if (clipDuplicates(flags) !== flags) {\n    throw new SyntaxError(\"Invalid duplicate regex flag \".concat(flags));\n  } // Strip and apply a leading mode modifier with any combination of flags except g or y\n\n  pattern = nativ.replace.call(pattern, /^\\(\\?([\\w$]+)\\)/, function ($0, $1) {\n    if (nativ.test.call(/[gy]/, $1)) {\n      throw new SyntaxError(\"Cannot use flag g or y in mode modifier \".concat($0));\n    } // Allow duplicate flags within the mode modifier\n\n    flags = clipDuplicates(flags + $1);\n    return '';\n  }); // Throw on unknown native or nonnative flags\n\n  var _iterator = _createForOfIteratorHelper(flags),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var flag = _step.value;\n      if (!registeredFlags[flag]) {\n        throw new SyntaxError(\"Unknown regex flag \".concat(flag));\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return {\n    pattern: pattern,\n    flags: flags\n  };\n}\n/**\n * Prepares an options object from the given value.\n *\n * @private\n * @param {String|Object} value Value to convert to an options object.\n * @returns {Object} Options object.\n */\n\nfunction prepareOptions(value) {\n  var options = {};\n  if (isType(value, 'String')) {\n    (0, _forEach[\"default\"])(XRegExp).call(XRegExp, value, /[^\\s,]+/, function (match) {\n      options[match] = true;\n    });\n    return options;\n  }\n  return value;\n}\n/**\n * Registers a flag so it doesn't throw an 'unknown flag' error.\n *\n * @private\n * @param {String} flag Single-character flag to register.\n */\n\nfunction registerFlag(flag) {\n  if (!/^[\\w$]$/.test(flag)) {\n    throw new Error('Flag must be a single character A-Za-z0-9_$');\n  }\n  registeredFlags[flag] = true;\n}\n/**\n * Runs built-in and custom regex syntax tokens in reverse insertion order at the specified\n * position, until a match is found.\n *\n * @private\n * @param {String} pattern Original pattern from which an XRegExp object is being built.\n * @param {String} flags Flags being used to construct the regex.\n * @param {Number} pos Position to search for tokens within `pattern`.\n * @param {Number} scope Regex scope to apply: 'default' or 'class'.\n * @param {Object} context Context object to use for token handler functions.\n * @returns {Object} Object with properties `matchLength`, `output`, and `reparse`; or `null`.\n */\n\nfunction runTokens(pattern, flags, pos, scope, context) {\n  var i = tokens.length;\n  var leadChar = pattern[pos];\n  var result = null;\n  var match;\n  var t; // Run in reverse insertion order\n\n  while (i--) {\n    t = tokens[i];\n    if (t.leadChar && t.leadChar !== leadChar || t.scope !== scope && t.scope !== 'all' || t.flag && !(0, _includes[\"default\"])(flags).call(flags, t.flag)) {\n      continue;\n    }\n    match = XRegExp.exec(pattern, t.regex, pos, 'sticky');\n    if (match) {\n      result = {\n        matchLength: match[0].length,\n        output: t.handler.call(context, match, scope, flags),\n        reparse: t.reparse\n      }; // Finished with token tests\n\n      break;\n    }\n  }\n  return result;\n}\n/**\n * Enables or disables implicit astral mode opt-in. When enabled, flag A is automatically added to\n * all new regexes created by XRegExp. This causes an error to be thrown when creating regexes if\n * the Unicode Base addon is not available, since flag A is registered by that addon.\n *\n * @private\n * @param {Boolean} on `true` to enable; `false` to disable.\n */\n\nfunction setAstral(on) {\n  features.astral = on;\n}\n/**\n * Adds named capture groups to the `groups` property of match arrays. See here for details:\n * https://github.com/tc39/proposal-regexp-named-groups\n *\n * @private\n * @param {Boolean} on `true` to enable; `false` to disable.\n */\n\nfunction setNamespacing(on) {\n  features.namespacing = on;\n}\n/**\n * Returns the object, or throws an error if it is `null` or `undefined`. This is used to follow\n * the ES5 abstract operation `ToObject`.\n *\n * @private\n * @param {*} value Object to check and return.\n * @returns {*} The provided object.\n */\n\nfunction toObject(value) {\n  // null or undefined\n  if (value == null) {\n    throw new TypeError('Cannot convert null or undefined to object');\n  }\n  return value;\n} // ==--------------------------==\n// Constructor\n// ==--------------------------==\n\n/**\n * Creates an extended regular expression object for matching text with a pattern. Differs from a\n * native regular expression in that additional syntax and flags are supported. The returned object\n * is in fact a native `RegExp` and works with all native methods.\n *\n * @class XRegExp\n * @constructor\n * @param {String|RegExp} pattern Regex pattern string, or an existing regex object to copy.\n * @param {String} [flags] Any combination of flags.\n *   Native flags:\n *     - `g` - global\n *     - `i` - ignore case\n *     - `m` - multiline anchors\n *     - `u` - unicode (ES6)\n *     - `y` - sticky (Firefox 3+, ES6)\n *   Additional XRegExp flags:\n *     - `n` - explicit capture\n *     - `s` - dot matches all (aka singleline)\n *     - `x` - free-spacing and line comments (aka extended)\n *     - `A` - astral (requires the Unicode Base addon)\n *   Flags cannot be provided when constructing one `RegExp` from another.\n * @returns {RegExp} Extended regular expression object.\n * @example\n *\n * // With named capture and flag x\n * XRegExp(`(?<year>  [0-9]{4} ) -?  # year\n *          (?<month> [0-9]{2} ) -?  # month\n *          (?<day>   [0-9]{2} )     # day`, 'x');\n *\n * // Providing a regex object copies it. Native regexes are recompiled using native (not XRegExp)\n * // syntax. Copies maintain extended data, are augmented with `XRegExp.prototype` properties, and\n * // have fresh `lastIndex` properties (set to zero).\n * XRegExp(/regex/);\n */\n\nfunction XRegExp(pattern, flags) {\n  if (XRegExp.isRegExp(pattern)) {\n    if (flags !== undefined) {\n      throw new TypeError('Cannot supply flags when copying a RegExp');\n    }\n    return copyRegex(pattern);\n  } // Copy the argument behavior of `RegExp`\n\n  pattern = pattern === undefined ? '' : String(pattern);\n  flags = flags === undefined ? '' : String(flags);\n  if (XRegExp.isInstalled('astral') && !(0, _includes[\"default\"])(flags).call(flags, 'A')) {\n    // This causes an error to be thrown if the Unicode Base addon is not available\n    flags += 'A';\n  }\n  if (!patternCache[pattern]) {\n    patternCache[pattern] = {};\n  }\n  if (!patternCache[pattern][flags]) {\n    var context = {\n      hasNamedCapture: false,\n      captureNames: []\n    };\n    var scope = defaultScope;\n    var output = '';\n    var pos = 0;\n    var result; // Check for flag-related errors, and strip/apply flags in a leading mode modifier\n\n    var applied = prepareFlags(pattern, flags);\n    var appliedPattern = applied.pattern;\n    var appliedFlags = (0, _flags[\"default\"])(applied); // Use XRegExp's tokens to translate the pattern to a native regex pattern.\n    // `appliedPattern.length` may change on each iteration if tokens use `reparse`\n\n    while (pos < appliedPattern.length) {\n      do {\n        // Check for custom tokens at the current position\n        result = runTokens(appliedPattern, appliedFlags, pos, scope, context); // If the matched token used the `reparse` option, splice its output into the\n        // pattern before running tokens again at the same position\n\n        if (result && result.reparse) {\n          appliedPattern = (0, _slice[\"default\"])(appliedPattern).call(appliedPattern, 0, pos) + result.output + (0, _slice[\"default\"])(appliedPattern).call(appliedPattern, pos + result.matchLength);\n        }\n      } while (result && result.reparse);\n      if (result) {\n        output += result.output;\n        pos += result.matchLength || 1;\n      } else {\n        // Get the native token at the current position\n        var _XRegExp$exec = XRegExp.exec(appliedPattern, nativeTokens[scope], pos, 'sticky'),\n          _XRegExp$exec2 = (0, _slicedToArray2[\"default\"])(_XRegExp$exec, 1),\n          token = _XRegExp$exec2[0];\n        output += token;\n        pos += token.length;\n        if (token === '[' && scope === defaultScope) {\n          scope = classScope;\n        } else if (token === ']' && scope === classScope) {\n          scope = defaultScope;\n        }\n      }\n    }\n    patternCache[pattern][flags] = {\n      // Use basic cleanup to collapse repeated empty groups like `(?:)(?:)` to `(?:)`. Empty\n      // groups are sometimes inserted during regex transpilation in order to keep tokens\n      // separated. However, more than one empty group in a row is never needed.\n      pattern: nativ.replace.call(output, /(?:\\(\\?:\\))+/g, '(?:)'),\n      // Strip all but native flags\n      flags: nativ.replace.call(appliedFlags, /[^gimuy]+/g, ''),\n      // `context.captureNames` has an item for each capturing group, even if unnamed\n      captures: context.hasNamedCapture ? context.captureNames : null\n    };\n  }\n  var generated = patternCache[pattern][flags];\n  return augment(new RegExp(generated.pattern, (0, _flags[\"default\"])(generated)), generated.captures, pattern, flags);\n} // Add `RegExp.prototype` to the prototype chain\n\nXRegExp.prototype = /(?:)/; // ==--------------------------==\n// Public properties\n// ==--------------------------==\n\n/**\n * The XRegExp version number as a string containing three dot-separated parts. For example,\n * '2.0.0-beta-3'.\n *\n * @static\n * @memberOf XRegExp\n * @type String\n */\n\nXRegExp.version = '4.4.1'; // ==--------------------------==\n// Public methods\n// ==--------------------------==\n// Intentionally undocumented; used in tests and addons\n\nXRegExp._clipDuplicates = clipDuplicates;\nXRegExp._hasNativeFlag = hasNativeFlag;\nXRegExp._dec = dec;\nXRegExp._hex = hex;\nXRegExp._pad4 = pad4;\n/**\n * Extends XRegExp syntax and allows custom flags. This is used internally and can be used to\n * create XRegExp addons. If more than one token can match the same string, the last added wins.\n *\n * @memberOf XRegExp\n * @param {RegExp} regex Regex object that matches the new token.\n * @param {Function} handler Function that returns a new pattern string (using native regex syntax)\n *   to replace the matched token within all future XRegExp regexes. Has access to persistent\n *   properties of the regex being built, through `this`. Invoked with three arguments:\n *   - The match array, with named backreference properties.\n *   - The regex scope where the match was found: 'default' or 'class'.\n *   - The flags used by the regex, including any flags in a leading mode modifier.\n *   The handler function becomes part of the XRegExp construction process, so be careful not to\n *   construct XRegExps within the function or you will trigger infinite recursion.\n * @param {Object} [options] Options object with optional properties:\n *   - `scope` {String} Scope where the token applies: 'default', 'class', or 'all'.\n *   - `flag` {String} Single-character flag that triggers the token. This also registers the\n *     flag, which prevents XRegExp from throwing an 'unknown flag' error when the flag is used.\n *   - `optionalFlags` {String} Any custom flags checked for within the token `handler` that are\n *     not required to trigger the token. This registers the flags, to prevent XRegExp from\n *     throwing an 'unknown flag' error when any of the flags are used.\n *   - `reparse` {Boolean} Whether the `handler` function's output should not be treated as\n *     final, and instead be reparseable by other tokens (including the current token). Allows\n *     token chaining or deferring.\n *   - `leadChar` {String} Single character that occurs at the beginning of any successful match\n *     of the token (not always applicable). This doesn't change the behavior of the token unless\n *     you provide an erroneous value. However, providing it can increase the token's performance\n *     since the token can be skipped at any positions where this character doesn't appear.\n * @example\n *\n * // Basic usage: Add \\a for the ALERT control code\n * XRegExp.addToken(\n *   /\\\\a/,\n *   () => '\\\\x07',\n *   {scope: 'all'}\n * );\n * XRegExp('\\\\a[\\\\a-\\\\n]+').test('\\x07\\n\\x07'); // -> true\n *\n * // Add the U (ungreedy) flag from PCRE and RE2, which reverses greedy and lazy quantifiers.\n * // Since `scope` is not specified, it uses 'default' (i.e., transformations apply outside of\n * // character classes only)\n * XRegExp.addToken(\n *   /([?*+]|{\\d+(?:,\\d*)?})(\\??)/,\n *   (match) => `${match[1]}${match[2] ? '' : '?'}`,\n *   {flag: 'U'}\n * );\n * XRegExp('a+', 'U').exec('aaa')[0]; // -> 'a'\n * XRegExp('a+?', 'U').exec('aaa')[0]; // -> 'aaa'\n */\n\nXRegExp.addToken = function (regex, handler, options) {\n  options = options || {};\n  var _options = options,\n    optionalFlags = _options.optionalFlags;\n  if (options.flag) {\n    registerFlag(options.flag);\n  }\n  if (optionalFlags) {\n    optionalFlags = nativ.split.call(optionalFlags, '');\n    var _iterator2 = _createForOfIteratorHelper(optionalFlags),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var flag = _step2.value;\n        registerFlag(flag);\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  } // Add to the private list of syntax tokens\n\n  tokens.push({\n    regex: copyRegex(regex, {\n      addG: true,\n      addY: hasNativeY,\n      isInternalOnly: true\n    }),\n    handler: handler,\n    scope: options.scope || defaultScope,\n    flag: options.flag,\n    reparse: options.reparse,\n    leadChar: options.leadChar\n  }); // Reset the pattern cache used by the `XRegExp` constructor, since the same pattern and flags\n  // might now produce different results\n\n  XRegExp.cache.flush('patterns');\n};\n/**\n * Caches and returns the result of calling `XRegExp(pattern, flags)`. On any subsequent call with\n * the same pattern and flag combination, the cached copy of the regex is returned.\n *\n * @memberOf XRegExp\n * @param {String} pattern Regex pattern string.\n * @param {String} [flags] Any combination of XRegExp flags.\n * @returns {RegExp} Cached XRegExp object.\n * @example\n *\n * while (match = XRegExp.cache('.', 'gs').exec(str)) {\n *   // The regex is compiled once only\n * }\n */\n\nXRegExp.cache = function (pattern, flags) {\n  if (!regexCache[pattern]) {\n    regexCache[pattern] = {};\n  }\n  return regexCache[pattern][flags] || (regexCache[pattern][flags] = XRegExp(pattern, flags));\n}; // Intentionally undocumented; used in tests\n\nXRegExp.cache.flush = function (cacheName) {\n  if (cacheName === 'patterns') {\n    // Flush the pattern cache used by the `XRegExp` constructor\n    patternCache = {};\n  } else {\n    // Flush the regex cache populated by `XRegExp.cache`\n    regexCache = {};\n  }\n};\n/**\n * Escapes any regular expression metacharacters, for use when matching literal strings. The result\n * can safely be used at any point within a regex that uses any flags.\n *\n * @memberOf XRegExp\n * @param {String} str String to escape.\n * @returns {string} String with regex metacharacters escaped.\n * @example\n *\n * XRegExp.escape('Escaped? <.>');\n * // -> 'Escaped\\?\\ <\\.>'\n */\n\nXRegExp.escape = function (str) {\n  return nativ.replace.call(toObject(str), /[-\\[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n};\n/**\n * Executes a regex search in a specified string. Returns a match array or `null`. If the provided\n * regex uses named capture, named backreference properties are included on the match array.\n * Optional `pos` and `sticky` arguments specify the search start position, and whether the match\n * must start at the specified position only. The `lastIndex` property of the provided regex is not\n * used, but is updated for compatibility. Also fixes browser bugs compared to the native\n * `RegExp.prototype.exec` and can be used reliably cross-browser.\n *\n * @memberOf XRegExp\n * @param {String} str String to search.\n * @param {RegExp} regex Regex to search with.\n * @param {Number} [pos=0] Zero-based index at which to start the search.\n * @param {Boolean|String} [sticky=false] Whether the match must start at the specified position\n *   only. The string `'sticky'` is accepted as an alternative to `true`.\n * @returns {Array} Match array with named backreference properties, or `null`.\n * @example\n *\n * // Basic use, with named backreference\n * let match = XRegExp.exec('U+2620', XRegExp('U\\\\+(?<hex>[0-9A-F]{4})'));\n * match.hex; // -> '2620'\n *\n * // With pos and sticky, in a loop\n * let pos = 2, result = [], match;\n * while (match = XRegExp.exec('<1><2><3><4>5<6>', /<(\\d)>/, pos, 'sticky')) {\n *   result.push(match[1]);\n *   pos = match.index + match[0].length;\n * }\n * // result -> ['2', '3', '4']\n */\n\nXRegExp.exec = function (str, regex, pos, sticky) {\n  var cacheKey = 'g';\n  var addY = false;\n  var fakeY = false;\n  var match;\n  addY = hasNativeY && !!(sticky || regex.sticky && sticky !== false);\n  if (addY) {\n    cacheKey += 'y';\n  } else if (sticky) {\n    // Simulate sticky matching by appending an empty capture to the original regex. The\n    // resulting regex will succeed no matter what at the current index (set with `lastIndex`),\n    // and will not search the rest of the subject string. We'll know that the original regex\n    // has failed if that last capture is `''` rather than `undefined` (i.e., if that last\n    // capture participated in the match).\n    fakeY = true;\n    cacheKey += 'FakeY';\n  }\n  regex[REGEX_DATA] = regex[REGEX_DATA] || {}; // Shares cached copies with `XRegExp.match`/`replace`\n\n  var r2 = regex[REGEX_DATA][cacheKey] || (regex[REGEX_DATA][cacheKey] = copyRegex(regex, {\n    addG: true,\n    addY: addY,\n    source: fakeY ? \"\".concat(regex.source, \"|()\") : undefined,\n    removeY: sticky === false,\n    isInternalOnly: true\n  }));\n  pos = pos || 0;\n  r2.lastIndex = pos; // Fixed `exec` required for `lastIndex` fix, named backreferences, etc.\n\n  match = fixed.exec.call(r2, str); // Get rid of the capture added by the pseudo-sticky matcher if needed. An empty string means\n  // the original regexp failed (see above).\n\n  if (fakeY && match && match.pop() === '') {\n    match = null;\n  }\n  if (regex.global) {\n    regex.lastIndex = match ? r2.lastIndex : 0;\n  }\n  return match;\n};\n/**\n * Executes a provided function once per regex match. Searches always start at the beginning of the\n * string and continue until the end, regardless of the state of the regex's `global` property and\n * initial `lastIndex`.\n *\n * @memberOf XRegExp\n * @param {String} str String to search.\n * @param {RegExp} regex Regex to search with.\n * @param {Function} callback Function to execute for each match. Invoked with four arguments:\n *   - The match array, with named backreference properties.\n *   - The zero-based match index.\n *   - The string being traversed.\n *   - The regex object being used to traverse the string.\n * @example\n *\n * // Extracts every other digit from a string\n * const evens = [];\n * XRegExp.forEach('1a2345', /\\d/, (match, i) => {\n *   if (i % 2) evens.push(+match[0]);\n * });\n * // evens -> [2, 4]\n */\n\nXRegExp.forEach = function (str, regex, callback) {\n  var pos = 0;\n  var i = -1;\n  var match;\n  while (match = XRegExp.exec(str, regex, pos)) {\n    // Because `regex` is provided to `callback`, the function could use the deprecated/\n    // nonstandard `RegExp.prototype.compile` to mutate the regex. However, since `XRegExp.exec`\n    // doesn't use `lastIndex` to set the search position, this can't lead to an infinite loop,\n    // at least. Actually, because of the way `XRegExp.exec` caches globalized versions of\n    // regexes, mutating the regex will not have any effect on the iteration or matched strings,\n    // which is a nice side effect that brings extra safety.\n    callback(match, ++i, str, regex);\n    pos = match.index + (match[0].length || 1);\n  }\n};\n/**\n * Copies a regex object and adds flag `g`. The copy maintains extended data, is augmented with\n * `XRegExp.prototype` properties, and has a fresh `lastIndex` property (set to zero). Native\n * regexes are not recompiled using XRegExp syntax.\n *\n * @memberOf XRegExp\n * @param {RegExp} regex Regex to globalize.\n * @returns {RegExp} Copy of the provided regex with flag `g` added.\n * @example\n *\n * const globalCopy = XRegExp.globalize(/regex/);\n * globalCopy.global; // -> true\n */\n\nXRegExp.globalize = function (regex) {\n  return copyRegex(regex, {\n    addG: true\n  });\n};\n/**\n * Installs optional features according to the specified options. Can be undone using\n * `XRegExp.uninstall`.\n *\n * @memberOf XRegExp\n * @param {Object|String} options Options object or string.\n * @example\n *\n * // With an options object\n * XRegExp.install({\n *   // Enables support for astral code points in Unicode addons (implicitly sets flag A)\n *   astral: true,\n *\n *   // Adds named capture groups to the `groups` property of matches\n *   namespacing: true\n * });\n *\n * // With an options string\n * XRegExp.install('astral namespacing');\n */\n\nXRegExp.install = function (options) {\n  options = prepareOptions(options);\n  if (!features.astral && options.astral) {\n    setAstral(true);\n  }\n  if (!features.namespacing && options.namespacing) {\n    setNamespacing(true);\n  }\n};\n/**\n * Checks whether an individual optional feature is installed.\n *\n * @memberOf XRegExp\n * @param {String} feature Name of the feature to check. One of:\n *   - `astral`\n *   - `namespacing`\n * @returns {boolean} Whether the feature is installed.\n * @example\n *\n * XRegExp.isInstalled('astral');\n */\n\nXRegExp.isInstalled = function (feature) {\n  return !!features[feature];\n};\n/**\n * Returns `true` if an object is a regex; `false` if it isn't. This works correctly for regexes\n * created in another frame, when `instanceof` and `constructor` checks would fail.\n *\n * @memberOf XRegExp\n * @param {*} value Object to check.\n * @returns {boolean} Whether the object is a `RegExp` object.\n * @example\n *\n * XRegExp.isRegExp('string'); // -> false\n * XRegExp.isRegExp(/regex/i); // -> true\n * XRegExp.isRegExp(RegExp('^', 'm')); // -> true\n * XRegExp.isRegExp(XRegExp('(?s).')); // -> true\n */\n\nXRegExp.isRegExp = function (value) {\n  return toString.call(value) === '[object RegExp]';\n}; // isType(value, 'RegExp');\n\n/**\n * Returns the first matched string, or in global mode, an array containing all matched strings.\n * This is essentially a more convenient re-implementation of `String.prototype.match` that gives\n * the result types you actually want (string instead of `exec`-style array in match-first mode,\n * and an empty array instead of `null` when no matches are found in match-all mode). It also lets\n * you override flag g and ignore `lastIndex`, and fixes browser bugs.\n *\n * @memberOf XRegExp\n * @param {String} str String to search.\n * @param {RegExp} regex Regex to search with.\n * @param {String} [scope='one'] Use 'one' to return the first match as a string. Use 'all' to\n *   return an array of all matched strings. If not explicitly specified and `regex` uses flag g,\n *   `scope` is 'all'.\n * @returns {String|Array} In match-first mode: First match as a string, or `null`. In match-all\n *   mode: Array of all matched strings, or an empty array.\n * @example\n *\n * // Match first\n * XRegExp.match('abc', /\\w/); // -> 'a'\n * XRegExp.match('abc', /\\w/g, 'one'); // -> 'a'\n * XRegExp.match('abc', /x/g, 'one'); // -> null\n *\n * // Match all\n * XRegExp.match('abc', /\\w/g); // -> ['a', 'b', 'c']\n * XRegExp.match('abc', /\\w/, 'all'); // -> ['a', 'b', 'c']\n * XRegExp.match('abc', /x/, 'all'); // -> []\n */\n\nXRegExp.match = function (str, regex, scope) {\n  var global = regex.global && scope !== 'one' || scope === 'all';\n  var cacheKey = (global ? 'g' : '') + (regex.sticky ? 'y' : '') || 'noGY';\n  regex[REGEX_DATA] = regex[REGEX_DATA] || {}; // Shares cached copies with `XRegExp.exec`/`replace`\n\n  var r2 = regex[REGEX_DATA][cacheKey] || (regex[REGEX_DATA][cacheKey] = copyRegex(regex, {\n    addG: !!global,\n    removeG: scope === 'one',\n    isInternalOnly: true\n  }));\n  var result = nativ.match.call(toObject(str), r2);\n  if (regex.global) {\n    regex.lastIndex = scope === 'one' && result ?\n    // Can't use `r2.lastIndex` since `r2` is nonglobal in this case\n    result.index + result[0].length : 0;\n  }\n  return global ? result || [] : result && result[0];\n};\n/**\n * Retrieves the matches from searching a string using a chain of regexes that successively search\n * within previous matches. The provided `chain` array can contain regexes and or objects with\n * `regex` and `backref` properties. When a backreference is specified, the named or numbered\n * backreference is passed forward to the next regex or returned.\n *\n * @memberOf XRegExp\n * @param {String} str String to search.\n * @param {Array} chain Regexes that each search for matches within preceding results.\n * @returns {Array} Matches by the last regex in the chain, or an empty array.\n * @example\n *\n * // Basic usage; matches numbers within <b> tags\n * XRegExp.matchChain('1 <b>2</b> 3 <b>4 a 56</b>', [\n *   XRegExp('(?is)<b>.*?</b>'),\n *   /\\d+/\n * ]);\n * // -> ['2', '4', '56']\n *\n * // Passing forward and returning specific backreferences\n * html = '<a href=\"http://xregexp.com/api/\">XRegExp</a>\\\n *         <a href=\"http://www.google.com/\">Google</a>';\n * XRegExp.matchChain(html, [\n *   {regex: /<a href=\"([^\"]+)\">/i, backref: 1},\n *   {regex: XRegExp('(?i)^https?://(?<domain>[^/?#]+)'), backref: 'domain'}\n * ]);\n * // -> ['xregexp.com', 'www.google.com']\n */\n\nXRegExp.matchChain = function (str, chain) {\n  return function recurseChain(values, level) {\n    var item = chain[level].regex ? chain[level] : {\n      regex: chain[level]\n    };\n    var matches = [];\n    function addMatch(match) {\n      if (item.backref) {\n        var ERR_UNDEFINED_GROUP = \"Backreference to undefined group: \".concat(item.backref);\n        var isNamedBackref = isNaN(item.backref);\n        if (isNamedBackref && XRegExp.isInstalled('namespacing')) {\n          // `groups` has `null` as prototype, so using `in` instead of `hasOwnProperty`\n          if (!(item.backref in match.groups)) {\n            throw new ReferenceError(ERR_UNDEFINED_GROUP);\n          }\n        } else if (!match.hasOwnProperty(item.backref)) {\n          throw new ReferenceError(ERR_UNDEFINED_GROUP);\n        }\n        var backrefValue = isNamedBackref && XRegExp.isInstalled('namespacing') ? match.groups[item.backref] : match[item.backref];\n        matches.push(backrefValue || '');\n      } else {\n        matches.push(match[0]);\n      }\n    }\n    var _iterator3 = _createForOfIteratorHelper(values),\n      _step3;\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var value = _step3.value;\n        (0, _forEach[\"default\"])(XRegExp).call(XRegExp, value, item.regex, addMatch);\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n    return level === chain.length - 1 || !matches.length ? matches : recurseChain(matches, level + 1);\n  }([str], 0);\n};\n/**\n * Returns a new string with one or all matches of a pattern replaced. The pattern can be a string\n * or regex, and the replacement can be a string or a function to be called for each match. To\n * perform a global search and replace, use the optional `scope` argument or include flag g if using\n * a regex. Replacement strings can use `${n}` or `$<n>` for named and numbered backreferences.\n * Replacement functions can use named backreferences via `arguments[0].name`. Also fixes browser\n * bugs compared to the native `String.prototype.replace` and can be used reliably cross-browser.\n *\n * @memberOf XRegExp\n * @param {String} str String to search.\n * @param {RegExp|String} search Search pattern to be replaced.\n * @param {String|Function} replacement Replacement string or a function invoked to create it.\n *   Replacement strings can include special replacement syntax:\n *     - $$ - Inserts a literal $ character.\n *     - $&, $0 - Inserts the matched substring.\n *     - $` - Inserts the string that precedes the matched substring (left context).\n *     - $' - Inserts the string that follows the matched substring (right context).\n *     - $n, $nn - Where n/nn are digits referencing an existent capturing group, inserts\n *       backreference n/nn.\n *     - ${n}, $<n> - Where n is a name or any number of digits that reference an existent capturing\n *       group, inserts backreference n.\n *   Replacement functions are invoked with three or more arguments:\n *     - The matched substring (corresponds to $& above). Named backreferences are accessible as\n *       properties of this first argument.\n *     - 0..n arguments, one for each backreference (corresponding to $1, $2, etc. above).\n *     - The zero-based index of the match within the total search string.\n *     - The total string being searched.\n * @param {String} [scope='one'] Use 'one' to replace the first match only, or 'all'. If not\n *   explicitly specified and using a regex with flag g, `scope` is 'all'.\n * @returns {String} New string with one or all matches replaced.\n * @example\n *\n * // Regex search, using named backreferences in replacement string\n * const name = XRegExp('(?<first>\\\\w+) (?<last>\\\\w+)');\n * XRegExp.replace('John Smith', name, '$<last>, $<first>');\n * // -> 'Smith, John'\n *\n * // Regex search, using named backreferences in replacement function\n * XRegExp.replace('John Smith', name, (match) => `${match.last}, ${match.first}`);\n * // -> 'Smith, John'\n *\n * // String search, with replace-all\n * XRegExp.replace('RegExp builds RegExps', 'RegExp', 'XRegExp', 'all');\n * // -> 'XRegExp builds XRegExps'\n */\n\nXRegExp.replace = function (str, search, replacement, scope) {\n  var isRegex = XRegExp.isRegExp(search);\n  var global = search.global && scope !== 'one' || scope === 'all';\n  var cacheKey = (global ? 'g' : '') + (search.sticky ? 'y' : '') || 'noGY';\n  var s2 = search;\n  if (isRegex) {\n    search[REGEX_DATA] = search[REGEX_DATA] || {}; // Shares cached copies with `XRegExp.exec`/`match`. Since a copy is used, `search`'s\n    // `lastIndex` isn't updated *during* replacement iterations\n\n    s2 = search[REGEX_DATA][cacheKey] || (search[REGEX_DATA][cacheKey] = copyRegex(search, {\n      addG: !!global,\n      removeG: scope === 'one',\n      isInternalOnly: true\n    }));\n  } else if (global) {\n    s2 = new RegExp(XRegExp.escape(String(search)), 'g');\n  } // Fixed `replace` required for named backreferences, etc.\n\n  var result = fixed.replace.call(toObject(str), s2, replacement);\n  if (isRegex && search.global) {\n    // Fixes IE, Safari bug (last tested IE 9, Safari 5.1)\n    search.lastIndex = 0;\n  }\n  return result;\n};\n/**\n * Performs batch processing of string replacements. Used like `XRegExp.replace`, but accepts an\n * array of replacement details. Later replacements operate on the output of earlier replacements.\n * Replacement details are accepted as an array with a regex or string to search for, the\n * replacement string or function, and an optional scope of 'one' or 'all'. Uses the XRegExp\n * replacement text syntax, which supports named backreference properties via `${name}` or\n * `$<name>`.\n *\n * @memberOf XRegExp\n * @param {String} str String to search.\n * @param {Array} replacements Array of replacement detail arrays.\n * @returns {String} New string with all replacements.\n * @example\n *\n * str = XRegExp.replaceEach(str, [\n *   [XRegExp('(?<name>a)'), 'z${name}'],\n *   [/b/gi, 'y'],\n *   [/c/g, 'x', 'one'], // scope 'one' overrides /g\n *   [/d/, 'w', 'all'],  // scope 'all' overrides lack of /g\n *   ['e', 'v', 'all'],  // scope 'all' allows replace-all for strings\n *   [/f/g, ($0) => $0.toUpperCase()]\n * ]);\n */\n\nXRegExp.replaceEach = function (str, replacements) {\n  var _iterator4 = _createForOfIteratorHelper(replacements),\n    _step4;\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var r = _step4.value;\n      str = XRegExp.replace(str, r[0], r[1], r[2]);\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n  return str;\n};\n/**\n * Splits a string into an array of strings using a regex or string separator. Matches of the\n * separator are not included in the result array. However, if `separator` is a regex that contains\n * capturing groups, backreferences are spliced into the result each time `separator` is matched.\n * Fixes browser bugs compared to the native `String.prototype.split` and can be used reliably\n * cross-browser.\n *\n * @memberOf XRegExp\n * @param {String} str String to split.\n * @param {RegExp|String} separator Regex or string to use for separating the string.\n * @param {Number} [limit] Maximum number of items to include in the result array.\n * @returns {Array} Array of substrings.\n * @example\n *\n * // Basic use\n * XRegExp.split('a b c', ' ');\n * // -> ['a', 'b', 'c']\n *\n * // With limit\n * XRegExp.split('a b c', ' ', 2);\n * // -> ['a', 'b']\n *\n * // Backreferences in result array\n * XRegExp.split('..word1..', /([a-z]+)(\\d+)/i);\n * // -> ['..', 'word', '1', '..']\n */\n\nXRegExp.split = function (str, separator, limit) {\n  return fixed.split.call(toObject(str), separator, limit);\n};\n/**\n * Executes a regex search in a specified string. Returns `true` or `false`. Optional `pos` and\n * `sticky` arguments specify the search start position, and whether the match must start at the\n * specified position only. The `lastIndex` property of the provided regex is not used, but is\n * updated for compatibility. Also fixes browser bugs compared to the native\n * `RegExp.prototype.test` and can be used reliably cross-browser.\n *\n * @memberOf XRegExp\n * @param {String} str String to search.\n * @param {RegExp} regex Regex to search with.\n * @param {Number} [pos=0] Zero-based index at which to start the search.\n * @param {Boolean|String} [sticky=false] Whether the match must start at the specified position\n *   only. The string `'sticky'` is accepted as an alternative to `true`.\n * @returns {boolean} Whether the regex matched the provided value.\n * @example\n *\n * // Basic use\n * XRegExp.test('abc', /c/); // -> true\n *\n * // With pos and sticky\n * XRegExp.test('abc', /c/, 0, 'sticky'); // -> false\n * XRegExp.test('abc', /c/, 2, 'sticky'); // -> true\n */\n// Do this the easy way :-)\n\nXRegExp.test = function (str, regex, pos, sticky) {\n  return !!XRegExp.exec(str, regex, pos, sticky);\n};\n/**\n * Uninstalls optional features according to the specified options. All optional features start out\n * uninstalled, so this is used to undo the actions of `XRegExp.install`.\n *\n * @memberOf XRegExp\n * @param {Object|String} options Options object or string.\n * @example\n *\n * // With an options object\n * XRegExp.uninstall({\n *   // Disables support for astral code points in Unicode addons\n *   astral: true,\n *\n *   // Don't add named capture groups to the `groups` property of matches\n *   namespacing: true\n * });\n *\n * // With an options string\n * XRegExp.uninstall('astral namespacing');\n */\n\nXRegExp.uninstall = function (options) {\n  options = prepareOptions(options);\n  if (features.astral && options.astral) {\n    setAstral(false);\n  }\n  if (features.namespacing && options.namespacing) {\n    setNamespacing(false);\n  }\n};\n/**\n * Returns an XRegExp object that is the union of the given patterns. Patterns can be provided as\n * regex objects or strings. Metacharacters are escaped in patterns provided as strings.\n * Backreferences in provided regex objects are automatically renumbered to work correctly within\n * the larger combined pattern. Native flags used by provided regexes are ignored in favor of the\n * `flags` argument.\n *\n * @memberOf XRegExp\n * @param {Array} patterns Regexes and strings to combine.\n * @param {String} [flags] Any combination of XRegExp flags.\n * @param {Object} [options] Options object with optional properties:\n *   - `conjunction` {String} Type of conjunction to use: 'or' (default) or 'none'.\n * @returns {RegExp} Union of the provided regexes and strings.\n * @example\n *\n * XRegExp.union(['a+b*c', /(dogs)\\1/, /(cats)\\1/], 'i');\n * // -> /a\\+b\\*c|(dogs)\\1|(cats)\\2/i\n *\n * XRegExp.union([/man/, /bear/, /pig/], 'i', {conjunction: 'none'});\n * // -> /manbearpig/i\n */\n\nXRegExp.union = function (patterns, flags, options) {\n  options = options || {};\n  var conjunction = options.conjunction || 'or';\n  var numCaptures = 0;\n  var numPriorCaptures;\n  var captureNames;\n  function rewrite(match, paren, backref) {\n    var name = captureNames[numCaptures - numPriorCaptures]; // Capturing group\n\n    if (paren) {\n      ++numCaptures; // If the current capture has a name, preserve the name\n\n      if (name) {\n        return \"(?<\".concat(name, \">\");\n      } // Backreference\n    } else if (backref) {\n      // Rewrite the backreference\n      return \"\\\\\".concat(+backref + numPriorCaptures);\n    }\n    return match;\n  }\n  if (!(isType(patterns, 'Array') && patterns.length)) {\n    throw new TypeError('Must provide a nonempty array of patterns to merge');\n  }\n  var parts = /(\\()(?!\\?)|\\\\([1-9]\\d*)|\\\\[\\s\\S]|\\[(?:[^\\\\\\]]|\\\\[\\s\\S])*\\]/g;\n  var output = [];\n  var _iterator5 = _createForOfIteratorHelper(patterns),\n    _step5;\n  try {\n    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n      var pattern = _step5.value;\n      if (XRegExp.isRegExp(pattern)) {\n        numPriorCaptures = numCaptures;\n        captureNames = pattern[REGEX_DATA] && pattern[REGEX_DATA].captureNames || []; // Rewrite backreferences. Passing to XRegExp dies on octals and ensures patterns are\n        // independently valid; helps keep this simple. Named captures are put back\n\n        output.push(nativ.replace.call(XRegExp(pattern.source).source, parts, rewrite));\n      } else {\n        output.push(XRegExp.escape(pattern));\n      }\n    }\n  } catch (err) {\n    _iterator5.e(err);\n  } finally {\n    _iterator5.f();\n  }\n  var separator = conjunction === 'none' ? '' : '|';\n  return XRegExp(output.join(separator), flags);\n}; // ==--------------------------==\n// Fixed/extended native methods\n// ==--------------------------==\n\n/**\n * Adds named capture support (with backreferences returned as `result.name`), and fixes browser\n * bugs in the native `RegExp.prototype.exec`. Use via `XRegExp.exec`.\n *\n * @memberOf RegExp\n * @param {String} str String to search.\n * @returns {Array} Match array with named backreference properties, or `null`.\n */\n\nfixed.exec = function (str) {\n  var origLastIndex = this.lastIndex;\n  var match = nativ.exec.apply(this, arguments);\n  if (match) {\n    // Fix browsers whose `exec` methods don't return `undefined` for nonparticipating capturing\n    // groups. This fixes IE 5.5-8, but not IE 9's quirks mode or emulation of older IEs. IE 9\n    // in standards mode follows the spec.\n    if (!correctExecNpcg && match.length > 1 && (0, _includes[\"default\"])(match).call(match, '')) {\n      var _context3;\n      var r2 = copyRegex(this, {\n        removeG: true,\n        isInternalOnly: true\n      }); // Using `str.slice(match.index)` rather than `match[0]` in case lookahead allowed\n      // matching due to characters outside the match\n\n      nativ.replace.call((0, _slice[\"default\"])(_context3 = String(str)).call(_context3, match.index), r2, function () {\n        var len = arguments.length; // Skip index 0 and the last 2\n\n        for (var i = 1; i < len - 2; ++i) {\n          if ((i < 0 || arguments.length <= i ? undefined : arguments[i]) === undefined) {\n            match[i] = undefined;\n          }\n        }\n      });\n    } // Attach named capture properties\n\n    var groupsObject = match;\n    if (XRegExp.isInstalled('namespacing')) {\n      // https://tc39.github.io/proposal-regexp-named-groups/#sec-regexpbuiltinexec\n      match.groups = (0, _create[\"default\"])(null);\n      groupsObject = match.groups;\n    }\n    if (this[REGEX_DATA] && this[REGEX_DATA].captureNames) {\n      // Skip index 0\n      for (var i = 1; i < match.length; ++i) {\n        var name = this[REGEX_DATA].captureNames[i - 1];\n        if (name) {\n          groupsObject[name] = match[i];\n        }\n      }\n    } // Fix browsers that increment `lastIndex` after zero-length matches\n\n    if (this.global && !match[0].length && this.lastIndex > match.index) {\n      this.lastIndex = match.index;\n    }\n  }\n  if (!this.global) {\n    // Fixes IE, Opera bug (last tested IE 9, Opera 11.6)\n    this.lastIndex = origLastIndex;\n  }\n  return match;\n};\n/**\n * Fixes browser bugs in the native `RegExp.prototype.test`.\n *\n * @memberOf RegExp\n * @param {String} str String to search.\n * @returns {boolean} Whether the regex matched the provided value.\n */\n\nfixed.test = function (str) {\n  // Do this the easy way :-)\n  return !!fixed.exec.call(this, str);\n};\n/**\n * Adds named capture support (with backreferences returned as `result.name`), and fixes browser\n * bugs in the native `String.prototype.match`.\n *\n * @memberOf String\n * @param {RegExp|*} regex Regex to search with. If not a regex object, it is passed to `RegExp`.\n * @returns {Array} If `regex` uses flag g, an array of match strings or `null`. Without flag g,\n *   the result of calling `regex.exec(this)`.\n */\n\nfixed.match = function (regex) {\n  if (!XRegExp.isRegExp(regex)) {\n    // Use the native `RegExp` rather than `XRegExp`\n    regex = new RegExp(regex);\n  } else if (regex.global) {\n    var result = nativ.match.apply(this, arguments); // Fixes IE bug\n\n    regex.lastIndex = 0;\n    return result;\n  }\n  return fixed.exec.call(regex, toObject(this));\n};\n/**\n * Adds support for `${n}` (or `$<n>`) tokens for named and numbered backreferences in replacement\n * text, and provides named backreferences to replacement functions as `arguments[0].name`. Also\n * fixes browser bugs in replacement text syntax when performing a replacement using a nonregex\n * search value, and the value of a replacement regex's `lastIndex` property during replacement\n * iterations and upon completion. Note that this doesn't support SpiderMonkey's proprietary third\n * (`flags`) argument. Use via `XRegExp.replace`.\n *\n * @memberOf String\n * @param {RegExp|String} search Search pattern to be replaced.\n * @param {String|Function} replacement Replacement string or a function invoked to create it.\n * @returns {string} New string with one or all matches replaced.\n */\n\nfixed.replace = function (search, replacement) {\n  var isRegex = XRegExp.isRegExp(search);\n  var origLastIndex;\n  var captureNames;\n  var result;\n  if (isRegex) {\n    if (search[REGEX_DATA]) {\n      captureNames = search[REGEX_DATA].captureNames;\n    } // Only needed if `search` is nonglobal\n\n    origLastIndex = search.lastIndex;\n  } else {\n    search += ''; // Type-convert\n  } // Don't use `typeof`; some older browsers return 'function' for regex objects\n\n  if (isType(replacement, 'Function')) {\n    // Stringifying `this` fixes a bug in IE < 9 where the last argument in replacement\n    // functions isn't type-converted to a string\n    result = nativ.replace.call(String(this), search, function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      if (captureNames) {\n        var groupsObject;\n        if (XRegExp.isInstalled('namespacing')) {\n          // https://tc39.github.io/proposal-regexp-named-groups/#sec-regexpbuiltinexec\n          groupsObject = (0, _create[\"default\"])(null);\n          args.push(groupsObject);\n        } else {\n          // Change the `args[0]` string primitive to a `String` object that can store\n          // properties. This really does need to use `String` as a constructor\n          args[0] = new String(args[0]);\n          groupsObject = args[0];\n        } // Store named backreferences\n\n        for (var i = 0; i < captureNames.length; ++i) {\n          if (captureNames[i]) {\n            groupsObject[captureNames[i]] = args[i + 1];\n          }\n        }\n      } // ES6 specs the context for replacement functions as `undefined`\n\n      return replacement.apply(void 0, args);\n    });\n  } else {\n    // Ensure that the last value of `args` will be a string when given nonstring `this`,\n    // while still throwing on null or undefined context\n    result = nativ.replace.call(this == null ? this : String(this), search, function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      return nativ.replace.call(String(replacement), replacementToken, replacer);\n      function replacer($0, bracketed, angled, dollarToken) {\n        bracketed = bracketed || angled; // Named or numbered backreference with curly or angled braces\n\n        if (bracketed) {\n          // XRegExp behavior for `${n}` or `$<n>`:\n          // 1. Backreference to numbered capture, if `n` is an integer. Use `0` for the\n          //    entire match. Any number of leading zeros may be used.\n          // 2. Backreference to named capture `n`, if it exists and is not an integer\n          //    overridden by numbered capture. In practice, this does not overlap with\n          //    numbered capture since XRegExp does not allow named capture to use a bare\n          //    integer as the name.\n          // 3. If the name or number does not refer to an existing capturing group, it's\n          //    an error.\n          var n = +bracketed; // Type-convert; drop leading zeros\n\n          if (n <= args.length - 3) {\n            return args[n] || '';\n          } // Groups with the same name is an error, else would need `lastIndexOf`\n\n          n = captureNames ? (0, _indexOf[\"default\"])(captureNames).call(captureNames, bracketed) : -1;\n          if (n < 0) {\n            throw new SyntaxError(\"Backreference to undefined group \".concat($0));\n          }\n          return args[n + 1] || '';\n        } // Else, special variable or numbered backreference without curly braces\n\n        if (dollarToken === '$') {\n          // $$\n          return '$';\n        }\n        if (dollarToken === '&' || +dollarToken === 0) {\n          // $&, $0 (not followed by 1-9), $00\n          return args[0];\n        }\n        if (dollarToken === '`') {\n          var _context4;\n\n          // $` (left context)\n          return (0, _slice[\"default\"])(_context4 = args[args.length - 1]).call(_context4, 0, args[args.length - 2]);\n        }\n        if (dollarToken === \"'\") {\n          var _context5;\n\n          // $' (right context)\n          return (0, _slice[\"default\"])(_context5 = args[args.length - 1]).call(_context5, args[args.length - 2] + args[0].length);\n        } // Else, numbered backreference without braces\n\n        dollarToken = +dollarToken; // Type-convert; drop leading zero\n        // XRegExp behavior for `$n` and `$nn`:\n        // - Backrefs end after 1 or 2 digits. Use `${..}` or `$<..>` for more digits.\n        // - `$1` is an error if no capturing groups.\n        // - `$10` is an error if less than 10 capturing groups. Use `${1}0` or `$<1>0`\n        //   instead.\n        // - `$01` is `$1` if at least one capturing group, else it's an error.\n        // - `$0` (not followed by 1-9) and `$00` are the entire match.\n        // Native behavior, for comparison:\n        // - Backrefs end after 1 or 2 digits. Cannot reference capturing group 100+.\n        // - `$1` is a literal `$1` if no capturing groups.\n        // - `$10` is `$1` followed by a literal `0` if less than 10 capturing groups.\n        // - `$01` is `$1` if at least one capturing group, else it's a literal `$01`.\n        // - `$0` is a literal `$0`.\n\n        if (!isNaN(dollarToken)) {\n          if (dollarToken > args.length - 3) {\n            throw new SyntaxError(\"Backreference to undefined group \".concat($0));\n          }\n          return args[dollarToken] || '';\n        } // `$` followed by an unsupported char is an error, unlike native JS\n\n        throw new SyntaxError(\"Invalid token \".concat($0));\n      }\n    });\n  }\n  if (isRegex) {\n    if (search.global) {\n      // Fixes IE, Safari bug (last tested IE 9, Safari 5.1)\n      search.lastIndex = 0;\n    } else {\n      // Fixes IE, Opera bug (last tested IE 9, Opera 11.6)\n      search.lastIndex = origLastIndex;\n    }\n  }\n  return result;\n};\n/**\n * Fixes browser bugs in the native `String.prototype.split`. Use via `XRegExp.split`.\n *\n * @memberOf String\n * @param {RegExp|String} separator Regex or string to use for separating the string.\n * @param {Number} [limit] Maximum number of items to include in the result array.\n * @returns {!Array} Array of substrings.\n */\n\nfixed.split = function (separator, limit) {\n  if (!XRegExp.isRegExp(separator)) {\n    // Browsers handle nonregex split correctly, so use the faster native method\n    return nativ.split.apply(this, arguments);\n  }\n  var str = String(this);\n  var output = [];\n  var origLastIndex = separator.lastIndex;\n  var lastLastIndex = 0;\n  var lastLength; // Values for `limit`, per the spec:\n  // If undefined: pow(2,32) - 1\n  // If 0, Infinity, or NaN: 0\n  // If positive number: limit = floor(limit); if (limit >= pow(2,32)) limit -= pow(2,32);\n  // If negative number: pow(2,32) - floor(abs(limit))\n  // If other: Type-convert, then use the above rules\n  // This line fails in very strange ways for some values of `limit` in Opera 10.5-10.63, unless\n  // Opera Dragonfly is open (go figure). It works in at least Opera 9.5-10.1 and 11+\n\n  limit = (limit === undefined ? -1 : limit) >>> 0;\n  (0, _forEach[\"default\"])(XRegExp).call(XRegExp, str, separator, function (match) {\n    // This condition is not the same as `if (match[0].length)`\n    if (match.index + match[0].length > lastLastIndex) {\n      output.push((0, _slice[\"default\"])(str).call(str, lastLastIndex, match.index));\n      if (match.length > 1 && match.index < str.length) {\n        Array.prototype.push.apply(output, (0, _slice[\"default\"])(match).call(match, 1));\n      }\n      lastLength = match[0].length;\n      lastLastIndex = match.index + lastLength;\n    }\n  });\n  if (lastLastIndex === str.length) {\n    if (!nativ.test.call(separator, '') || lastLength) {\n      output.push('');\n    }\n  } else {\n    output.push((0, _slice[\"default\"])(str).call(str, lastLastIndex));\n  }\n  separator.lastIndex = origLastIndex;\n  return output.length > limit ? (0, _slice[\"default\"])(output).call(output, 0, limit) : output;\n}; // ==--------------------------==\n// Built-in syntax/flag tokens\n// ==--------------------------==\n\n/*\n * Letter escapes that natively match literal characters: `\\a`, `\\A`, etc. These should be\n * SyntaxErrors but are allowed in web reality. XRegExp makes them errors for cross-browser\n * consistency and to reserve their syntax, but lets them be superseded by addons.\n */\n\nXRegExp.addToken(/\\\\([ABCE-RTUVXYZaeg-mopqyz]|c(?![A-Za-z])|u(?![\\dA-Fa-f]{4}|{[\\dA-Fa-f]+})|x(?![\\dA-Fa-f]{2}))/, function (match, scope) {\n  // \\B is allowed in default scope only\n  if (match[1] === 'B' && scope === defaultScope) {\n    return match[0];\n  }\n  throw new SyntaxError(\"Invalid escape \".concat(match[0]));\n}, {\n  scope: 'all',\n  leadChar: '\\\\'\n});\n/*\n * Unicode code point escape with curly braces: `\\u{N..}`. `N..` is any one or more digit\n * hexadecimal number from 0-10FFFF, and can include leading zeros. Requires the native ES6 `u` flag\n * to support code points greater than U+FFFF. Avoids converting code points above U+FFFF to\n * surrogate pairs (which could be done without flag `u`), since that could lead to broken behavior\n * if you follow a `\\u{N..}` token that references a code point above U+FFFF with a quantifier, or\n * if you use the same in a character class.\n */\n\nXRegExp.addToken(/\\\\u{([\\dA-Fa-f]+)}/, function (match, scope, flags) {\n  var code = dec(match[1]);\n  if (code > 0x10FFFF) {\n    throw new SyntaxError(\"Invalid Unicode code point \".concat(match[0]));\n  }\n  if (code <= 0xFFFF) {\n    // Converting to \\uNNNN avoids needing to escape the literal character and keep it\n    // separate from preceding tokens\n    return \"\\\\u\".concat(pad4(hex(code)));\n  } // If `code` is between 0xFFFF and 0x10FFFF, require and defer to native handling\n\n  if (hasNativeU && (0, _includes[\"default\"])(flags).call(flags, 'u')) {\n    return match[0];\n  }\n  throw new SyntaxError('Cannot use Unicode code point above \\\\u{FFFF} without flag u');\n}, {\n  scope: 'all',\n  leadChar: '\\\\'\n});\n/*\n * Empty character class: `[]` or `[^]`. This fixes a critical cross-browser syntax inconsistency.\n * Unless this is standardized (per the ES spec), regex syntax can't be accurately parsed because\n * character class endings can't be determined.\n */\n\nXRegExp.addToken(/\\[(\\^?)\\]/,\n// For cross-browser compatibility with ES3, convert [] to \\b\\B and [^] to [\\s\\S].\n// (?!) should work like \\b\\B, but is unreliable in some versions of Firefox\n\n/* eslint-disable no-confusing-arrow */\nfunction (match) {\n  return match[1] ? '[\\\\s\\\\S]' : '\\\\b\\\\B';\n}, /* eslint-enable no-confusing-arrow */\n{\n  leadChar: '['\n});\n/*\n * Comment pattern: `(?# )`. Inline comments are an alternative to the line comments allowed in\n * free-spacing mode (flag x).\n */\n\nXRegExp.addToken(/\\(\\?#[^)]*\\)/, getContextualTokenSeparator, {\n  leadChar: '('\n});\n/*\n * Whitespace and line comments, in free-spacing mode (aka extended mode, flag x) only.\n */\n\nXRegExp.addToken(/\\s+|#[^\\n]*\\n?/, getContextualTokenSeparator, {\n  flag: 'x'\n});\n/*\n * Dot, in dotall mode (aka singleline mode, flag s) only.\n */\n\nXRegExp.addToken(/\\./, function () {\n  return '[\\\\s\\\\S]';\n}, {\n  flag: 's',\n  leadChar: '.'\n});\n/*\n * Named backreference: `\\k<name>`. Backreference names can use the characters A-Z, a-z, 0-9, _,\n * and $ only. Also allows numbered backreferences as `\\k<n>`.\n */\n\nXRegExp.addToken(/\\\\k<([\\w$]+)>/, function (match) {\n  var _context6, _context7;\n\n  // Groups with the same name is an error, else would need `lastIndexOf`\n  var index = isNaN(match[1]) ? (0, _indexOf[\"default\"])(_context6 = this.captureNames).call(_context6, match[1]) + 1 : +match[1];\n  var endIndex = match.index + match[0].length;\n  if (!index || index > this.captureNames.length) {\n    throw new SyntaxError(\"Backreference to undefined group \".concat(match[0]));\n  } // Keep backreferences separate from subsequent literal numbers. This avoids e.g.\n  // inadvertedly changing `(?<n>)\\k<n>1` to `()\\11`.\n\n  return (0, _concat[\"default\"])(_context7 = \"\\\\\".concat(index)).call(_context7, endIndex === match.input.length || isNaN(match.input[endIndex]) ? '' : '(?:)');\n}, {\n  leadChar: '\\\\'\n});\n/*\n * Numbered backreference or octal, plus any following digits: `\\0`, `\\11`, etc. Octals except `\\0`\n * not followed by 0-9 and backreferences to unopened capture groups throw an error. Other matches\n * are returned unaltered. IE < 9 doesn't support backreferences above `\\99` in regex syntax.\n */\n\nXRegExp.addToken(/\\\\(\\d+)/, function (match, scope) {\n  if (!(scope === defaultScope && /^[1-9]/.test(match[1]) && +match[1] <= this.captureNames.length) && match[1] !== '0') {\n    throw new SyntaxError(\"Cannot use octal escape or backreference to undefined group \".concat(match[0]));\n  }\n  return match[0];\n}, {\n  scope: 'all',\n  leadChar: '\\\\'\n});\n/*\n * Named capturing group; match the opening delimiter only: `(?<name>`. Capture names can use the\n * characters A-Z, a-z, 0-9, _, and $ only. Names can't be integers. Supports Python-style\n * `(?P<name>` as an alternate syntax to avoid issues in some older versions of Opera which natively\n * supported the Python-style syntax. Otherwise, XRegExp might treat numbered backreferences to\n * Python-style named capture as octals.\n */\n\nXRegExp.addToken(/\\(\\?P?<([\\w$]+)>/, function (match) {\n  var _context8;\n\n  // Disallow bare integers as names because named backreferences are added to match arrays\n  // and therefore numeric properties may lead to incorrect lookups\n  if (!isNaN(match[1])) {\n    throw new SyntaxError(\"Cannot use integer as capture name \".concat(match[0]));\n  }\n  if (!XRegExp.isInstalled('namespacing') && (match[1] === 'length' || match[1] === '__proto__')) {\n    throw new SyntaxError(\"Cannot use reserved word as capture name \".concat(match[0]));\n  }\n  if ((0, _includes[\"default\"])(_context8 = this.captureNames).call(_context8, match[1])) {\n    throw new SyntaxError(\"Cannot use same name for multiple groups \".concat(match[0]));\n  }\n  this.captureNames.push(match[1]);\n  this.hasNamedCapture = true;\n  return '(';\n}, {\n  leadChar: '('\n});\n/*\n * Capturing group; match the opening parenthesis only. Required for support of named capturing\n * groups. Also adds explicit capture mode (flag n).\n */\n\nXRegExp.addToken(/\\((?!\\?)/, function (match, scope, flags) {\n  if ((0, _includes[\"default\"])(flags).call(flags, 'n')) {\n    return '(?:';\n  }\n  this.captureNames.push(null);\n  return '(';\n}, {\n  optionalFlags: 'n',\n  leadChar: '('\n});\nvar _default = XRegExp;\nexports[\"default\"] = _default;\nmodule.exports = exports.default;","map":{"version":3,"names":["_interopRequireDefault","require","_Object$defineProperty","exports","value","_getIterator2","_isArray","_getIteratorMethod2","_symbol","_from","_concat","_indexOf","_create","_slicedToArray2","_forEach","_includes","_parseInt2","_slice","_sort","_flags","_createForOfIteratorHelper","o","allowArrayLike","it","_unsupportedIterableToArray","length","i","F","s","n","done","e","_e","f","TypeError","normalCompletion","didErr","err","step","next","_e2","minLen","_context9","_arrayLikeToArray","Object","prototype","toString","call","constructor","name","test","arr","len","arr2","Array","REGEX_DATA","features","astral","namespacing","nativ","exec","RegExp","match","String","replace","split","fixed","regexCache","patternCache","tokens","defaultScope","classScope","nativeTokens","replacementToken","correctExecNpcg","undefined","hasFlagsProp","_ref","hasNativeFlag","flag","isSupported","gy","incompleteY","exception","hasNativeU","hasNativeY","registeredFlags","g","m","u","y","augment","regex","captureNames","xSource","xFlags","isInternalOnly","_context","__proto__","XRegExp","p","source","flags","join","clipDuplicates","str","copyRegex","options","_context2","isRegExp","xData","getNativeFlags","flagsToAdd","flagsToRemove","xregexpSource","xregexpFlags","removeG","removeY","concat","addG","addY","hasNamedCapture","dec","hex","getContextualTokenSeparator","scope","input","index","substr","isQuantifierNext","pattern","pos","inlineCommentPattern","lineCommentPattern","quantifierPattern","isType","type","pad4","prepareFlags","SyntaxError","$0","$1","_iterator","_step","prepareOptions","registerFlag","Error","runTokens","context","leadChar","result","t","matchLength","output","handler","reparse","setAstral","on","setNamespacing","toObject","isInstalled","applied","appliedPattern","appliedFlags","_XRegExp$exec","_XRegExp$exec2","token","captures","generated","version","_clipDuplicates","_hasNativeFlag","_dec","_hex","_pad4","addToken","_options","optionalFlags","_iterator2","_step2","push","cache","flush","cacheName","escape","sticky","cacheKey","fakeY","r2","lastIndex","pop","global","forEach","callback","globalize","install","feature","matchChain","chain","recurseChain","values","level","item","matches","addMatch","backref","ERR_UNDEFINED_GROUP","isNamedBackref","isNaN","groups","ReferenceError","hasOwnProperty","backrefValue","_iterator3","_step3","search","replacement","isRegex","s2","replaceEach","replacements","_iterator4","_step4","r","separator","limit","uninstall","union","patterns","conjunction","numCaptures","numPriorCaptures","rewrite","paren","parts","_iterator5","_step5","origLastIndex","apply","arguments","_context3","groupsObject","_len","args","_key","_len2","_key2","replacer","bracketed","angled","dollarToken","_context4","_context5","lastLastIndex","lastLength","code","_context6","_context7","endIndex","_context8","_default","module","default"],"sources":["D:/CMK/2023_5/WebsiteBuiderTask/modify/grapesJs/node_modules/xregexp/lib/xregexp.js"],"sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports[\"default\"] = void 0;\n\nvar _getIterator2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js/get-iterator\"));\n\nvar _isArray = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/array/is-array\"));\n\nvar _getIteratorMethod2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js/get-iterator-method\"));\n\nvar _symbol = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/symbol\"));\n\nvar _from = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/array/from\"));\n\nvar _concat = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/concat\"));\n\nvar _indexOf = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/index-of\"));\n\nvar _create = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/object/create\"));\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/slicedToArray\"));\n\nvar _forEach = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/for-each\"));\n\nvar _includes = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/includes\"));\n\nvar _parseInt2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/parse-int\"));\n\nvar _slice = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/slice\"));\n\nvar _sort = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/sort\"));\n\nvar _flags = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/flags\"));\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof _symbol[\"default\"] === \"undefined\" || (0, _getIteratorMethod2[\"default\"])(o) == null) { if ((0, _isArray[\"default\"])(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = (0, _getIterator2[\"default\"])(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { var _context9; if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = (0, _slice[\"default\"])(_context9 = Object.prototype.toString.call(o)).call(_context9, 8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return (0, _from[\"default\"])(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/*!\n * XRegExp 4.4.1\n * <xregexp.com>\n * Steven Levithan (c) 2007-present MIT License\n */\n\n/**\n * XRegExp provides augmented, extensible regular expressions. You get additional regex syntax and\n * flags, beyond what browsers support natively. XRegExp is also a regex utility belt with tools to\n * make your client-side grepping simpler and more powerful, while freeing you from related\n * cross-browser inconsistencies.\n */\n// ==--------------------------==\n// Private stuff\n// ==--------------------------==\n// Property name used for extended regex instance data\nvar REGEX_DATA = 'xregexp'; // Optional features that can be installed and uninstalled\n\nvar features = {\n  astral: false,\n  namespacing: false\n}; // Native methods to use and restore ('native' is an ES3 reserved keyword)\n\nvar nativ = {\n  exec: RegExp.prototype.exec,\n  test: RegExp.prototype.test,\n  match: String.prototype.match,\n  replace: String.prototype.replace,\n  split: String.prototype.split\n}; // Storage for fixed/extended native methods\n\nvar fixed = {}; // Storage for regexes cached by `XRegExp.cache`\n\nvar regexCache = {}; // Storage for pattern details cached by the `XRegExp` constructor\n\nvar patternCache = {}; // Storage for regex syntax tokens added internally or by `XRegExp.addToken`\n\nvar tokens = []; // Token scopes\n\nvar defaultScope = 'default';\nvar classScope = 'class'; // Regexes that match native regex syntax, including octals\n\nvar nativeTokens = {\n  // Any native multicharacter token in default scope, or any single character\n  'default': /\\\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9]\\d*|x[\\dA-Fa-f]{2}|u(?:[\\dA-Fa-f]{4}|{[\\dA-Fa-f]+})|c[A-Za-z]|[\\s\\S])|\\(\\?(?:[:=!]|<[=!])|[?*+]\\?|{\\d+(?:,\\d*)?}\\??|[\\s\\S]/,\n  // Any native multicharacter token in character class scope, or any single character\n  'class': /\\\\(?:[0-3][0-7]{0,2}|[4-7][0-7]?|x[\\dA-Fa-f]{2}|u(?:[\\dA-Fa-f]{4}|{[\\dA-Fa-f]+})|c[A-Za-z]|[\\s\\S])|[\\s\\S]/\n}; // Any backreference or dollar-prefixed character in replacement strings\n\nvar replacementToken = /\\$(?:{([\\w$]+)}|<([\\w$]+)>|(\\d\\d?|[\\s\\S]))/g; // Check for correct `exec` handling of nonparticipating capturing groups\n\nvar correctExecNpcg = nativ.exec.call(/()??/, '')[1] === undefined; // Check for ES6 `flags` prop support\n\nvar hasFlagsProp = (0, _flags[\"default\"])(/x/) !== undefined; // Shortcut to `Object.prototype.toString`\n\nvar _ref = {},\n    toString = _ref.toString;\n\nfunction hasNativeFlag(flag) {\n  // Can't check based on the presence of properties/getters since browsers might support such\n  // properties even when they don't support the corresponding flag in regex construction (tested\n  // in Chrome 48, where `'unicode' in /x/` is true but trying to construct a regex with flag `u`\n  // throws an error)\n  var isSupported = true;\n\n  try {\n    // Can't use regex literals for testing even in a `try` because regex literals with\n    // unsupported flags cause a compilation error in IE\n    new RegExp('', flag); // Work around a broken/incomplete IE11 polyfill for sticky introduced in core-js 3.6.0\n\n    if (flag === 'y') {\n      // Using function to avoid babel transform to regex literal\n      var gy = function () {\n        return 'gy';\n      }();\n\n      var incompleteY = '.a'.replace(new RegExp('a', gy), '.') === '..';\n\n      if (incompleteY) {\n        isSupported = false;\n      }\n    }\n  } catch (exception) {\n    isSupported = false;\n  }\n\n  return isSupported;\n} // Check for ES6 `u` flag support\n\n\nvar hasNativeU = hasNativeFlag('u'); // Check for ES6 `y` flag support\n\nvar hasNativeY = hasNativeFlag('y'); // Tracker for known flags, including addon flags\n\nvar registeredFlags = {\n  g: true,\n  i: true,\n  m: true,\n  u: hasNativeU,\n  y: hasNativeY\n};\n/**\n * Attaches extended data and `XRegExp.prototype` properties to a regex object.\n *\n * @private\n * @param {RegExp} regex Regex to augment.\n * @param {Array} captureNames Array with capture names, or `null`.\n * @param {String} xSource XRegExp pattern used to generate `regex`, or `null` if N/A.\n * @param {String} xFlags XRegExp flags used to generate `regex`, or `null` if N/A.\n * @param {Boolean} [isInternalOnly=false] Whether the regex will be used only for internal\n *   operations, and never exposed to users. For internal-only regexes, we can improve perf by\n *   skipping some operations like attaching `XRegExp.prototype` properties.\n * @returns {!RegExp} Augmented regex.\n */\n\nfunction augment(regex, captureNames, xSource, xFlags, isInternalOnly) {\n  var _context;\n\n  regex[REGEX_DATA] = {\n    captureNames: captureNames\n  };\n\n  if (isInternalOnly) {\n    return regex;\n  } // Can't auto-inherit these since the XRegExp constructor returns a nonprimitive value\n\n\n  if (regex.__proto__) {\n    regex.__proto__ = XRegExp.prototype;\n  } else {\n    for (var p in XRegExp.prototype) {\n      // An `XRegExp.prototype.hasOwnProperty(p)` check wouldn't be worth it here, since this\n      // is performance sensitive, and enumerable `Object.prototype` or `RegExp.prototype`\n      // extensions exist on `regex.prototype` anyway\n      regex[p] = XRegExp.prototype[p];\n    }\n  }\n\n  regex[REGEX_DATA].source = xSource; // Emulate the ES6 `flags` prop by ensuring flags are in alphabetical order\n\n  regex[REGEX_DATA].flags = xFlags ? (0, _sort[\"default\"])(_context = xFlags.split('')).call(_context).join('') : xFlags;\n  return regex;\n}\n/**\n * Removes any duplicate characters from the provided string.\n *\n * @private\n * @param {String} str String to remove duplicate characters from.\n * @returns {string} String with any duplicate characters removed.\n */\n\n\nfunction clipDuplicates(str) {\n  return nativ.replace.call(str, /([\\s\\S])(?=[\\s\\S]*\\1)/g, '');\n}\n/**\n * Copies a regex object while preserving extended data and augmenting with `XRegExp.prototype`\n * properties. The copy has a fresh `lastIndex` property (set to zero). Allows adding and removing\n * flags g and y while copying the regex.\n *\n * @private\n * @param {RegExp} regex Regex to copy.\n * @param {Object} [options] Options object with optional properties:\n *   - `addG` {Boolean} Add flag g while copying the regex.\n *   - `addY` {Boolean} Add flag y while copying the regex.\n *   - `removeG` {Boolean} Remove flag g while copying the regex.\n *   - `removeY` {Boolean} Remove flag y while copying the regex.\n *   - `isInternalOnly` {Boolean} Whether the copied regex will be used only for internal\n *     operations, and never exposed to users. For internal-only regexes, we can improve perf by\n *     skipping some operations like attaching `XRegExp.prototype` properties.\n *   - `source` {String} Overrides `<regex>.source`, for special cases.\n * @returns {RegExp} Copy of the provided regex, possibly with modified flags.\n */\n\n\nfunction copyRegex(regex, options) {\n  var _context2;\n\n  if (!XRegExp.isRegExp(regex)) {\n    throw new TypeError('Type RegExp expected');\n  }\n\n  var xData = regex[REGEX_DATA] || {};\n  var flags = getNativeFlags(regex);\n  var flagsToAdd = '';\n  var flagsToRemove = '';\n  var xregexpSource = null;\n  var xregexpFlags = null;\n  options = options || {};\n\n  if (options.removeG) {\n    flagsToRemove += 'g';\n  }\n\n  if (options.removeY) {\n    flagsToRemove += 'y';\n  }\n\n  if (flagsToRemove) {\n    flags = nativ.replace.call(flags, new RegExp(\"[\".concat(flagsToRemove, \"]+\"), 'g'), '');\n  }\n\n  if (options.addG) {\n    flagsToAdd += 'g';\n  }\n\n  if (options.addY) {\n    flagsToAdd += 'y';\n  }\n\n  if (flagsToAdd) {\n    flags = clipDuplicates(flags + flagsToAdd);\n  }\n\n  if (!options.isInternalOnly) {\n    if (xData.source !== undefined) {\n      xregexpSource = xData.source;\n    } // null or undefined; don't want to add to `flags` if the previous value was null, since\n    // that indicates we're not tracking original precompilation flags\n\n\n    if ((0, _flags[\"default\"])(xData) != null) {\n      // Flags are only added for non-internal regexes by `XRegExp.globalize`. Flags are never\n      // removed for non-internal regexes, so don't need to handle it\n      xregexpFlags = flagsToAdd ? clipDuplicates((0, _flags[\"default\"])(xData) + flagsToAdd) : (0, _flags[\"default\"])(xData);\n    }\n  } // Augment with `XRegExp.prototype` properties, but use the native `RegExp` constructor to avoid\n  // searching for special tokens. That would be wrong for regexes constructed by `RegExp`, and\n  // unnecessary for regexes constructed by `XRegExp` because the regex has already undergone the\n  // translation to native regex syntax\n\n\n  regex = augment(new RegExp(options.source || regex.source, flags), hasNamedCapture(regex) ? (0, _slice[\"default\"])(_context2 = xData.captureNames).call(_context2, 0) : null, xregexpSource, xregexpFlags, options.isInternalOnly);\n  return regex;\n}\n/**\n * Converts hexadecimal to decimal.\n *\n * @private\n * @param {String} hex\n * @returns {number}\n */\n\n\nfunction dec(hex) {\n  return (0, _parseInt2[\"default\"])(hex, 16);\n}\n/**\n * Returns a pattern that can be used in a native RegExp in place of an ignorable token such as an\n * inline comment or whitespace with flag x. This is used directly as a token handler function\n * passed to `XRegExp.addToken`.\n *\n * @private\n * @param {String} match Match arg of `XRegExp.addToken` handler\n * @param {String} scope Scope arg of `XRegExp.addToken` handler\n * @param {String} flags Flags arg of `XRegExp.addToken` handler\n * @returns {string} Either '' or '(?:)', depending on which is needed in the context of the match.\n */\n\n\nfunction getContextualTokenSeparator(match, scope, flags) {\n  if ( // No need to separate tokens if at the beginning or end of a group\n  match.input[match.index - 1] === '(' || match.input[match.index + match[0].length] === ')' || // No need to separate tokens if before or after a `|`\n  match.input[match.index - 1] === '|' || match.input[match.index + match[0].length] === '|' || // No need to separate tokens if at the beginning or end of the pattern\n  match.index < 1 || match.index + match[0].length >= match.input.length || // No need to separate tokens if at the beginning of a noncapturing group or lookahead.\n  // The way this is written relies on:\n  // - The search regex matching only 3-char strings.\n  // - Although `substr` gives chars from the end of the string if given a negative index,\n  //   the resulting substring will be too short to match. Ex: `'abcd'.substr(-1, 3) === 'd'`\n  nativ.test.call(/^\\(\\?[:=!]/, match.input.substr(match.index - 3, 3)) || // Avoid separating tokens when the following token is a quantifier\n  isQuantifierNext(match.input, match.index + match[0].length, flags)) {\n    return '';\n  } // Keep tokens separated. This avoids e.g. inadvertedly changing `\\1 1` or `\\1(?#)1` to `\\11`.\n  // This also ensures all tokens remain as discrete atoms, e.g. it avoids converting the syntax\n  // error `(? :` into `(?:`.\n\n\n  return '(?:)';\n}\n/**\n * Returns native `RegExp` flags used by a regex object.\n *\n * @private\n * @param {RegExp} regex Regex to check.\n * @returns {string} Native flags in use.\n */\n\n\nfunction getNativeFlags(regex) {\n  return hasFlagsProp ? (0, _flags[\"default\"])(regex) : // Explicitly using `RegExp.prototype.toString` (rather than e.g. `String` or concatenation\n  // with an empty string) allows this to continue working predictably when\n  // `XRegExp.proptotype.toString` is overridden\n  nativ.exec.call(/\\/([a-z]*)$/i, RegExp.prototype.toString.call(regex))[1];\n}\n/**\n * Determines whether a regex has extended instance data used to track capture names.\n *\n * @private\n * @param {RegExp} regex Regex to check.\n * @returns {boolean} Whether the regex uses named capture.\n */\n\n\nfunction hasNamedCapture(regex) {\n  return !!(regex[REGEX_DATA] && regex[REGEX_DATA].captureNames);\n}\n/**\n * Converts decimal to hexadecimal.\n *\n * @private\n * @param {Number|String} dec\n * @returns {string}\n */\n\n\nfunction hex(dec) {\n  return (0, _parseInt2[\"default\"])(dec, 10).toString(16);\n}\n/**\n * Checks whether the next nonignorable token after the specified position is a quantifier.\n *\n * @private\n * @param {String} pattern Pattern to search within.\n * @param {Number} pos Index in `pattern` to search at.\n * @param {String} flags Flags used by the pattern.\n * @returns {Boolean} Whether the next nonignorable token is a quantifier.\n */\n\n\nfunction isQuantifierNext(pattern, pos, flags) {\n  var inlineCommentPattern = '\\\\(\\\\?#[^)]*\\\\)';\n  var lineCommentPattern = '#[^#\\\\n]*';\n  var quantifierPattern = '[?*+]|{\\\\d+(?:,\\\\d*)?}';\n  return nativ.test.call((0, _includes[\"default\"])(flags).call(flags, 'x') ? // Ignore any leading whitespace, line comments, and inline comments\n  /^(?:\\s|#[^#\\n]*|\\(\\?#[^)]*\\))*(?:[?*+]|{\\d+(?:,\\d*)?})/ : // Ignore any leading inline comments\n  /^(?:\\(\\?#[^)]*\\))*(?:[?*+]|{\\d+(?:,\\d*)?})/, (0, _slice[\"default\"])(pattern).call(pattern, pos));\n}\n/**\n * Determines whether a value is of the specified type, by resolving its internal [[Class]].\n *\n * @private\n * @param {*} value Object to check.\n * @param {String} type Type to check for, in TitleCase.\n * @returns {boolean} Whether the object matches the type.\n */\n\n\nfunction isType(value, type) {\n  return toString.call(value) === \"[object \".concat(type, \"]\");\n}\n/**\n * Adds leading zeros if shorter than four characters. Used for fixed-length hexadecimal values.\n *\n * @private\n * @param {String} str\n * @returns {string}\n */\n\n\nfunction pad4(str) {\n  while (str.length < 4) {\n    str = \"0\".concat(str);\n  }\n\n  return str;\n}\n/**\n * Checks for flag-related errors, and strips/applies flags in a leading mode modifier. Offloads\n * the flag preparation logic from the `XRegExp` constructor.\n *\n * @private\n * @param {String} pattern Regex pattern, possibly with a leading mode modifier.\n * @param {String} flags Any combination of flags.\n * @returns {!Object} Object with properties `pattern` and `flags`.\n */\n\n\nfunction prepareFlags(pattern, flags) {\n  // Recent browsers throw on duplicate flags, so copy this behavior for nonnative flags\n  if (clipDuplicates(flags) !== flags) {\n    throw new SyntaxError(\"Invalid duplicate regex flag \".concat(flags));\n  } // Strip and apply a leading mode modifier with any combination of flags except g or y\n\n\n  pattern = nativ.replace.call(pattern, /^\\(\\?([\\w$]+)\\)/, function ($0, $1) {\n    if (nativ.test.call(/[gy]/, $1)) {\n      throw new SyntaxError(\"Cannot use flag g or y in mode modifier \".concat($0));\n    } // Allow duplicate flags within the mode modifier\n\n\n    flags = clipDuplicates(flags + $1);\n    return '';\n  }); // Throw on unknown native or nonnative flags\n\n  var _iterator = _createForOfIteratorHelper(flags),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var flag = _step.value;\n\n      if (!registeredFlags[flag]) {\n        throw new SyntaxError(\"Unknown regex flag \".concat(flag));\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return {\n    pattern: pattern,\n    flags: flags\n  };\n}\n/**\n * Prepares an options object from the given value.\n *\n * @private\n * @param {String|Object} value Value to convert to an options object.\n * @returns {Object} Options object.\n */\n\n\nfunction prepareOptions(value) {\n  var options = {};\n\n  if (isType(value, 'String')) {\n    (0, _forEach[\"default\"])(XRegExp).call(XRegExp, value, /[^\\s,]+/, function (match) {\n      options[match] = true;\n    });\n    return options;\n  }\n\n  return value;\n}\n/**\n * Registers a flag so it doesn't throw an 'unknown flag' error.\n *\n * @private\n * @param {String} flag Single-character flag to register.\n */\n\n\nfunction registerFlag(flag) {\n  if (!/^[\\w$]$/.test(flag)) {\n    throw new Error('Flag must be a single character A-Za-z0-9_$');\n  }\n\n  registeredFlags[flag] = true;\n}\n/**\n * Runs built-in and custom regex syntax tokens in reverse insertion order at the specified\n * position, until a match is found.\n *\n * @private\n * @param {String} pattern Original pattern from which an XRegExp object is being built.\n * @param {String} flags Flags being used to construct the regex.\n * @param {Number} pos Position to search for tokens within `pattern`.\n * @param {Number} scope Regex scope to apply: 'default' or 'class'.\n * @param {Object} context Context object to use for token handler functions.\n * @returns {Object} Object with properties `matchLength`, `output`, and `reparse`; or `null`.\n */\n\n\nfunction runTokens(pattern, flags, pos, scope, context) {\n  var i = tokens.length;\n  var leadChar = pattern[pos];\n  var result = null;\n  var match;\n  var t; // Run in reverse insertion order\n\n  while (i--) {\n    t = tokens[i];\n\n    if (t.leadChar && t.leadChar !== leadChar || t.scope !== scope && t.scope !== 'all' || t.flag && !(0, _includes[\"default\"])(flags).call(flags, t.flag)) {\n      continue;\n    }\n\n    match = XRegExp.exec(pattern, t.regex, pos, 'sticky');\n\n    if (match) {\n      result = {\n        matchLength: match[0].length,\n        output: t.handler.call(context, match, scope, flags),\n        reparse: t.reparse\n      }; // Finished with token tests\n\n      break;\n    }\n  }\n\n  return result;\n}\n/**\n * Enables or disables implicit astral mode opt-in. When enabled, flag A is automatically added to\n * all new regexes created by XRegExp. This causes an error to be thrown when creating regexes if\n * the Unicode Base addon is not available, since flag A is registered by that addon.\n *\n * @private\n * @param {Boolean} on `true` to enable; `false` to disable.\n */\n\n\nfunction setAstral(on) {\n  features.astral = on;\n}\n/**\n * Adds named capture groups to the `groups` property of match arrays. See here for details:\n * https://github.com/tc39/proposal-regexp-named-groups\n *\n * @private\n * @param {Boolean} on `true` to enable; `false` to disable.\n */\n\n\nfunction setNamespacing(on) {\n  features.namespacing = on;\n}\n/**\n * Returns the object, or throws an error if it is `null` or `undefined`. This is used to follow\n * the ES5 abstract operation `ToObject`.\n *\n * @private\n * @param {*} value Object to check and return.\n * @returns {*} The provided object.\n */\n\n\nfunction toObject(value) {\n  // null or undefined\n  if (value == null) {\n    throw new TypeError('Cannot convert null or undefined to object');\n  }\n\n  return value;\n} // ==--------------------------==\n// Constructor\n// ==--------------------------==\n\n/**\n * Creates an extended regular expression object for matching text with a pattern. Differs from a\n * native regular expression in that additional syntax and flags are supported. The returned object\n * is in fact a native `RegExp` and works with all native methods.\n *\n * @class XRegExp\n * @constructor\n * @param {String|RegExp} pattern Regex pattern string, or an existing regex object to copy.\n * @param {String} [flags] Any combination of flags.\n *   Native flags:\n *     - `g` - global\n *     - `i` - ignore case\n *     - `m` - multiline anchors\n *     - `u` - unicode (ES6)\n *     - `y` - sticky (Firefox 3+, ES6)\n *   Additional XRegExp flags:\n *     - `n` - explicit capture\n *     - `s` - dot matches all (aka singleline)\n *     - `x` - free-spacing and line comments (aka extended)\n *     - `A` - astral (requires the Unicode Base addon)\n *   Flags cannot be provided when constructing one `RegExp` from another.\n * @returns {RegExp} Extended regular expression object.\n * @example\n *\n * // With named capture and flag x\n * XRegExp(`(?<year>  [0-9]{4} ) -?  # year\n *          (?<month> [0-9]{2} ) -?  # month\n *          (?<day>   [0-9]{2} )     # day`, 'x');\n *\n * // Providing a regex object copies it. Native regexes are recompiled using native (not XRegExp)\n * // syntax. Copies maintain extended data, are augmented with `XRegExp.prototype` properties, and\n * // have fresh `lastIndex` properties (set to zero).\n * XRegExp(/regex/);\n */\n\n\nfunction XRegExp(pattern, flags) {\n  if (XRegExp.isRegExp(pattern)) {\n    if (flags !== undefined) {\n      throw new TypeError('Cannot supply flags when copying a RegExp');\n    }\n\n    return copyRegex(pattern);\n  } // Copy the argument behavior of `RegExp`\n\n\n  pattern = pattern === undefined ? '' : String(pattern);\n  flags = flags === undefined ? '' : String(flags);\n\n  if (XRegExp.isInstalled('astral') && !(0, _includes[\"default\"])(flags).call(flags, 'A')) {\n    // This causes an error to be thrown if the Unicode Base addon is not available\n    flags += 'A';\n  }\n\n  if (!patternCache[pattern]) {\n    patternCache[pattern] = {};\n  }\n\n  if (!patternCache[pattern][flags]) {\n    var context = {\n      hasNamedCapture: false,\n      captureNames: []\n    };\n    var scope = defaultScope;\n    var output = '';\n    var pos = 0;\n    var result; // Check for flag-related errors, and strip/apply flags in a leading mode modifier\n\n    var applied = prepareFlags(pattern, flags);\n    var appliedPattern = applied.pattern;\n    var appliedFlags = (0, _flags[\"default\"])(applied); // Use XRegExp's tokens to translate the pattern to a native regex pattern.\n    // `appliedPattern.length` may change on each iteration if tokens use `reparse`\n\n    while (pos < appliedPattern.length) {\n      do {\n        // Check for custom tokens at the current position\n        result = runTokens(appliedPattern, appliedFlags, pos, scope, context); // If the matched token used the `reparse` option, splice its output into the\n        // pattern before running tokens again at the same position\n\n        if (result && result.reparse) {\n          appliedPattern = (0, _slice[\"default\"])(appliedPattern).call(appliedPattern, 0, pos) + result.output + (0, _slice[\"default\"])(appliedPattern).call(appliedPattern, pos + result.matchLength);\n        }\n      } while (result && result.reparse);\n\n      if (result) {\n        output += result.output;\n        pos += result.matchLength || 1;\n      } else {\n        // Get the native token at the current position\n        var _XRegExp$exec = XRegExp.exec(appliedPattern, nativeTokens[scope], pos, 'sticky'),\n            _XRegExp$exec2 = (0, _slicedToArray2[\"default\"])(_XRegExp$exec, 1),\n            token = _XRegExp$exec2[0];\n\n        output += token;\n        pos += token.length;\n\n        if (token === '[' && scope === defaultScope) {\n          scope = classScope;\n        } else if (token === ']' && scope === classScope) {\n          scope = defaultScope;\n        }\n      }\n    }\n\n    patternCache[pattern][flags] = {\n      // Use basic cleanup to collapse repeated empty groups like `(?:)(?:)` to `(?:)`. Empty\n      // groups are sometimes inserted during regex transpilation in order to keep tokens\n      // separated. However, more than one empty group in a row is never needed.\n      pattern: nativ.replace.call(output, /(?:\\(\\?:\\))+/g, '(?:)'),\n      // Strip all but native flags\n      flags: nativ.replace.call(appliedFlags, /[^gimuy]+/g, ''),\n      // `context.captureNames` has an item for each capturing group, even if unnamed\n      captures: context.hasNamedCapture ? context.captureNames : null\n    };\n  }\n\n  var generated = patternCache[pattern][flags];\n  return augment(new RegExp(generated.pattern, (0, _flags[\"default\"])(generated)), generated.captures, pattern, flags);\n} // Add `RegExp.prototype` to the prototype chain\n\n\nXRegExp.prototype = /(?:)/; // ==--------------------------==\n// Public properties\n// ==--------------------------==\n\n/**\n * The XRegExp version number as a string containing three dot-separated parts. For example,\n * '2.0.0-beta-3'.\n *\n * @static\n * @memberOf XRegExp\n * @type String\n */\n\nXRegExp.version = '4.4.1'; // ==--------------------------==\n// Public methods\n// ==--------------------------==\n// Intentionally undocumented; used in tests and addons\n\nXRegExp._clipDuplicates = clipDuplicates;\nXRegExp._hasNativeFlag = hasNativeFlag;\nXRegExp._dec = dec;\nXRegExp._hex = hex;\nXRegExp._pad4 = pad4;\n/**\n * Extends XRegExp syntax and allows custom flags. This is used internally and can be used to\n * create XRegExp addons. If more than one token can match the same string, the last added wins.\n *\n * @memberOf XRegExp\n * @param {RegExp} regex Regex object that matches the new token.\n * @param {Function} handler Function that returns a new pattern string (using native regex syntax)\n *   to replace the matched token within all future XRegExp regexes. Has access to persistent\n *   properties of the regex being built, through `this`. Invoked with three arguments:\n *   - The match array, with named backreference properties.\n *   - The regex scope where the match was found: 'default' or 'class'.\n *   - The flags used by the regex, including any flags in a leading mode modifier.\n *   The handler function becomes part of the XRegExp construction process, so be careful not to\n *   construct XRegExps within the function or you will trigger infinite recursion.\n * @param {Object} [options] Options object with optional properties:\n *   - `scope` {String} Scope where the token applies: 'default', 'class', or 'all'.\n *   - `flag` {String} Single-character flag that triggers the token. This also registers the\n *     flag, which prevents XRegExp from throwing an 'unknown flag' error when the flag is used.\n *   - `optionalFlags` {String} Any custom flags checked for within the token `handler` that are\n *     not required to trigger the token. This registers the flags, to prevent XRegExp from\n *     throwing an 'unknown flag' error when any of the flags are used.\n *   - `reparse` {Boolean} Whether the `handler` function's output should not be treated as\n *     final, and instead be reparseable by other tokens (including the current token). Allows\n *     token chaining or deferring.\n *   - `leadChar` {String} Single character that occurs at the beginning of any successful match\n *     of the token (not always applicable). This doesn't change the behavior of the token unless\n *     you provide an erroneous value. However, providing it can increase the token's performance\n *     since the token can be skipped at any positions where this character doesn't appear.\n * @example\n *\n * // Basic usage: Add \\a for the ALERT control code\n * XRegExp.addToken(\n *   /\\\\a/,\n *   () => '\\\\x07',\n *   {scope: 'all'}\n * );\n * XRegExp('\\\\a[\\\\a-\\\\n]+').test('\\x07\\n\\x07'); // -> true\n *\n * // Add the U (ungreedy) flag from PCRE and RE2, which reverses greedy and lazy quantifiers.\n * // Since `scope` is not specified, it uses 'default' (i.e., transformations apply outside of\n * // character classes only)\n * XRegExp.addToken(\n *   /([?*+]|{\\d+(?:,\\d*)?})(\\??)/,\n *   (match) => `${match[1]}${match[2] ? '' : '?'}`,\n *   {flag: 'U'}\n * );\n * XRegExp('a+', 'U').exec('aaa')[0]; // -> 'a'\n * XRegExp('a+?', 'U').exec('aaa')[0]; // -> 'aaa'\n */\n\nXRegExp.addToken = function (regex, handler, options) {\n  options = options || {};\n  var _options = options,\n      optionalFlags = _options.optionalFlags;\n\n  if (options.flag) {\n    registerFlag(options.flag);\n  }\n\n  if (optionalFlags) {\n    optionalFlags = nativ.split.call(optionalFlags, '');\n\n    var _iterator2 = _createForOfIteratorHelper(optionalFlags),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var flag = _step2.value;\n        registerFlag(flag);\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  } // Add to the private list of syntax tokens\n\n\n  tokens.push({\n    regex: copyRegex(regex, {\n      addG: true,\n      addY: hasNativeY,\n      isInternalOnly: true\n    }),\n    handler: handler,\n    scope: options.scope || defaultScope,\n    flag: options.flag,\n    reparse: options.reparse,\n    leadChar: options.leadChar\n  }); // Reset the pattern cache used by the `XRegExp` constructor, since the same pattern and flags\n  // might now produce different results\n\n  XRegExp.cache.flush('patterns');\n};\n/**\n * Caches and returns the result of calling `XRegExp(pattern, flags)`. On any subsequent call with\n * the same pattern and flag combination, the cached copy of the regex is returned.\n *\n * @memberOf XRegExp\n * @param {String} pattern Regex pattern string.\n * @param {String} [flags] Any combination of XRegExp flags.\n * @returns {RegExp} Cached XRegExp object.\n * @example\n *\n * while (match = XRegExp.cache('.', 'gs').exec(str)) {\n *   // The regex is compiled once only\n * }\n */\n\n\nXRegExp.cache = function (pattern, flags) {\n  if (!regexCache[pattern]) {\n    regexCache[pattern] = {};\n  }\n\n  return regexCache[pattern][flags] || (regexCache[pattern][flags] = XRegExp(pattern, flags));\n}; // Intentionally undocumented; used in tests\n\n\nXRegExp.cache.flush = function (cacheName) {\n  if (cacheName === 'patterns') {\n    // Flush the pattern cache used by the `XRegExp` constructor\n    patternCache = {};\n  } else {\n    // Flush the regex cache populated by `XRegExp.cache`\n    regexCache = {};\n  }\n};\n/**\n * Escapes any regular expression metacharacters, for use when matching literal strings. The result\n * can safely be used at any point within a regex that uses any flags.\n *\n * @memberOf XRegExp\n * @param {String} str String to escape.\n * @returns {string} String with regex metacharacters escaped.\n * @example\n *\n * XRegExp.escape('Escaped? <.>');\n * // -> 'Escaped\\?\\ <\\.>'\n */\n\n\nXRegExp.escape = function (str) {\n  return nativ.replace.call(toObject(str), /[-\\[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n};\n/**\n * Executes a regex search in a specified string. Returns a match array or `null`. If the provided\n * regex uses named capture, named backreference properties are included on the match array.\n * Optional `pos` and `sticky` arguments specify the search start position, and whether the match\n * must start at the specified position only. The `lastIndex` property of the provided regex is not\n * used, but is updated for compatibility. Also fixes browser bugs compared to the native\n * `RegExp.prototype.exec` and can be used reliably cross-browser.\n *\n * @memberOf XRegExp\n * @param {String} str String to search.\n * @param {RegExp} regex Regex to search with.\n * @param {Number} [pos=0] Zero-based index at which to start the search.\n * @param {Boolean|String} [sticky=false] Whether the match must start at the specified position\n *   only. The string `'sticky'` is accepted as an alternative to `true`.\n * @returns {Array} Match array with named backreference properties, or `null`.\n * @example\n *\n * // Basic use, with named backreference\n * let match = XRegExp.exec('U+2620', XRegExp('U\\\\+(?<hex>[0-9A-F]{4})'));\n * match.hex; // -> '2620'\n *\n * // With pos and sticky, in a loop\n * let pos = 2, result = [], match;\n * while (match = XRegExp.exec('<1><2><3><4>5<6>', /<(\\d)>/, pos, 'sticky')) {\n *   result.push(match[1]);\n *   pos = match.index + match[0].length;\n * }\n * // result -> ['2', '3', '4']\n */\n\n\nXRegExp.exec = function (str, regex, pos, sticky) {\n  var cacheKey = 'g';\n  var addY = false;\n  var fakeY = false;\n  var match;\n  addY = hasNativeY && !!(sticky || regex.sticky && sticky !== false);\n\n  if (addY) {\n    cacheKey += 'y';\n  } else if (sticky) {\n    // Simulate sticky matching by appending an empty capture to the original regex. The\n    // resulting regex will succeed no matter what at the current index (set with `lastIndex`),\n    // and will not search the rest of the subject string. We'll know that the original regex\n    // has failed if that last capture is `''` rather than `undefined` (i.e., if that last\n    // capture participated in the match).\n    fakeY = true;\n    cacheKey += 'FakeY';\n  }\n\n  regex[REGEX_DATA] = regex[REGEX_DATA] || {}; // Shares cached copies with `XRegExp.match`/`replace`\n\n  var r2 = regex[REGEX_DATA][cacheKey] || (regex[REGEX_DATA][cacheKey] = copyRegex(regex, {\n    addG: true,\n    addY: addY,\n    source: fakeY ? \"\".concat(regex.source, \"|()\") : undefined,\n    removeY: sticky === false,\n    isInternalOnly: true\n  }));\n  pos = pos || 0;\n  r2.lastIndex = pos; // Fixed `exec` required for `lastIndex` fix, named backreferences, etc.\n\n  match = fixed.exec.call(r2, str); // Get rid of the capture added by the pseudo-sticky matcher if needed. An empty string means\n  // the original regexp failed (see above).\n\n  if (fakeY && match && match.pop() === '') {\n    match = null;\n  }\n\n  if (regex.global) {\n    regex.lastIndex = match ? r2.lastIndex : 0;\n  }\n\n  return match;\n};\n/**\n * Executes a provided function once per regex match. Searches always start at the beginning of the\n * string and continue until the end, regardless of the state of the regex's `global` property and\n * initial `lastIndex`.\n *\n * @memberOf XRegExp\n * @param {String} str String to search.\n * @param {RegExp} regex Regex to search with.\n * @param {Function} callback Function to execute for each match. Invoked with four arguments:\n *   - The match array, with named backreference properties.\n *   - The zero-based match index.\n *   - The string being traversed.\n *   - The regex object being used to traverse the string.\n * @example\n *\n * // Extracts every other digit from a string\n * const evens = [];\n * XRegExp.forEach('1a2345', /\\d/, (match, i) => {\n *   if (i % 2) evens.push(+match[0]);\n * });\n * // evens -> [2, 4]\n */\n\n\nXRegExp.forEach = function (str, regex, callback) {\n  var pos = 0;\n  var i = -1;\n  var match;\n\n  while (match = XRegExp.exec(str, regex, pos)) {\n    // Because `regex` is provided to `callback`, the function could use the deprecated/\n    // nonstandard `RegExp.prototype.compile` to mutate the regex. However, since `XRegExp.exec`\n    // doesn't use `lastIndex` to set the search position, this can't lead to an infinite loop,\n    // at least. Actually, because of the way `XRegExp.exec` caches globalized versions of\n    // regexes, mutating the regex will not have any effect on the iteration or matched strings,\n    // which is a nice side effect that brings extra safety.\n    callback(match, ++i, str, regex);\n    pos = match.index + (match[0].length || 1);\n  }\n};\n/**\n * Copies a regex object and adds flag `g`. The copy maintains extended data, is augmented with\n * `XRegExp.prototype` properties, and has a fresh `lastIndex` property (set to zero). Native\n * regexes are not recompiled using XRegExp syntax.\n *\n * @memberOf XRegExp\n * @param {RegExp} regex Regex to globalize.\n * @returns {RegExp} Copy of the provided regex with flag `g` added.\n * @example\n *\n * const globalCopy = XRegExp.globalize(/regex/);\n * globalCopy.global; // -> true\n */\n\n\nXRegExp.globalize = function (regex) {\n  return copyRegex(regex, {\n    addG: true\n  });\n};\n/**\n * Installs optional features according to the specified options. Can be undone using\n * `XRegExp.uninstall`.\n *\n * @memberOf XRegExp\n * @param {Object|String} options Options object or string.\n * @example\n *\n * // With an options object\n * XRegExp.install({\n *   // Enables support for astral code points in Unicode addons (implicitly sets flag A)\n *   astral: true,\n *\n *   // Adds named capture groups to the `groups` property of matches\n *   namespacing: true\n * });\n *\n * // With an options string\n * XRegExp.install('astral namespacing');\n */\n\n\nXRegExp.install = function (options) {\n  options = prepareOptions(options);\n\n  if (!features.astral && options.astral) {\n    setAstral(true);\n  }\n\n  if (!features.namespacing && options.namespacing) {\n    setNamespacing(true);\n  }\n};\n/**\n * Checks whether an individual optional feature is installed.\n *\n * @memberOf XRegExp\n * @param {String} feature Name of the feature to check. One of:\n *   - `astral`\n *   - `namespacing`\n * @returns {boolean} Whether the feature is installed.\n * @example\n *\n * XRegExp.isInstalled('astral');\n */\n\n\nXRegExp.isInstalled = function (feature) {\n  return !!features[feature];\n};\n/**\n * Returns `true` if an object is a regex; `false` if it isn't. This works correctly for regexes\n * created in another frame, when `instanceof` and `constructor` checks would fail.\n *\n * @memberOf XRegExp\n * @param {*} value Object to check.\n * @returns {boolean} Whether the object is a `RegExp` object.\n * @example\n *\n * XRegExp.isRegExp('string'); // -> false\n * XRegExp.isRegExp(/regex/i); // -> true\n * XRegExp.isRegExp(RegExp('^', 'm')); // -> true\n * XRegExp.isRegExp(XRegExp('(?s).')); // -> true\n */\n\n\nXRegExp.isRegExp = function (value) {\n  return toString.call(value) === '[object RegExp]';\n}; // isType(value, 'RegExp');\n\n/**\n * Returns the first matched string, or in global mode, an array containing all matched strings.\n * This is essentially a more convenient re-implementation of `String.prototype.match` that gives\n * the result types you actually want (string instead of `exec`-style array in match-first mode,\n * and an empty array instead of `null` when no matches are found in match-all mode). It also lets\n * you override flag g and ignore `lastIndex`, and fixes browser bugs.\n *\n * @memberOf XRegExp\n * @param {String} str String to search.\n * @param {RegExp} regex Regex to search with.\n * @param {String} [scope='one'] Use 'one' to return the first match as a string. Use 'all' to\n *   return an array of all matched strings. If not explicitly specified and `regex` uses flag g,\n *   `scope` is 'all'.\n * @returns {String|Array} In match-first mode: First match as a string, or `null`. In match-all\n *   mode: Array of all matched strings, or an empty array.\n * @example\n *\n * // Match first\n * XRegExp.match('abc', /\\w/); // -> 'a'\n * XRegExp.match('abc', /\\w/g, 'one'); // -> 'a'\n * XRegExp.match('abc', /x/g, 'one'); // -> null\n *\n * // Match all\n * XRegExp.match('abc', /\\w/g); // -> ['a', 'b', 'c']\n * XRegExp.match('abc', /\\w/, 'all'); // -> ['a', 'b', 'c']\n * XRegExp.match('abc', /x/, 'all'); // -> []\n */\n\n\nXRegExp.match = function (str, regex, scope) {\n  var global = regex.global && scope !== 'one' || scope === 'all';\n  var cacheKey = (global ? 'g' : '') + (regex.sticky ? 'y' : '') || 'noGY';\n  regex[REGEX_DATA] = regex[REGEX_DATA] || {}; // Shares cached copies with `XRegExp.exec`/`replace`\n\n  var r2 = regex[REGEX_DATA][cacheKey] || (regex[REGEX_DATA][cacheKey] = copyRegex(regex, {\n    addG: !!global,\n    removeG: scope === 'one',\n    isInternalOnly: true\n  }));\n  var result = nativ.match.call(toObject(str), r2);\n\n  if (regex.global) {\n    regex.lastIndex = scope === 'one' && result ? // Can't use `r2.lastIndex` since `r2` is nonglobal in this case\n    result.index + result[0].length : 0;\n  }\n\n  return global ? result || [] : result && result[0];\n};\n/**\n * Retrieves the matches from searching a string using a chain of regexes that successively search\n * within previous matches. The provided `chain` array can contain regexes and or objects with\n * `regex` and `backref` properties. When a backreference is specified, the named or numbered\n * backreference is passed forward to the next regex or returned.\n *\n * @memberOf XRegExp\n * @param {String} str String to search.\n * @param {Array} chain Regexes that each search for matches within preceding results.\n * @returns {Array} Matches by the last regex in the chain, or an empty array.\n * @example\n *\n * // Basic usage; matches numbers within <b> tags\n * XRegExp.matchChain('1 <b>2</b> 3 <b>4 a 56</b>', [\n *   XRegExp('(?is)<b>.*?</b>'),\n *   /\\d+/\n * ]);\n * // -> ['2', '4', '56']\n *\n * // Passing forward and returning specific backreferences\n * html = '<a href=\"http://xregexp.com/api/\">XRegExp</a>\\\n *         <a href=\"http://www.google.com/\">Google</a>';\n * XRegExp.matchChain(html, [\n *   {regex: /<a href=\"([^\"]+)\">/i, backref: 1},\n *   {regex: XRegExp('(?i)^https?://(?<domain>[^/?#]+)'), backref: 'domain'}\n * ]);\n * // -> ['xregexp.com', 'www.google.com']\n */\n\n\nXRegExp.matchChain = function (str, chain) {\n  return function recurseChain(values, level) {\n    var item = chain[level].regex ? chain[level] : {\n      regex: chain[level]\n    };\n    var matches = [];\n\n    function addMatch(match) {\n      if (item.backref) {\n        var ERR_UNDEFINED_GROUP = \"Backreference to undefined group: \".concat(item.backref);\n        var isNamedBackref = isNaN(item.backref);\n\n        if (isNamedBackref && XRegExp.isInstalled('namespacing')) {\n          // `groups` has `null` as prototype, so using `in` instead of `hasOwnProperty`\n          if (!(item.backref in match.groups)) {\n            throw new ReferenceError(ERR_UNDEFINED_GROUP);\n          }\n        } else if (!match.hasOwnProperty(item.backref)) {\n          throw new ReferenceError(ERR_UNDEFINED_GROUP);\n        }\n\n        var backrefValue = isNamedBackref && XRegExp.isInstalled('namespacing') ? match.groups[item.backref] : match[item.backref];\n        matches.push(backrefValue || '');\n      } else {\n        matches.push(match[0]);\n      }\n    }\n\n    var _iterator3 = _createForOfIteratorHelper(values),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var value = _step3.value;\n        (0, _forEach[\"default\"])(XRegExp).call(XRegExp, value, item.regex, addMatch);\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n\n    return level === chain.length - 1 || !matches.length ? matches : recurseChain(matches, level + 1);\n  }([str], 0);\n};\n/**\n * Returns a new string with one or all matches of a pattern replaced. The pattern can be a string\n * or regex, and the replacement can be a string or a function to be called for each match. To\n * perform a global search and replace, use the optional `scope` argument or include flag g if using\n * a regex. Replacement strings can use `${n}` or `$<n>` for named and numbered backreferences.\n * Replacement functions can use named backreferences via `arguments[0].name`. Also fixes browser\n * bugs compared to the native `String.prototype.replace` and can be used reliably cross-browser.\n *\n * @memberOf XRegExp\n * @param {String} str String to search.\n * @param {RegExp|String} search Search pattern to be replaced.\n * @param {String|Function} replacement Replacement string or a function invoked to create it.\n *   Replacement strings can include special replacement syntax:\n *     - $$ - Inserts a literal $ character.\n *     - $&, $0 - Inserts the matched substring.\n *     - $` - Inserts the string that precedes the matched substring (left context).\n *     - $' - Inserts the string that follows the matched substring (right context).\n *     - $n, $nn - Where n/nn are digits referencing an existent capturing group, inserts\n *       backreference n/nn.\n *     - ${n}, $<n> - Where n is a name or any number of digits that reference an existent capturing\n *       group, inserts backreference n.\n *   Replacement functions are invoked with three or more arguments:\n *     - The matched substring (corresponds to $& above). Named backreferences are accessible as\n *       properties of this first argument.\n *     - 0..n arguments, one for each backreference (corresponding to $1, $2, etc. above).\n *     - The zero-based index of the match within the total search string.\n *     - The total string being searched.\n * @param {String} [scope='one'] Use 'one' to replace the first match only, or 'all'. If not\n *   explicitly specified and using a regex with flag g, `scope` is 'all'.\n * @returns {String} New string with one or all matches replaced.\n * @example\n *\n * // Regex search, using named backreferences in replacement string\n * const name = XRegExp('(?<first>\\\\w+) (?<last>\\\\w+)');\n * XRegExp.replace('John Smith', name, '$<last>, $<first>');\n * // -> 'Smith, John'\n *\n * // Regex search, using named backreferences in replacement function\n * XRegExp.replace('John Smith', name, (match) => `${match.last}, ${match.first}`);\n * // -> 'Smith, John'\n *\n * // String search, with replace-all\n * XRegExp.replace('RegExp builds RegExps', 'RegExp', 'XRegExp', 'all');\n * // -> 'XRegExp builds XRegExps'\n */\n\n\nXRegExp.replace = function (str, search, replacement, scope) {\n  var isRegex = XRegExp.isRegExp(search);\n  var global = search.global && scope !== 'one' || scope === 'all';\n  var cacheKey = (global ? 'g' : '') + (search.sticky ? 'y' : '') || 'noGY';\n  var s2 = search;\n\n  if (isRegex) {\n    search[REGEX_DATA] = search[REGEX_DATA] || {}; // Shares cached copies with `XRegExp.exec`/`match`. Since a copy is used, `search`'s\n    // `lastIndex` isn't updated *during* replacement iterations\n\n    s2 = search[REGEX_DATA][cacheKey] || (search[REGEX_DATA][cacheKey] = copyRegex(search, {\n      addG: !!global,\n      removeG: scope === 'one',\n      isInternalOnly: true\n    }));\n  } else if (global) {\n    s2 = new RegExp(XRegExp.escape(String(search)), 'g');\n  } // Fixed `replace` required for named backreferences, etc.\n\n\n  var result = fixed.replace.call(toObject(str), s2, replacement);\n\n  if (isRegex && search.global) {\n    // Fixes IE, Safari bug (last tested IE 9, Safari 5.1)\n    search.lastIndex = 0;\n  }\n\n  return result;\n};\n/**\n * Performs batch processing of string replacements. Used like `XRegExp.replace`, but accepts an\n * array of replacement details. Later replacements operate on the output of earlier replacements.\n * Replacement details are accepted as an array with a regex or string to search for, the\n * replacement string or function, and an optional scope of 'one' or 'all'. Uses the XRegExp\n * replacement text syntax, which supports named backreference properties via `${name}` or\n * `$<name>`.\n *\n * @memberOf XRegExp\n * @param {String} str String to search.\n * @param {Array} replacements Array of replacement detail arrays.\n * @returns {String} New string with all replacements.\n * @example\n *\n * str = XRegExp.replaceEach(str, [\n *   [XRegExp('(?<name>a)'), 'z${name}'],\n *   [/b/gi, 'y'],\n *   [/c/g, 'x', 'one'], // scope 'one' overrides /g\n *   [/d/, 'w', 'all'],  // scope 'all' overrides lack of /g\n *   ['e', 'v', 'all'],  // scope 'all' allows replace-all for strings\n *   [/f/g, ($0) => $0.toUpperCase()]\n * ]);\n */\n\n\nXRegExp.replaceEach = function (str, replacements) {\n  var _iterator4 = _createForOfIteratorHelper(replacements),\n      _step4;\n\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var r = _step4.value;\n      str = XRegExp.replace(str, r[0], r[1], r[2]);\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n\n  return str;\n};\n/**\n * Splits a string into an array of strings using a regex or string separator. Matches of the\n * separator are not included in the result array. However, if `separator` is a regex that contains\n * capturing groups, backreferences are spliced into the result each time `separator` is matched.\n * Fixes browser bugs compared to the native `String.prototype.split` and can be used reliably\n * cross-browser.\n *\n * @memberOf XRegExp\n * @param {String} str String to split.\n * @param {RegExp|String} separator Regex or string to use for separating the string.\n * @param {Number} [limit] Maximum number of items to include in the result array.\n * @returns {Array} Array of substrings.\n * @example\n *\n * // Basic use\n * XRegExp.split('a b c', ' ');\n * // -> ['a', 'b', 'c']\n *\n * // With limit\n * XRegExp.split('a b c', ' ', 2);\n * // -> ['a', 'b']\n *\n * // Backreferences in result array\n * XRegExp.split('..word1..', /([a-z]+)(\\d+)/i);\n * // -> ['..', 'word', '1', '..']\n */\n\n\nXRegExp.split = function (str, separator, limit) {\n  return fixed.split.call(toObject(str), separator, limit);\n};\n/**\n * Executes a regex search in a specified string. Returns `true` or `false`. Optional `pos` and\n * `sticky` arguments specify the search start position, and whether the match must start at the\n * specified position only. The `lastIndex` property of the provided regex is not used, but is\n * updated for compatibility. Also fixes browser bugs compared to the native\n * `RegExp.prototype.test` and can be used reliably cross-browser.\n *\n * @memberOf XRegExp\n * @param {String} str String to search.\n * @param {RegExp} regex Regex to search with.\n * @param {Number} [pos=0] Zero-based index at which to start the search.\n * @param {Boolean|String} [sticky=false] Whether the match must start at the specified position\n *   only. The string `'sticky'` is accepted as an alternative to `true`.\n * @returns {boolean} Whether the regex matched the provided value.\n * @example\n *\n * // Basic use\n * XRegExp.test('abc', /c/); // -> true\n *\n * // With pos and sticky\n * XRegExp.test('abc', /c/, 0, 'sticky'); // -> false\n * XRegExp.test('abc', /c/, 2, 'sticky'); // -> true\n */\n// Do this the easy way :-)\n\n\nXRegExp.test = function (str, regex, pos, sticky) {\n  return !!XRegExp.exec(str, regex, pos, sticky);\n};\n/**\n * Uninstalls optional features according to the specified options. All optional features start out\n * uninstalled, so this is used to undo the actions of `XRegExp.install`.\n *\n * @memberOf XRegExp\n * @param {Object|String} options Options object or string.\n * @example\n *\n * // With an options object\n * XRegExp.uninstall({\n *   // Disables support for astral code points in Unicode addons\n *   astral: true,\n *\n *   // Don't add named capture groups to the `groups` property of matches\n *   namespacing: true\n * });\n *\n * // With an options string\n * XRegExp.uninstall('astral namespacing');\n */\n\n\nXRegExp.uninstall = function (options) {\n  options = prepareOptions(options);\n\n  if (features.astral && options.astral) {\n    setAstral(false);\n  }\n\n  if (features.namespacing && options.namespacing) {\n    setNamespacing(false);\n  }\n};\n/**\n * Returns an XRegExp object that is the union of the given patterns. Patterns can be provided as\n * regex objects or strings. Metacharacters are escaped in patterns provided as strings.\n * Backreferences in provided regex objects are automatically renumbered to work correctly within\n * the larger combined pattern. Native flags used by provided regexes are ignored in favor of the\n * `flags` argument.\n *\n * @memberOf XRegExp\n * @param {Array} patterns Regexes and strings to combine.\n * @param {String} [flags] Any combination of XRegExp flags.\n * @param {Object} [options] Options object with optional properties:\n *   - `conjunction` {String} Type of conjunction to use: 'or' (default) or 'none'.\n * @returns {RegExp} Union of the provided regexes and strings.\n * @example\n *\n * XRegExp.union(['a+b*c', /(dogs)\\1/, /(cats)\\1/], 'i');\n * // -> /a\\+b\\*c|(dogs)\\1|(cats)\\2/i\n *\n * XRegExp.union([/man/, /bear/, /pig/], 'i', {conjunction: 'none'});\n * // -> /manbearpig/i\n */\n\n\nXRegExp.union = function (patterns, flags, options) {\n  options = options || {};\n  var conjunction = options.conjunction || 'or';\n  var numCaptures = 0;\n  var numPriorCaptures;\n  var captureNames;\n\n  function rewrite(match, paren, backref) {\n    var name = captureNames[numCaptures - numPriorCaptures]; // Capturing group\n\n    if (paren) {\n      ++numCaptures; // If the current capture has a name, preserve the name\n\n      if (name) {\n        return \"(?<\".concat(name, \">\");\n      } // Backreference\n\n    } else if (backref) {\n      // Rewrite the backreference\n      return \"\\\\\".concat(+backref + numPriorCaptures);\n    }\n\n    return match;\n  }\n\n  if (!(isType(patterns, 'Array') && patterns.length)) {\n    throw new TypeError('Must provide a nonempty array of patterns to merge');\n  }\n\n  var parts = /(\\()(?!\\?)|\\\\([1-9]\\d*)|\\\\[\\s\\S]|\\[(?:[^\\\\\\]]|\\\\[\\s\\S])*\\]/g;\n  var output = [];\n\n  var _iterator5 = _createForOfIteratorHelper(patterns),\n      _step5;\n\n  try {\n    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n      var pattern = _step5.value;\n\n      if (XRegExp.isRegExp(pattern)) {\n        numPriorCaptures = numCaptures;\n        captureNames = pattern[REGEX_DATA] && pattern[REGEX_DATA].captureNames || []; // Rewrite backreferences. Passing to XRegExp dies on octals and ensures patterns are\n        // independently valid; helps keep this simple. Named captures are put back\n\n        output.push(nativ.replace.call(XRegExp(pattern.source).source, parts, rewrite));\n      } else {\n        output.push(XRegExp.escape(pattern));\n      }\n    }\n  } catch (err) {\n    _iterator5.e(err);\n  } finally {\n    _iterator5.f();\n  }\n\n  var separator = conjunction === 'none' ? '' : '|';\n  return XRegExp(output.join(separator), flags);\n}; // ==--------------------------==\n// Fixed/extended native methods\n// ==--------------------------==\n\n/**\n * Adds named capture support (with backreferences returned as `result.name`), and fixes browser\n * bugs in the native `RegExp.prototype.exec`. Use via `XRegExp.exec`.\n *\n * @memberOf RegExp\n * @param {String} str String to search.\n * @returns {Array} Match array with named backreference properties, or `null`.\n */\n\n\nfixed.exec = function (str) {\n  var origLastIndex = this.lastIndex;\n  var match = nativ.exec.apply(this, arguments);\n\n  if (match) {\n    // Fix browsers whose `exec` methods don't return `undefined` for nonparticipating capturing\n    // groups. This fixes IE 5.5-8, but not IE 9's quirks mode or emulation of older IEs. IE 9\n    // in standards mode follows the spec.\n    if (!correctExecNpcg && match.length > 1 && (0, _includes[\"default\"])(match).call(match, '')) {\n      var _context3;\n\n      var r2 = copyRegex(this, {\n        removeG: true,\n        isInternalOnly: true\n      }); // Using `str.slice(match.index)` rather than `match[0]` in case lookahead allowed\n      // matching due to characters outside the match\n\n      nativ.replace.call((0, _slice[\"default\"])(_context3 = String(str)).call(_context3, match.index), r2, function () {\n        var len = arguments.length; // Skip index 0 and the last 2\n\n        for (var i = 1; i < len - 2; ++i) {\n          if ((i < 0 || arguments.length <= i ? undefined : arguments[i]) === undefined) {\n            match[i] = undefined;\n          }\n        }\n      });\n    } // Attach named capture properties\n\n\n    var groupsObject = match;\n\n    if (XRegExp.isInstalled('namespacing')) {\n      // https://tc39.github.io/proposal-regexp-named-groups/#sec-regexpbuiltinexec\n      match.groups = (0, _create[\"default\"])(null);\n      groupsObject = match.groups;\n    }\n\n    if (this[REGEX_DATA] && this[REGEX_DATA].captureNames) {\n      // Skip index 0\n      for (var i = 1; i < match.length; ++i) {\n        var name = this[REGEX_DATA].captureNames[i - 1];\n\n        if (name) {\n          groupsObject[name] = match[i];\n        }\n      }\n    } // Fix browsers that increment `lastIndex` after zero-length matches\n\n\n    if (this.global && !match[0].length && this.lastIndex > match.index) {\n      this.lastIndex = match.index;\n    }\n  }\n\n  if (!this.global) {\n    // Fixes IE, Opera bug (last tested IE 9, Opera 11.6)\n    this.lastIndex = origLastIndex;\n  }\n\n  return match;\n};\n/**\n * Fixes browser bugs in the native `RegExp.prototype.test`.\n *\n * @memberOf RegExp\n * @param {String} str String to search.\n * @returns {boolean} Whether the regex matched the provided value.\n */\n\n\nfixed.test = function (str) {\n  // Do this the easy way :-)\n  return !!fixed.exec.call(this, str);\n};\n/**\n * Adds named capture support (with backreferences returned as `result.name`), and fixes browser\n * bugs in the native `String.prototype.match`.\n *\n * @memberOf String\n * @param {RegExp|*} regex Regex to search with. If not a regex object, it is passed to `RegExp`.\n * @returns {Array} If `regex` uses flag g, an array of match strings or `null`. Without flag g,\n *   the result of calling `regex.exec(this)`.\n */\n\n\nfixed.match = function (regex) {\n  if (!XRegExp.isRegExp(regex)) {\n    // Use the native `RegExp` rather than `XRegExp`\n    regex = new RegExp(regex);\n  } else if (regex.global) {\n    var result = nativ.match.apply(this, arguments); // Fixes IE bug\n\n    regex.lastIndex = 0;\n    return result;\n  }\n\n  return fixed.exec.call(regex, toObject(this));\n};\n/**\n * Adds support for `${n}` (or `$<n>`) tokens for named and numbered backreferences in replacement\n * text, and provides named backreferences to replacement functions as `arguments[0].name`. Also\n * fixes browser bugs in replacement text syntax when performing a replacement using a nonregex\n * search value, and the value of a replacement regex's `lastIndex` property during replacement\n * iterations and upon completion. Note that this doesn't support SpiderMonkey's proprietary third\n * (`flags`) argument. Use via `XRegExp.replace`.\n *\n * @memberOf String\n * @param {RegExp|String} search Search pattern to be replaced.\n * @param {String|Function} replacement Replacement string or a function invoked to create it.\n * @returns {string} New string with one or all matches replaced.\n */\n\n\nfixed.replace = function (search, replacement) {\n  var isRegex = XRegExp.isRegExp(search);\n  var origLastIndex;\n  var captureNames;\n  var result;\n\n  if (isRegex) {\n    if (search[REGEX_DATA]) {\n      captureNames = search[REGEX_DATA].captureNames;\n    } // Only needed if `search` is nonglobal\n\n\n    origLastIndex = search.lastIndex;\n  } else {\n    search += ''; // Type-convert\n  } // Don't use `typeof`; some older browsers return 'function' for regex objects\n\n\n  if (isType(replacement, 'Function')) {\n    // Stringifying `this` fixes a bug in IE < 9 where the last argument in replacement\n    // functions isn't type-converted to a string\n    result = nativ.replace.call(String(this), search, function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      if (captureNames) {\n        var groupsObject;\n\n        if (XRegExp.isInstalled('namespacing')) {\n          // https://tc39.github.io/proposal-regexp-named-groups/#sec-regexpbuiltinexec\n          groupsObject = (0, _create[\"default\"])(null);\n          args.push(groupsObject);\n        } else {\n          // Change the `args[0]` string primitive to a `String` object that can store\n          // properties. This really does need to use `String` as a constructor\n          args[0] = new String(args[0]);\n          groupsObject = args[0];\n        } // Store named backreferences\n\n\n        for (var i = 0; i < captureNames.length; ++i) {\n          if (captureNames[i]) {\n            groupsObject[captureNames[i]] = args[i + 1];\n          }\n        }\n      } // ES6 specs the context for replacement functions as `undefined`\n\n\n      return replacement.apply(void 0, args);\n    });\n  } else {\n    // Ensure that the last value of `args` will be a string when given nonstring `this`,\n    // while still throwing on null or undefined context\n    result = nativ.replace.call(this == null ? this : String(this), search, function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      return nativ.replace.call(String(replacement), replacementToken, replacer);\n\n      function replacer($0, bracketed, angled, dollarToken) {\n        bracketed = bracketed || angled; // Named or numbered backreference with curly or angled braces\n\n        if (bracketed) {\n          // XRegExp behavior for `${n}` or `$<n>`:\n          // 1. Backreference to numbered capture, if `n` is an integer. Use `0` for the\n          //    entire match. Any number of leading zeros may be used.\n          // 2. Backreference to named capture `n`, if it exists and is not an integer\n          //    overridden by numbered capture. In practice, this does not overlap with\n          //    numbered capture since XRegExp does not allow named capture to use a bare\n          //    integer as the name.\n          // 3. If the name or number does not refer to an existing capturing group, it's\n          //    an error.\n          var n = +bracketed; // Type-convert; drop leading zeros\n\n          if (n <= args.length - 3) {\n            return args[n] || '';\n          } // Groups with the same name is an error, else would need `lastIndexOf`\n\n\n          n = captureNames ? (0, _indexOf[\"default\"])(captureNames).call(captureNames, bracketed) : -1;\n\n          if (n < 0) {\n            throw new SyntaxError(\"Backreference to undefined group \".concat($0));\n          }\n\n          return args[n + 1] || '';\n        } // Else, special variable or numbered backreference without curly braces\n\n\n        if (dollarToken === '$') {\n          // $$\n          return '$';\n        }\n\n        if (dollarToken === '&' || +dollarToken === 0) {\n          // $&, $0 (not followed by 1-9), $00\n          return args[0];\n        }\n\n        if (dollarToken === '`') {\n          var _context4;\n\n          // $` (left context)\n          return (0, _slice[\"default\"])(_context4 = args[args.length - 1]).call(_context4, 0, args[args.length - 2]);\n        }\n\n        if (dollarToken === \"'\") {\n          var _context5;\n\n          // $' (right context)\n          return (0, _slice[\"default\"])(_context5 = args[args.length - 1]).call(_context5, args[args.length - 2] + args[0].length);\n        } // Else, numbered backreference without braces\n\n\n        dollarToken = +dollarToken; // Type-convert; drop leading zero\n        // XRegExp behavior for `$n` and `$nn`:\n        // - Backrefs end after 1 or 2 digits. Use `${..}` or `$<..>` for more digits.\n        // - `$1` is an error if no capturing groups.\n        // - `$10` is an error if less than 10 capturing groups. Use `${1}0` or `$<1>0`\n        //   instead.\n        // - `$01` is `$1` if at least one capturing group, else it's an error.\n        // - `$0` (not followed by 1-9) and `$00` are the entire match.\n        // Native behavior, for comparison:\n        // - Backrefs end after 1 or 2 digits. Cannot reference capturing group 100+.\n        // - `$1` is a literal `$1` if no capturing groups.\n        // - `$10` is `$1` followed by a literal `0` if less than 10 capturing groups.\n        // - `$01` is `$1` if at least one capturing group, else it's a literal `$01`.\n        // - `$0` is a literal `$0`.\n\n        if (!isNaN(dollarToken)) {\n          if (dollarToken > args.length - 3) {\n            throw new SyntaxError(\"Backreference to undefined group \".concat($0));\n          }\n\n          return args[dollarToken] || '';\n        } // `$` followed by an unsupported char is an error, unlike native JS\n\n\n        throw new SyntaxError(\"Invalid token \".concat($0));\n      }\n    });\n  }\n\n  if (isRegex) {\n    if (search.global) {\n      // Fixes IE, Safari bug (last tested IE 9, Safari 5.1)\n      search.lastIndex = 0;\n    } else {\n      // Fixes IE, Opera bug (last tested IE 9, Opera 11.6)\n      search.lastIndex = origLastIndex;\n    }\n  }\n\n  return result;\n};\n/**\n * Fixes browser bugs in the native `String.prototype.split`. Use via `XRegExp.split`.\n *\n * @memberOf String\n * @param {RegExp|String} separator Regex or string to use for separating the string.\n * @param {Number} [limit] Maximum number of items to include in the result array.\n * @returns {!Array} Array of substrings.\n */\n\n\nfixed.split = function (separator, limit) {\n  if (!XRegExp.isRegExp(separator)) {\n    // Browsers handle nonregex split correctly, so use the faster native method\n    return nativ.split.apply(this, arguments);\n  }\n\n  var str = String(this);\n  var output = [];\n  var origLastIndex = separator.lastIndex;\n  var lastLastIndex = 0;\n  var lastLength; // Values for `limit`, per the spec:\n  // If undefined: pow(2,32) - 1\n  // If 0, Infinity, or NaN: 0\n  // If positive number: limit = floor(limit); if (limit >= pow(2,32)) limit -= pow(2,32);\n  // If negative number: pow(2,32) - floor(abs(limit))\n  // If other: Type-convert, then use the above rules\n  // This line fails in very strange ways for some values of `limit` in Opera 10.5-10.63, unless\n  // Opera Dragonfly is open (go figure). It works in at least Opera 9.5-10.1 and 11+\n\n  limit = (limit === undefined ? -1 : limit) >>> 0;\n  (0, _forEach[\"default\"])(XRegExp).call(XRegExp, str, separator, function (match) {\n    // This condition is not the same as `if (match[0].length)`\n    if (match.index + match[0].length > lastLastIndex) {\n      output.push((0, _slice[\"default\"])(str).call(str, lastLastIndex, match.index));\n\n      if (match.length > 1 && match.index < str.length) {\n        Array.prototype.push.apply(output, (0, _slice[\"default\"])(match).call(match, 1));\n      }\n\n      lastLength = match[0].length;\n      lastLastIndex = match.index + lastLength;\n    }\n  });\n\n  if (lastLastIndex === str.length) {\n    if (!nativ.test.call(separator, '') || lastLength) {\n      output.push('');\n    }\n  } else {\n    output.push((0, _slice[\"default\"])(str).call(str, lastLastIndex));\n  }\n\n  separator.lastIndex = origLastIndex;\n  return output.length > limit ? (0, _slice[\"default\"])(output).call(output, 0, limit) : output;\n}; // ==--------------------------==\n// Built-in syntax/flag tokens\n// ==--------------------------==\n\n/*\n * Letter escapes that natively match literal characters: `\\a`, `\\A`, etc. These should be\n * SyntaxErrors but are allowed in web reality. XRegExp makes them errors for cross-browser\n * consistency and to reserve their syntax, but lets them be superseded by addons.\n */\n\n\nXRegExp.addToken(/\\\\([ABCE-RTUVXYZaeg-mopqyz]|c(?![A-Za-z])|u(?![\\dA-Fa-f]{4}|{[\\dA-Fa-f]+})|x(?![\\dA-Fa-f]{2}))/, function (match, scope) {\n  // \\B is allowed in default scope only\n  if (match[1] === 'B' && scope === defaultScope) {\n    return match[0];\n  }\n\n  throw new SyntaxError(\"Invalid escape \".concat(match[0]));\n}, {\n  scope: 'all',\n  leadChar: '\\\\'\n});\n/*\n * Unicode code point escape with curly braces: `\\u{N..}`. `N..` is any one or more digit\n * hexadecimal number from 0-10FFFF, and can include leading zeros. Requires the native ES6 `u` flag\n * to support code points greater than U+FFFF. Avoids converting code points above U+FFFF to\n * surrogate pairs (which could be done without flag `u`), since that could lead to broken behavior\n * if you follow a `\\u{N..}` token that references a code point above U+FFFF with a quantifier, or\n * if you use the same in a character class.\n */\n\nXRegExp.addToken(/\\\\u{([\\dA-Fa-f]+)}/, function (match, scope, flags) {\n  var code = dec(match[1]);\n\n  if (code > 0x10FFFF) {\n    throw new SyntaxError(\"Invalid Unicode code point \".concat(match[0]));\n  }\n\n  if (code <= 0xFFFF) {\n    // Converting to \\uNNNN avoids needing to escape the literal character and keep it\n    // separate from preceding tokens\n    return \"\\\\u\".concat(pad4(hex(code)));\n  } // If `code` is between 0xFFFF and 0x10FFFF, require and defer to native handling\n\n\n  if (hasNativeU && (0, _includes[\"default\"])(flags).call(flags, 'u')) {\n    return match[0];\n  }\n\n  throw new SyntaxError('Cannot use Unicode code point above \\\\u{FFFF} without flag u');\n}, {\n  scope: 'all',\n  leadChar: '\\\\'\n});\n/*\n * Empty character class: `[]` or `[^]`. This fixes a critical cross-browser syntax inconsistency.\n * Unless this is standardized (per the ES spec), regex syntax can't be accurately parsed because\n * character class endings can't be determined.\n */\n\nXRegExp.addToken(/\\[(\\^?)\\]/, // For cross-browser compatibility with ES3, convert [] to \\b\\B and [^] to [\\s\\S].\n// (?!) should work like \\b\\B, but is unreliable in some versions of Firefox\n\n/* eslint-disable no-confusing-arrow */\nfunction (match) {\n  return match[1] ? '[\\\\s\\\\S]' : '\\\\b\\\\B';\n},\n/* eslint-enable no-confusing-arrow */\n{\n  leadChar: '['\n});\n/*\n * Comment pattern: `(?# )`. Inline comments are an alternative to the line comments allowed in\n * free-spacing mode (flag x).\n */\n\nXRegExp.addToken(/\\(\\?#[^)]*\\)/, getContextualTokenSeparator, {\n  leadChar: '('\n});\n/*\n * Whitespace and line comments, in free-spacing mode (aka extended mode, flag x) only.\n */\n\nXRegExp.addToken(/\\s+|#[^\\n]*\\n?/, getContextualTokenSeparator, {\n  flag: 'x'\n});\n/*\n * Dot, in dotall mode (aka singleline mode, flag s) only.\n */\n\nXRegExp.addToken(/\\./, function () {\n  return '[\\\\s\\\\S]';\n}, {\n  flag: 's',\n  leadChar: '.'\n});\n/*\n * Named backreference: `\\k<name>`. Backreference names can use the characters A-Z, a-z, 0-9, _,\n * and $ only. Also allows numbered backreferences as `\\k<n>`.\n */\n\nXRegExp.addToken(/\\\\k<([\\w$]+)>/, function (match) {\n  var _context6, _context7;\n\n  // Groups with the same name is an error, else would need `lastIndexOf`\n  var index = isNaN(match[1]) ? (0, _indexOf[\"default\"])(_context6 = this.captureNames).call(_context6, match[1]) + 1 : +match[1];\n  var endIndex = match.index + match[0].length;\n\n  if (!index || index > this.captureNames.length) {\n    throw new SyntaxError(\"Backreference to undefined group \".concat(match[0]));\n  } // Keep backreferences separate from subsequent literal numbers. This avoids e.g.\n  // inadvertedly changing `(?<n>)\\k<n>1` to `()\\11`.\n\n\n  return (0, _concat[\"default\"])(_context7 = \"\\\\\".concat(index)).call(_context7, endIndex === match.input.length || isNaN(match.input[endIndex]) ? '' : '(?:)');\n}, {\n  leadChar: '\\\\'\n});\n/*\n * Numbered backreference or octal, plus any following digits: `\\0`, `\\11`, etc. Octals except `\\0`\n * not followed by 0-9 and backreferences to unopened capture groups throw an error. Other matches\n * are returned unaltered. IE < 9 doesn't support backreferences above `\\99` in regex syntax.\n */\n\nXRegExp.addToken(/\\\\(\\d+)/, function (match, scope) {\n  if (!(scope === defaultScope && /^[1-9]/.test(match[1]) && +match[1] <= this.captureNames.length) && match[1] !== '0') {\n    throw new SyntaxError(\"Cannot use octal escape or backreference to undefined group \".concat(match[0]));\n  }\n\n  return match[0];\n}, {\n  scope: 'all',\n  leadChar: '\\\\'\n});\n/*\n * Named capturing group; match the opening delimiter only: `(?<name>`. Capture names can use the\n * characters A-Z, a-z, 0-9, _, and $ only. Names can't be integers. Supports Python-style\n * `(?P<name>` as an alternate syntax to avoid issues in some older versions of Opera which natively\n * supported the Python-style syntax. Otherwise, XRegExp might treat numbered backreferences to\n * Python-style named capture as octals.\n */\n\nXRegExp.addToken(/\\(\\?P?<([\\w$]+)>/, function (match) {\n  var _context8;\n\n  // Disallow bare integers as names because named backreferences are added to match arrays\n  // and therefore numeric properties may lead to incorrect lookups\n  if (!isNaN(match[1])) {\n    throw new SyntaxError(\"Cannot use integer as capture name \".concat(match[0]));\n  }\n\n  if (!XRegExp.isInstalled('namespacing') && (match[1] === 'length' || match[1] === '__proto__')) {\n    throw new SyntaxError(\"Cannot use reserved word as capture name \".concat(match[0]));\n  }\n\n  if ((0, _includes[\"default\"])(_context8 = this.captureNames).call(_context8, match[1])) {\n    throw new SyntaxError(\"Cannot use same name for multiple groups \".concat(match[0]));\n  }\n\n  this.captureNames.push(match[1]);\n  this.hasNamedCapture = true;\n  return '(';\n}, {\n  leadChar: '('\n});\n/*\n * Capturing group; match the opening parenthesis only. Required for support of named capturing\n * groups. Also adds explicit capture mode (flag n).\n */\n\nXRegExp.addToken(/\\((?!\\?)/, function (match, scope, flags) {\n  if ((0, _includes[\"default\"])(flags).call(flags, 'n')) {\n    return '(?:';\n  }\n\n  this.captureNames.push(null);\n  return '(';\n}, {\n  optionalFlags: 'n',\n  leadChar: '('\n});\nvar _default = XRegExp;\nexports[\"default\"] = _default;\nmodule.exports = exports.default;"],"mappings":"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"},"metadata":{},"sourceType":"script"}