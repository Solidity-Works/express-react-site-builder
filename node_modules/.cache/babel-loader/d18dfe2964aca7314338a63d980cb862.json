{"ast":null,"code":"import { each, isString } from 'underscore';\nimport { parse as nodeHtmlParser } from \"node-html-parser\";\nimport XRegExp from \"xregexp\";\nwindow.nodeHtmlParser = nodeHtmlParser;\n\n/**\r\n * Parses an HTML string into its HTML and CSS component representation keeping case of tags and attributes. This\r\n * is necessary in case you want React compatible JSX tags in the template, in which case the react components must start\r\n * wih uppercase and also the camel casing of attributes is importane (ie. className vs classname)\r\n *\r\n * This function is based on src/parser/model/ParserHtml.js. For parsing we are using node-html-parser instead of\r\n * the browser's DOM to keep the case of tags and attributes. The code is mostly the same  as in ParserHtml.js\r\n * by maing the objects created by  node-html-parser compatible with the DOM representation.\r\n *\r\n * @param config usual grapesjs config\r\n * @returns parser function\r\n */\nexport default (config => {\n  var TEXT_NODE = 'span';\n  var c = config;\n  var modelAttrStart = 'data-gjs-';\n  return {\n    compTypes: '',\n    modelAttrStart,\n    /**\r\n     * Extract component props from an attribute object\r\n     * @param {Object} attr\r\n     * @returns {Object} An object containing props and attributes without them\r\n     */\n    splitPropsFromAttr() {\n      let attr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      const props = {};\n      const attrs = {};\n      each(attr, (value, key) => {\n        if (key.indexOf(this.modelAttrStart) === 0) {\n          const modelAttr = key.replace(modelAttrStart, '');\n          const valueLen = value.length;\n          const valStr = value && isString(value);\n          const firstChar = valStr && value.substr(0, 1);\n          const lastChar = valStr && value.substr(valueLen - 1);\n          value = value === 'true' ? true : value;\n          value = value === 'false' ? false : value;\n\n          // Try to parse JSON where it's possible\n          // I can get false positive here (eg. a selector '[data-attr]')\n          // so put it under try/catch and let fail silently\n          try {\n            value = firstChar == '{' && lastChar == '}' || firstChar == '[' && lastChar == ']' ? JSON.parse(value) : value;\n          } catch (e) {}\n          props[modelAttr] = value;\n        } else {\n          attrs[key] = value;\n        }\n      });\n      return {\n        props,\n        attrs\n      };\n    },\n    /**\r\n     * Given a string with html (jsx). Attributes having JSX expressions will be quoted to look like\r\n     * actual HTML attributes\r\n     * @param {*} html\r\n     * @return html with quoted JSX attributes\r\n     *\r\n     * https://stackoverflow.com/questions/546433/regular-expression-to-match-balanced-parentheses\r\n     */\n    quoteJsxExpresionsInAttributes(html) {\n      let found = XRegExp.matchRecursive(html, \"{\", \"}\", \"g\");\n      for (let i = 0; i < found.length; i++) {\n        // (value) => \\`\\${(value) => < 10 ? \\`0\\${value}\\` : value)}\\`\n        // --> {(value) => \\`\\${(value) => < 10 ? \\`0\\${value}\\` : value)}\\`}\n        let pattern = \"{\" + found[i] + \"}\";\n        let lastStartPos = 0;\n        // Find pattern until we reach and of html\n        while (true) {\n          let needsQuote = false;\n          // get next match position\n          let matchPos = html.indexOf(pattern, lastStartPos);\n          if (matchPos === -1) {\n            break;\n          }\n          // We will look back 1 and 2 characters\n          let oneCharBeforePos = matchPos - 1;\n          let twoCharBeforePos = matchPos - 2;\n          if (twoCharBeforePos > 0 && oneCharBeforePos > 0) {\n            // Need to quote if have sg like this:\n            //   formatValue={(value) => \\`\\${(value) => < 10 ? \\`0\\${value}\\` : value)}\\`}\n            // (ie: if patterns comes atfre and equals sime, but not =\")\n            // But no need to quote if:\n            //    formatValue=\"{(value) => \\`\\${(value) => < 10 ? \\`0\\${value}\\` : value)}\\`}\"\n            //    <Timer.Days/>{this.model.attributes.displayLabels ? \" \"+this.model.attributes.labels.labelDays+\" \" : ', '}\n            needsQuote = html.substring(twoCharBeforePos, twoCharBeforePos + 2) !== '=\"' && html.substring(oneCharBeforePos, oneCharBeforePos + 1) === \"=\";\n          }\n\n          // If need to quote: replace patterns with quoted version also escaping some HTML entities\n          if (needsQuote) {\n            let replacement = '\"{' + found[i].replace(\"<\", \"&lt;\").replace(\">\", \"&gt;\").replace(\"&\", \"&amp;\") + '}\"';\n            html = html.replace(pattern, replacement);\n            lastStartPos = matchPos + replacement.length;\n          } else {\n            lastStartPos = matchPos + pattern.length;\n          }\n\n          // No lastStartPos placed after the processed string\n        }\n      }\n\n      return html;\n    },\n    /**\r\n     * Unquote attributes containg JSX previously quoted using quoteJsxExpresionsInAttributes\r\n     * @param html\r\n     */\n    unquoteJsxExpresionsInAttributes(html) {\n      let found = html.match(/=[\"']{.*}[\"']/g);\n      if (!found) {\n        return html;\n      }\n      for (let i = 0; i < found.length; i++) {\n        let pattern = found[i];\n        let replacement = pattern.startsWith('=\"{') ? pattern.replace('\"{', \"{\").replace('}\"', \"}\") : pattern.replace(\"{'\", \"{\").replace(\"}'\", \"}\");\n        replacement = replacement.replace(\"&lt;\", \"<\").replace(\"&gt;\", \">\").replace(\"&amp;\", \"&\");\n        html = html.replace(pattern, replacement);\n      }\n      return html;\n    },\n    /**\r\n     * Parse style string to object\r\n     * @param {string} str\r\n     * @return {Object}\r\n     * @example\r\n     * var stl = ParserHtml.parseStyle('color:black; width:100px; test:value;');\r\n     * console.log(stl);\r\n     * // {color: 'black', width: '100px', test: 'value'}\r\n     */\n    parseStyle(str) {\n      var result = {};\n      var decls = str.split(';');\n      for (var i = 0, len = decls.length; i < len; i++) {\n        var decl = decls[i].trim();\n        if (!decl) continue;\n        var prop = decl.split(':');\n        result[prop[0].trim()] = prop.slice(1).join(':').trim();\n      }\n      return result;\n    },\n    /**\r\n     * Parse class string to array\r\n     * @param {string} str\r\n     * @return {Array<string>}\r\n     * @example\r\n     * var res = ParserHtml.parseClass('test1 test2 test3');\r\n     * console.log(res);\r\n     * // ['test1', 'test2', 'test3']\r\n     */\n    parseClass(str) {\n      const result = [];\n      const cls = str.split(' ');\n      for (let i = 0, len = cls.length; i < len; i++) {\n        const cl = cls[i].trim();\n        if (!cl) continue;\n        result.push(cl);\n      }\n      return result;\n    },\n    toAttrArray(obj) {\n      var attrArr = [];\n      Object.keys(obj).map(key => {\n        attrArr.push({\n          'nodeName': key,\n          'nodeValue': obj[key]\n        });\n      });\n      return attrArr;\n    },\n    /**\r\n     * Get data from the node element\r\n     * @param  {HTMLElement} el DOM element to traverse\r\n     * @return {Array<Object>}\r\n     */\n    parseNode(el) {\n      const result = [];\n      const nodes = el.childNodes;\n      for (var i = 0, len = nodes.length; i < len; i++) {\n        const node = nodes[i];\n\n        // DOM copmatibility\n        node.nodeValue = node.rawText;\n        node.content = node.rawText;\n\n        // Make attrs compatible with DOM representation\n        let attrs = [];\n        attrs = (typeof node.attributes == 'object' ? this.toAttrArray(node.attributes) : node.attributes) || [];\n        const attrsLen = attrs.length;\n        const nodePrev = result[result.length - 1];\n        const nodeChild = node.childNodes.length;\n        const ct = this.compTypes;\n        let model = {};\n        if (ct) {\n          let obj = '';\n          let type = node.getAttribute && node.getAttribute(`${modelAttrStart}type`);\n          if (!type) {\n            type = node.attributes && node.attributes[`${modelAttrStart}type`];\n          }\n          if (type) {\n            model = {\n              type\n            };\n          } else {\n            for (let it = 0; it < ct.length; it++) {\n              const compType = ct[it];\n              obj = compType.model.isComponent(node);\n              if (obj) {\n                if (typeof obj !== 'object') {\n                  obj = {\n                    type: compType.id\n                  };\n                }\n                break;\n              }\n            }\n            model = obj;\n          }\n        }\n        model.tagName = node.tagName;\n        if (attrsLen) {\n          model.attributes = {};\n        }\n        for (let j = 0; j < attrsLen; j++) {\n          const nodeName = attrs[j].nodeName;\n          let nodeValue = attrs[j].nodeValue;\n          // if (nodeName == \"formatValue\") {\n          //     debugger;\n          // }\n\n          // Isolate attributes\n          if (nodeName == 'style') {\n            model.style = this.parseStyle(nodeValue);\n          } else if (nodeName == 'class') {\n            model.classes = this.parseClass(nodeValue);\n          } else if (nodeName == 'contenteditable') {\n            continue;\n          } else if (nodeName.indexOf(modelAttrStart) === 0) {\n            const modelAttr = nodeName.replace(modelAttrStart, '');\n            const valueLen = nodeValue.length;\n            const firstChar = nodeValue && nodeValue.substr(0, 1);\n            const lastChar = nodeValue && nodeValue.substr(valueLen - 1);\n            nodeValue = nodeValue === 'true' ? true : nodeValue;\n            nodeValue = nodeValue === 'false' ? false : nodeValue;\n            try {\n              nodeValue = firstChar == '{' && lastChar == '}' || firstChar == '[' && lastChar == ']' ? JSON.parse(nodeValue) : nodeValue;\n            } catch (e) {}\n            model[modelAttr] = nodeValue;\n          } else {\n            model.attributes[nodeName] = nodeValue;\n          }\n        }\n        if (nodeChild && !model.components) {\n          const firstChild = node.childNodes[0];\n          firstChild.nodeValue = firstChild.rawText;\n          if (nodeChild === 1 && firstChild.nodeType === 3) {\n            !model.type && (model.type = 'text');\n            model.content = firstChild.nodeValue;\n          } else {\n            model.components = this.parseNode(node);\n          }\n        }\n        if (model.type == 'textnode') {\n          model.content = node.nodeValue;\n          if (nodePrev && nodePrev.type == 'textnode') {\n            nodePrev.content += model.content;\n            continue;\n          }\n          if (!config.keepEmptyTextNodes) {\n            const content = node.nodeValue;\n            if (content != ' ' && !content.trim()) {\n              continue;\n            }\n          }\n        }\n        const comps = model.components;\n        if (!model.type && comps) {\n          let allTxt = 1;\n          let foundTextNode = 0;\n          for (let ci = 0; ci < comps.length; ci++) {\n            const comp = comps[ci];\n            const cType = comp.type;\n            if (['text', 'textnode'].indexOf(cType) < 0 && c.textTags.indexOf(comp.tagName) < 0) {\n              allTxt = 0;\n              break;\n            }\n            if (cType == 'textnode') {\n              foundTextNode = 1;\n            }\n          }\n          if (allTxt && foundTextNode) {\n            model.type = 'text';\n          }\n        }\n        if (!model.tagName && model.type != 'textnode') {\n          continue;\n        }\n        result.push(model);\n      }\n      return result;\n    },\n    /**\r\n     * Parse HTML string to a desired model object\r\n     * @param  {string} str HTML string\r\n     * @param  {ParserCss} parserCss In case there is style tags inside HTML\r\n     * @return {Object}\r\n     *\r\n     */\n    parse(str, parserCss) {\n      console.log(\"html\", str, parserCss);\n      var config = c.em && c.em.get('Config') || {};\n      var res = {\n        html: '',\n        css: ''\n      };\n      var quoted = this.quoteJsxExpresionsInAttributes(str);\n      let wrappedInDiv = false;\n      if (!quoted.startsWith('<')) {\n        quoted = '<div>' + quoted + '</div>';\n        wrappedInDiv = true;\n      }\n      const dom = nodeHtmlParser(quoted);\n      var result = this.parseNode(dom);\n      if (result.length == 1) {\n        result = result[0];\n      }\n      if (wrappedInDiv) {\n        if (result.components) {\n          result = result.components;\n        } else {\n          delete result.tagName;\n          result.type = \"textnode\";\n        }\n      }\n      res.html = result;\n      if (parserCss) {\n        var el = document.createElement('div');\n        el.innerHTML = str;\n        var styleStr = '';\n        var styles = el.querySelectorAll('style');\n        var j = styles.length;\n        while (j--) {\n          styleStr = styles[j].innerHTML + styleStr;\n          styles[j].parentNode.removeChild(styles[j]);\n        }\n        if (styleStr) res.css = parserCss.parse(styleStr);\n      }\n      return res;\n    }\n  };\n});","map":{"version":3,"names":["each","isString","parse","nodeHtmlParser","XRegExp","window","config","TEXT_NODE","c","modelAttrStart","compTypes","splitPropsFromAttr","attr","arguments","length","undefined","props","attrs","value","key","indexOf","modelAttr","replace","valueLen","valStr","firstChar","substr","lastChar","JSON","e","quoteJsxExpresionsInAttributes","html","found","matchRecursive","i","pattern","lastStartPos","needsQuote","matchPos","oneCharBeforePos","twoCharBeforePos","substring","replacement","unquoteJsxExpresionsInAttributes","match","startsWith","parseStyle","str","result","decls","split","len","decl","trim","prop","slice","join","parseClass","cls","cl","push","toAttrArray","obj","attrArr","Object","keys","map","parseNode","el","nodes","childNodes","node","nodeValue","rawText","content","attributes","attrsLen","nodePrev","nodeChild","ct","model","type","getAttribute","it","compType","isComponent","id","tagName","j","nodeName","style","classes","components","firstChild","nodeType","keepEmptyTextNodes","comps","allTxt","foundTextNode","ci","comp","cType","textTags","parserCss","console","log","em","get","res","css","quoted","wrappedInDiv","dom","document","createElement","innerHTML","styleStr","styles","querySelectorAll","parentNode","removeChild"],"sources":["D:/CMK/2023_5/WebsiteBuiderTask/modify/grapesJs/src/Table/ParserHtmlCaseSensitive.js"],"sourcesContent":["import { each, isString } from 'underscore';\r\nimport { parse as nodeHtmlParser } from \"node-html-parser\";\r\nimport XRegExp from \"xregexp\";\r\n\r\nwindow.nodeHtmlParser = nodeHtmlParser;\r\n\r\n/**\r\n * Parses an HTML string into its HTML and CSS component representation keeping case of tags and attributes. This\r\n * is necessary in case you want React compatible JSX tags in the template, in which case the react components must start\r\n * wih uppercase and also the camel casing of attributes is importane (ie. className vs classname)\r\n *\r\n * This function is based on src/parser/model/ParserHtml.js. For parsing we are using node-html-parser instead of\r\n * the browser's DOM to keep the case of tags and attributes. The code is mostly the same  as in ParserHtml.js\r\n * by maing the objects created by  node-html-parser compatible with the DOM representation.\r\n *\r\n * @param config usual grapesjs config\r\n * @returns parser function\r\n */\r\nexport default config => {\r\n    var TEXT_NODE = 'span';\r\n    var c = config;\r\n    var modelAttrStart = 'data-gjs-';\r\n\r\n    return {\r\n        compTypes: '',\r\n\r\n        modelAttrStart,\r\n\r\n        /**\r\n         * Extract component props from an attribute object\r\n         * @param {Object} attr\r\n         * @returns {Object} An object containing props and attributes without them\r\n         */\r\n        splitPropsFromAttr(attr = {}) {\r\n            const props = {};\r\n            const attrs = {};\r\n\r\n            each(attr, (value, key) => {\r\n                if (key.indexOf(this.modelAttrStart) === 0) {\r\n                    const modelAttr = key.replace(modelAttrStart, '');\r\n                    const valueLen = value.length;\r\n                    const valStr = value && isString(value);\r\n                    const firstChar = valStr && value.substr(0, 1);\r\n                    const lastChar = valStr && value.substr(valueLen - 1);\r\n                    value = value === 'true' ? true : value;\r\n                    value = value === 'false' ? false : value;\r\n\r\n                    // Try to parse JSON where it's possible\r\n                    // I can get false positive here (eg. a selector '[data-attr]')\r\n                    // so put it under try/catch and let fail silently\r\n                    try {\r\n                        value =\r\n                            (firstChar == '{' && lastChar == '}') ||\r\n                            (firstChar == '[' && lastChar == ']')\r\n                                ? JSON.parse(value)\r\n                                : value;\r\n                    } catch (e) {}\r\n\r\n                    props[modelAttr] = value;\r\n                } else {\r\n                    attrs[key] = value;\r\n                }\r\n            });\r\n\r\n            return {\r\n                props,\r\n                attrs\r\n            };\r\n        },\r\n\r\n        /**\r\n         * Given a string with html (jsx). Attributes having JSX expressions will be quoted to look like\r\n         * actual HTML attributes\r\n         * @param {*} html\r\n         * @return html with quoted JSX attributes\r\n         *\r\n         * https://stackoverflow.com/questions/546433/regular-expression-to-match-balanced-parentheses\r\n         */\r\n        quoteJsxExpresionsInAttributes(html) {\r\n            let found = XRegExp.matchRecursive(html, \"{\", \"}\", \"g\");\r\n            for (let i = 0; i < found.length; i++) {\r\n                // (value) => \\`\\${(value) => < 10 ? \\`0\\${value}\\` : value)}\\`\r\n                // --> {(value) => \\`\\${(value) => < 10 ? \\`0\\${value}\\` : value)}\\`}\r\n                let pattern = \"{\" + found[i] + \"}\";\r\n                let lastStartPos = 0;\r\n                // Find pattern until we reach and of html\r\n                while (true) {\r\n                    let needsQuote = false;\r\n                    // get next match position\r\n                    let matchPos = html.indexOf(pattern, lastStartPos);\r\n                    if (matchPos === -1) {\r\n                        break;\r\n                    }\r\n                    // We will look back 1 and 2 characters\r\n                    let oneCharBeforePos = matchPos - 1;\r\n                    let twoCharBeforePos = matchPos - 2;\r\n                    if (twoCharBeforePos > 0 && oneCharBeforePos > 0) {\r\n                        // Need to quote if have sg like this:\r\n                        //   formatValue={(value) => \\`\\${(value) => < 10 ? \\`0\\${value}\\` : value)}\\`}\r\n                        // (ie: if patterns comes atfre and equals sime, but not =\")\r\n                        // But no need to quote if:\r\n                        //    formatValue=\"{(value) => \\`\\${(value) => < 10 ? \\`0\\${value}\\` : value)}\\`}\"\r\n                        //    <Timer.Days/>{this.model.attributes.displayLabels ? \" \"+this.model.attributes.labels.labelDays+\" \" : ', '}\r\n                        needsQuote =\r\n                            html.substring(twoCharBeforePos, twoCharBeforePos + 2) !== '=\"' &&\r\n                            html.substring(oneCharBeforePos, oneCharBeforePos + 1) === \"=\";\r\n                    }\r\n\r\n                    // If need to quote: replace patterns with quoted version also escaping some HTML entities\r\n                    if (needsQuote) {\r\n                        let replacement =\r\n                            '\"{' +\r\n                            found[i]\r\n                                .replace(\"<\", \"&lt;\")\r\n                                .replace(\">\", \"&gt;\")\r\n                                .replace(\"&\", \"&amp;\")\r\n                            + '}\"';\r\n                        html = html.replace(pattern, replacement);\r\n                        lastStartPos = matchPos + replacement.length;\r\n                    } else {\r\n                        lastStartPos = matchPos + pattern.length;\r\n                    }\r\n\r\n                    // No lastStartPos placed after the processed string\r\n                }\r\n            }\r\n            return html;\r\n        },\r\n\r\n\r\n\r\n        /**\r\n         * Unquote attributes containg JSX previously quoted using quoteJsxExpresionsInAttributes\r\n         * @param html\r\n         */\r\n        unquoteJsxExpresionsInAttributes(html) {\r\n            let found = html.match(/=[\"']{.*}[\"']/g);\r\n            if (!found) {\r\n                return html;\r\n            }\r\n            for (let i = 0; i < found.length; i++) {\r\n                let pattern = found[i];\r\n                let replacement = pattern.startsWith('=\"{')\r\n                    ? pattern.replace('\"{', \"{\").replace('}\"', \"}\")\r\n                    : pattern.replace(\"{'\", \"{\").replace(\"}'\", \"}\");\r\n                replacement = replacement\r\n                    .replace(\"&lt;\", \"<\")\r\n                    .replace(\"&gt;\", \">\")\r\n                    .replace(\"&amp;\", \"&\");\r\n                html = html.replace(pattern, replacement);\r\n            }\r\n            return html;\r\n        },\r\n\r\n\r\n        /**\r\n         * Parse style string to object\r\n         * @param {string} str\r\n         * @return {Object}\r\n         * @example\r\n         * var stl = ParserHtml.parseStyle('color:black; width:100px; test:value;');\r\n         * console.log(stl);\r\n         * // {color: 'black', width: '100px', test: 'value'}\r\n         */\r\n        parseStyle(str) {\r\n            var result = {};\r\n            var decls = str.split(';');\r\n            for (var i = 0, len = decls.length; i < len; i++) {\r\n                var decl = decls[i].trim();\r\n                if (!decl) continue;\r\n                var prop = decl.split(':');\r\n                result[prop[0].trim()] = prop\r\n                    .slice(1)\r\n                    .join(':')\r\n                    .trim();\r\n            }\r\n            return result;\r\n        },\r\n\r\n        /**\r\n         * Parse class string to array\r\n         * @param {string} str\r\n         * @return {Array<string>}\r\n         * @example\r\n         * var res = ParserHtml.parseClass('test1 test2 test3');\r\n         * console.log(res);\r\n         * // ['test1', 'test2', 'test3']\r\n         */\r\n        parseClass(str) {\r\n            const result = [];\r\n            const cls = str.split(' ');\r\n            for (let i = 0, len = cls.length; i < len; i++) {\r\n                const cl = cls[i].trim();\r\n                if (!cl) continue;\r\n                result.push(cl);\r\n            }\r\n            return result;\r\n        },\r\n\r\n        toAttrArray(obj){\r\n            var attrArr = [];\r\n            Object.keys(obj).map(key => {\r\n                attrArr.push({'nodeName':key, 'nodeValue':obj[key]})\r\n            })\r\n            return attrArr;\r\n        },\r\n\r\n        /**\r\n         * Get data from the node element\r\n         * @param  {HTMLElement} el DOM element to traverse\r\n         * @return {Array<Object>}\r\n         */\r\n        parseNode(el) {\r\n            const result = [];\r\n            const nodes = el.childNodes;\r\n\r\n            for (var i = 0, len = nodes.length; i < len; i++) {\r\n                const node = nodes[i];\r\n\r\n                // DOM copmatibility\r\n                node.nodeValue = node.rawText;\r\n                node.content = node.rawText;\r\n\r\n                // Make attrs compatible with DOM representation\r\n                let attrs = [];\r\n                    attrs = (typeof node.attributes == 'object'\r\n                        ? this.toAttrArray(node.attributes)\r\n                        :  node.attributes)\r\n                        || []\r\n                    const attrsLen = attrs.length;\r\n                const nodePrev = result[result.length - 1];\r\n                const nodeChild = node.childNodes.length;\r\n                const ct = this.compTypes;\r\n                let model = {};\r\n\r\n                if (ct) {\r\n                    let obj = '';\r\n                    let type =\r\n                        node.getAttribute && node.getAttribute(`${modelAttrStart}type`);\r\n                    if (!type) {\r\n                        type = node.attributes && node.attributes[`${modelAttrStart}type`];\r\n                    }\r\n\r\n                    if (type) {\r\n                        model = { type };\r\n                    } else {\r\n                       \r\n                        for (let it = 0; it < ct.length; it++) {\r\n                            const compType = ct[it];\r\n                            obj = compType.model.isComponent(node);\r\n\r\n                            if (obj) {\r\n                                if (typeof obj !== 'object') {\r\n                                    obj = { type: compType.id };\r\n                                }\r\n                                break;\r\n                            }\r\n                        }\r\n\r\n                        model = obj;\r\n                    }\r\n                }\r\n\r\n                model.tagName = node.tagName;\r\n\r\n                if (attrsLen) {\r\n                    model.attributes = {};\r\n                }\r\n\r\n                for (let j = 0; j < attrsLen; j++) {\r\n                    const nodeName = attrs[j].nodeName;\r\n                    let nodeValue = attrs[j].nodeValue;\r\n                    // if (nodeName == \"formatValue\") {\r\n                    //     debugger;\r\n                    // }\r\n\r\n                    // Isolate attributes\r\n                    if (nodeName == 'style') {\r\n                        model.style = this.parseStyle(nodeValue);\r\n                    } else if (nodeName == 'class') {\r\n                        model.classes = this.parseClass(nodeValue);\r\n                    } else if (nodeName == 'contenteditable') {\r\n                        continue;\r\n                    } else if (nodeName.indexOf(modelAttrStart) === 0) {\r\n                        const modelAttr = nodeName.replace(modelAttrStart, '');\r\n                        const valueLen = nodeValue.length;\r\n                        const firstChar = nodeValue && nodeValue.substr(0, 1);\r\n                        const lastChar = nodeValue && nodeValue.substr(valueLen - 1);\r\n                        nodeValue = nodeValue === 'true' ? true : nodeValue;\r\n                        nodeValue = nodeValue === 'false' ? false : nodeValue;\r\n\r\n                      \r\n                        try {\r\n                            nodeValue =\r\n                                (firstChar == '{' && lastChar == '}') ||\r\n                                (firstChar == '[' && lastChar == ']')\r\n                                    ? JSON.parse(nodeValue)\r\n                                    : nodeValue;\r\n                        } catch (e) {}\r\n\r\n                        model[modelAttr] = nodeValue;\r\n                    } else {\r\n                        model.attributes[nodeName] = nodeValue;\r\n                    }\r\n                }\r\n\r\n                if (nodeChild && !model.components) {\r\n                    const firstChild = node.childNodes[0];\r\n                    firstChild.nodeValue = firstChild.rawText;\r\n\r\n                    if (nodeChild === 1 && firstChild.nodeType === 3) {\r\n                        !model.type && (model.type = 'text');\r\n                        model.content = firstChild.nodeValue;\r\n                    } else {\r\n                        model.components = this.parseNode(node);\r\n                    }\r\n                }\r\n\r\n                if (model.type == 'textnode') {\r\n                    model.content = node.nodeValue;\r\n\r\n                    if (nodePrev && nodePrev.type == 'textnode') {\r\n                        nodePrev.content += model.content;\r\n                        continue;\r\n                    }\r\n\r\n                    if (!config.keepEmptyTextNodes) {\r\n                        const content = node.nodeValue;\r\n                        if (content != ' ' && !content.trim()) {\r\n                            continue;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                \r\n                const comps = model.components;\r\n                if (!model.type && comps) {\r\n                    let allTxt = 1;\r\n                    let foundTextNode = 0;\r\n\r\n                    for (let ci = 0; ci < comps.length; ci++) {\r\n                        const comp = comps[ci];\r\n                        const cType = comp.type;\r\n\r\n                        if (\r\n                            ['text', 'textnode'].indexOf(cType) < 0 &&\r\n                            c.textTags.indexOf(comp.tagName) < 0\r\n                        ) {\r\n                            allTxt = 0;\r\n                            break;\r\n                        }\r\n\r\n                        if (cType == 'textnode') {\r\n                            foundTextNode = 1;\r\n                        }\r\n                    }\r\n\r\n                    if (allTxt && foundTextNode) {\r\n                        model.type = 'text';\r\n                    }\r\n                }\r\n\r\n                if (!model.tagName && model.type != 'textnode') {\r\n                    continue;\r\n                }\r\n\r\n                result.push(model);\r\n            }\r\n\r\n            return result;\r\n        },\r\n\r\n        /**\r\n         * Parse HTML string to a desired model object\r\n         * @param  {string} str HTML string\r\n         * @param  {ParserCss} parserCss In case there is style tags inside HTML\r\n         * @return {Object}\r\n         *\r\n         */\r\n        parse(str, parserCss) {\r\n            console.log(\"html\", str, parserCss);\r\n\r\n            var config = (c.em && c.em.get('Config')) || {};\r\n            var res = { html: '', css: '' };\r\n\r\n            var quoted = this.quoteJsxExpresionsInAttributes(str);\r\n            let wrappedInDiv = false;\r\n            if (!quoted.startsWith('<')) {\r\n                quoted = '<div>'+quoted+'</div>';\r\n                wrappedInDiv = true;\r\n            }\r\n            const dom = nodeHtmlParser(quoted);\r\n            var result = this.parseNode(dom);\r\n\r\n            if (result.length == 1) {\r\n                result = result[0];\r\n            }\r\n\r\n            if (wrappedInDiv) {\r\n                if (result.components) {\r\n                    result = result.components;\r\n                }\r\n                \r\n                else {\r\n                    delete result.tagName;\r\n                    result.type = \"textnode\";\r\n                }\r\n            }\r\n            res.html = result;\r\n\r\n           \r\n            if (parserCss) {\r\n                var el = document.createElement('div');\r\n                el.innerHTML = str;\r\n                var styleStr = '';\r\n                var styles = el.querySelectorAll('style');\r\n                var j = styles.length;\r\n\r\n                while (j--) {\r\n                    styleStr = styles[j].innerHTML + styleStr;\r\n                    styles[j].parentNode.removeChild(styles[j]);\r\n                }\r\n\r\n                if (styleStr) res.css = parserCss.parse(styleStr);\r\n            }\r\n\r\n            return res;\r\n        }\r\n    };\r\n};"],"mappings":"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"},"metadata":{},"sourceType":"module"}