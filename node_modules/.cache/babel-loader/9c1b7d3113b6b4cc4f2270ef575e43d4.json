{"ast":null,"code":"import { decode } from 'he';\nimport Node from './node';\nimport NodeType from './type';\nimport TextNode from './text';\nimport Matcher from '../matcher';\nimport arr_back from '../back';\nimport CommentNode from './comment';\nconst kBlockElements = new Map();\nkBlockElements.set('DIV', true);\nkBlockElements.set('div', true);\nkBlockElements.set('P', true);\nkBlockElements.set('p', true);\n// ul: true,\n// ol: true,\nkBlockElements.set('LI', true);\nkBlockElements.set('li', true);\n// table: true,\n// tr: true,\nkBlockElements.set('TD', true);\nkBlockElements.set('td', true);\nkBlockElements.set('SECTION', true);\nkBlockElements.set('section', true);\nkBlockElements.set('BR', true);\nkBlockElements.set('br', true);\n/**\n * HTMLElement, which contains a set of children.\n *\n * Note: this is a minimalist implementation, no complete tree\n *   structure provided (no parentNode, nextSibling,\n *   previousSibling etc).\n * @class HTMLElement\n * @extends {Node}\n */\nexport default class HTMLElement extends Node {\n  /**\n   * Creates an instance of HTMLElement.\n   * @param keyAttrs\tid and class attribute\n   * @param [rawAttrs]\tattributes in string\n   *\n   * @memberof HTMLElement\n   */\n  constructor(tagName, keyAttrs) {\n    let rawAttrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n    let parentNode = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    super();\n    this.rawAttrs = rawAttrs;\n    this.parentNode = parentNode;\n    this.classNames = [];\n    /**\n     * Node Type declaration.\n     */\n    this.nodeType = NodeType.ELEMENT_NODE;\n    this.rawTagName = tagName;\n    this.rawAttrs = rawAttrs || '';\n    this.parentNode = parentNode || null;\n    this.childNodes = [];\n    if (keyAttrs.id) {\n      this.id = keyAttrs.id;\n      if (!rawAttrs) {\n        this.rawAttrs = `id=\"${keyAttrs.id}\"`;\n      }\n    }\n    if (keyAttrs.class) {\n      this.classNames = keyAttrs.class.split(/\\s+/);\n      if (!rawAttrs) {\n        const cls = `class=\"${this.classNames.join(' ')}\"`;\n        if (this.rawAttrs) {\n          this.rawAttrs += ` ${cls}`;\n        } else {\n          this.rawAttrs = cls;\n        }\n      }\n    }\n  }\n  /**\n   * Remove current element\n   */\n  remove() {\n    if (this.parentNode) {\n      const children = this.parentNode.childNodes;\n      this.parentNode.childNodes = children.filter(child => {\n        return this !== child;\n      });\n    }\n  }\n  /**\n   * Remove Child element from childNodes array\n   * @param {HTMLElement} node     node to remove\n   */\n  removeChild(node) {\n    this.childNodes = this.childNodes.filter(child => {\n      return child !== node;\n    });\n  }\n  /**\n   * Exchanges given child with new child\n   * @param {HTMLElement} oldNode     node to exchange\n   * @param {HTMLElement} newNode     new node\n   */\n  exchangeChild(oldNode, newNode) {\n    const children = this.childNodes;\n    this.childNodes = children.map(child => {\n      if (child === oldNode) {\n        return newNode;\n      }\n      return child;\n    });\n  }\n  get tagName() {\n    return this.rawTagName ? this.rawTagName.toUpperCase() : this.rawTagName;\n  }\n  /**\n   * Get escpaed (as-it) text value of current node and its children.\n   * @return {string} text content\n   */\n  get rawText() {\n    return this.childNodes.reduce((pre, cur) => {\n      return pre += cur.rawText;\n    }, '');\n  }\n  /**\n   * Get unescaped text value of current node and its children.\n   * @return {string} text content\n   */\n  get text() {\n    return decode(this.rawText);\n  }\n  /**\n   * Get structured Text (with '\\n' etc.)\n   * @return {string} structured text\n   */\n  get structuredText() {\n    let currentBlock = [];\n    const blocks = [currentBlock];\n    function dfs(node) {\n      if (node.nodeType === NodeType.ELEMENT_NODE) {\n        if (kBlockElements.get(node.rawTagName)) {\n          if (currentBlock.length > 0) {\n            blocks.push(currentBlock = []);\n          }\n          node.childNodes.forEach(dfs);\n          if (currentBlock.length > 0) {\n            blocks.push(currentBlock = []);\n          }\n        } else {\n          node.childNodes.forEach(dfs);\n        }\n      } else if (node.nodeType === NodeType.TEXT_NODE) {\n        if (node.isWhitespace) {\n          // Whitespace node, postponed output\n          currentBlock.prependWhitespace = true;\n        } else {\n          let text = node.text;\n          if (currentBlock.prependWhitespace) {\n            text = ` ${text}`;\n            currentBlock.prependWhitespace = false;\n          }\n          currentBlock.push(text);\n        }\n      }\n    }\n    dfs(this);\n    return blocks.map(block => {\n      // Normalize each line's whitespace\n      return block.join('').trim().replace(/\\s{2,}/g, ' ');\n    }).join('\\n').replace(/\\s+$/, ''); // trimRight;\n  }\n\n  toString() {\n    const tag = this.rawTagName;\n    if (tag) {\n      const is_void = /^(area|base|br|col|embed|hr|img|input|link|meta|param|source|track|wbr)$/i.test(tag);\n      const attrs = this.rawAttrs ? ` ${this.rawAttrs}` : '';\n      if (is_void) {\n        return `<${tag}${attrs}>`;\n      }\n      return `<${tag}${attrs}>${this.innerHTML}</${tag}>`;\n    }\n    return this.innerHTML;\n  }\n  get innerHTML() {\n    return this.childNodes.map(child => {\n      return child.toString();\n    }).join('');\n  }\n  set_content(content) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (content instanceof Node) {\n      content = [content];\n    } else if (typeof content == 'string') {\n      const r = parse(content, options);\n      content = r.childNodes.length ? r.childNodes : [new TextNode(content)];\n    }\n    this.childNodes = content;\n  }\n  get outerHTML() {\n    return this.toString();\n  }\n  /**\n   * Trim element from right (in block) after seeing pattern in a TextNode.\n   * @param  {RegExp} pattern pattern to find\n   * @return {HTMLElement}    reference to current node\n   */\n  trimRight(pattern) {\n    for (let i = 0; i < this.childNodes.length; i++) {\n      const childNode = this.childNodes[i];\n      if (childNode.nodeType === NodeType.ELEMENT_NODE) {\n        childNode.trimRight(pattern);\n      } else {\n        const index = childNode.rawText.search(pattern);\n        if (index > -1) {\n          childNode.rawText = childNode.rawText.substr(0, index);\n          // trim all following nodes.\n          this.childNodes.length = i + 1;\n        }\n      }\n    }\n    return this;\n  }\n  /**\n   * Get DOM structure\n   * @return {string} strucutre\n   */\n  get structure() {\n    const res = [];\n    let indention = 0;\n    function write(str) {\n      res.push('  '.repeat(indention) + str);\n    }\n    function dfs(node) {\n      const idStr = node.id ? `#${node.id}` : '';\n      const classStr = node.classNames.length ? `.${node.classNames.join('.')}` : '';\n      write(node.rawTagName + idStr + classStr);\n      indention++;\n      node.childNodes.forEach(childNode => {\n        if (childNode.nodeType === NodeType.ELEMENT_NODE) {\n          dfs(childNode);\n        } else if (childNode.nodeType === NodeType.TEXT_NODE) {\n          if (!childNode.isWhitespace) {\n            write('#text');\n          }\n        }\n      });\n      indention--;\n    }\n    dfs(this);\n    return res.join('\\n');\n  }\n  /**\n   * Remove whitespaces in this sub tree.\n   * @return {HTMLElement} pointer to this\n   */\n  removeWhitespace() {\n    let o = 0;\n    this.childNodes.forEach(node => {\n      if (node.nodeType === NodeType.TEXT_NODE) {\n        if (node.isWhitespace) {\n          return;\n        }\n        node.rawText = node.rawText.trim();\n      } else if (node.nodeType === NodeType.ELEMENT_NODE) {\n        node.removeWhitespace();\n      }\n      this.childNodes[o++] = node;\n    });\n    this.childNodes.length = o;\n    return this;\n  }\n  /**\n   * Query CSS selector to find matching nodes.\n   * @param  {string}         selector Simplified CSS selector\n   * @param  {Matcher}        selector A Matcher instance\n   * @return {HTMLElement[]}  matching elements\n   */\n  querySelectorAll(selector) {\n    let matcher;\n    if (selector instanceof Matcher) {\n      matcher = selector;\n      matcher.reset();\n    } else {\n      if (selector.includes(',')) {\n        const selectors = selector.split(',');\n        return Array.from(selectors.reduce((pre, cur) => {\n          const result = this.querySelectorAll(cur.trim());\n          return result.reduce((p, c) => {\n            return p.add(c);\n          }, pre);\n        }, new Set()));\n      }\n      matcher = new Matcher(selector);\n    }\n    const stack = [];\n    return this.childNodes.reduce((res, cur) => {\n      stack.push([cur, 0, false]);\n      while (stack.length) {\n        const state = arr_back(stack); // get last element\n        const el = state[0];\n        if (state[1] === 0) {\n          // Seen for first time.\n          if (el.nodeType !== NodeType.ELEMENT_NODE) {\n            stack.pop();\n            continue;\n          }\n          const html_el = el;\n          state[2] = matcher.advance(html_el);\n          if (state[2]) {\n            if (matcher.matched) {\n              res.push(html_el);\n              res.push(...html_el.querySelectorAll(selector));\n              // no need to go further.\n              matcher.rewind();\n              stack.pop();\n              continue;\n            }\n          }\n        }\n        if (state[1] < el.childNodes.length) {\n          stack.push([el.childNodes[state[1]++], 0, false]);\n        } else {\n          if (state[2]) {\n            matcher.rewind();\n          }\n          stack.pop();\n        }\n      }\n      return res;\n    }, []);\n  }\n  /**\n   * Query CSS Selector to find matching node.\n   * @param  {string}         selector Simplified CSS selector\n   * @param  {Matcher}        selector A Matcher instance\n   * @return {HTMLElement}    matching node\n   */\n  querySelector(selector) {\n    let matcher;\n    if (selector instanceof Matcher) {\n      matcher = selector;\n      matcher.reset();\n    } else {\n      matcher = new Matcher(selector);\n    }\n    const stack = [];\n    for (const node of this.childNodes) {\n      stack.push([node, 0, false]);\n      while (stack.length) {\n        const state = arr_back(stack);\n        const el = state[0];\n        if (state[1] === 0) {\n          // Seen for first time.\n          if (el.nodeType !== NodeType.ELEMENT_NODE) {\n            stack.pop();\n            continue;\n          }\n          state[2] = matcher.advance(el);\n          if (state[2]) {\n            if (matcher.matched) {\n              return el;\n            }\n          }\n        }\n        if (state[1] < el.childNodes.length) {\n          stack.push([el.childNodes[state[1]++], 0, false]);\n        } else {\n          if (state[2]) {\n            matcher.rewind();\n          }\n          stack.pop();\n        }\n      }\n    }\n    return null;\n  }\n  /**\n   * Append a child node to childNodes\n   * @param  {Node} node node to append\n   * @return {Node}      node appended\n   */\n  appendChild(node) {\n    // node.parentNode = this;\n    this.childNodes.push(node);\n    if (node instanceof HTMLElement) {\n      node.parentNode = this;\n    }\n    return node;\n  }\n  /**\n   * Get first child node\n   * @return {Node} first child node\n   */\n  get firstChild() {\n    return this.childNodes[0];\n  }\n  /**\n   * Get last child node\n   * @return {Node} last child node\n   */\n  get lastChild() {\n    return arr_back(this.childNodes);\n  }\n  /**\n   * Get attributes\n   * @return {Object} parsed and unescaped attributes\n   */\n  get attributes() {\n    if (this._attrs) {\n      return this._attrs;\n    }\n    this._attrs = {};\n    const attrs = this.rawAttributes;\n    for (const key in attrs) {\n      const val = attrs[key] || '';\n      this._attrs[key] = decode(val);\n    }\n    return this._attrs;\n  }\n  /**\n   * Get escaped (as-it) attributes\n   * @return {Object} parsed attributes\n   */\n  get rawAttributes() {\n    if (this._rawAttrs) {\n      return this._rawAttrs;\n    }\n    const attrs = {};\n    if (this.rawAttrs) {\n      const re = /\\b([a-z][a-z0-9-]*)(?:\\s*=\\s*(?:\"([^\"]*)\"|'([^']*)'|(\\S+)))?/ig;\n      let match;\n      while (match = re.exec(this.rawAttrs)) {\n        attrs[match[1]] = match[2] || match[3] || match[4] || null;\n      }\n    }\n    this._rawAttrs = attrs;\n    return attrs;\n  }\n  removeAttribute(key) {\n    const attrs = this.rawAttributes;\n    delete attrs[key];\n    // Update this.attribute\n    if (this._attrs) {\n      delete this._attrs[key];\n    }\n    // Update rawString\n    this.rawAttrs = Object.keys(attrs).map(name => {\n      const val = JSON.stringify(attrs[name]);\n      if (val === undefined || val === 'null') {\n        return name;\n      }\n      return `${name}=${val}`;\n    }).join(' ');\n  }\n  hasAttribute(key) {\n    return key in this.attributes;\n  }\n  /**\n   * Get an attribute\n   * @return {string} value of the attribute\n   */\n  getAttribute(key) {\n    return this.attributes[key];\n  }\n  /**\n   * Set an attribute value to the HTMLElement\n   * @param {string} key The attribute name\n   * @param {string} value The value to set, or null / undefined to remove an attribute\n   */\n  setAttribute(key, value) {\n    if (arguments.length < 2) {\n      throw new Error('Failed to execute \\'setAttribute\\' on \\'Element\\'');\n    }\n    const attrs = this.rawAttributes;\n    attrs[key] = String(value);\n    if (this._attrs) {\n      this._attrs[key] = decode(attrs[key]);\n    }\n    // Update rawString\n    this.rawAttrs = Object.keys(attrs).map(name => {\n      const val = JSON.stringify(attrs[name]);\n      if (val === 'null' || val === '\"\"') {\n        return name;\n      }\n      return `${name}=${val}`;\n    }).join(' ');\n  }\n  /**\n   * Replace all the attributes of the HTMLElement by the provided attributes\n   * @param {Attributes} attributes the new attribute set\n   */\n  setAttributes(attributes) {\n    // Invalidate current this.attributes\n    if (this._attrs) {\n      delete this._attrs;\n    }\n    // Invalidate current this.rawAttributes\n    if (this._rawAttrs) {\n      delete this._rawAttrs;\n    }\n    // Update rawString\n    this.rawAttrs = Object.keys(attributes).map(name => {\n      const val = attributes[name];\n      if (val === 'null' || val === '\"\"') {\n        return name;\n      }\n      return `${name}=${JSON.stringify(String(val))}`;\n    }).join(' ');\n  }\n  insertAdjacentHTML(where, html) {\n    if (arguments.length < 2) {\n      throw new Error('2 arguments required');\n    }\n    const p = parse(html);\n    if (where === 'afterend') {\n      const idx = this.parentNode.childNodes.findIndex(child => {\n        return child === this;\n      });\n      this.parentNode.childNodes.splice(idx + 1, 0, ...p.childNodes);\n      p.childNodes.forEach(n => {\n        if (n instanceof HTMLElement) {\n          n.parentNode = this.parentNode;\n        }\n      });\n    } else if (where === 'afterbegin') {\n      this.childNodes.unshift(...p.childNodes);\n    } else if (where === 'beforeend') {\n      p.childNodes.forEach(n => {\n        this.appendChild(n);\n      });\n    } else if (where === 'beforebegin') {\n      const idx = this.parentNode.childNodes.findIndex(child => {\n        return child === this;\n      });\n      this.parentNode.childNodes.splice(idx, 0, ...p.childNodes);\n      p.childNodes.forEach(n => {\n        if (n instanceof HTMLElement) {\n          n.parentNode = this.parentNode;\n        }\n      });\n    } else {\n      throw new Error(`The value provided ('${where}') is not one of 'beforebegin', 'afterbegin', 'beforeend', or 'afterend'`);\n    }\n    // if (!where || html === undefined || html === null) {\n    // \treturn;\n    // }\n  }\n\n  get nextSibling() {\n    if (this.parentNode) {\n      const children = this.parentNode.childNodes;\n      let i = 0;\n      while (i < children.length) {\n        const child = children[i++];\n        if (this === child) {\n          return children[i] || null;\n        }\n      }\n      return null;\n    }\n  }\n  get nextElementSibling() {\n    if (this.parentNode) {\n      const children = this.parentNode.childNodes;\n      let i = 0;\n      let find = false;\n      while (i < children.length) {\n        const child = children[i++];\n        if (find) {\n          if (child instanceof HTMLElement) {\n            return child || null;\n          }\n        } else if (this === child) {\n          find = true;\n        }\n      }\n      return null;\n    }\n  }\n}\n// https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name\nconst kMarkupPattern = /<!--[^]*?(?=-->)-->|<(\\/?)([a-z][-.:0-9_a-z]*)\\s*([^>]*?)(\\/?)>/ig;\n// <(?<tag>[^\\s]*)(.*)>(.*)</\\k<tag>>\n// <([a-z][-.:0-9_a-z]*)\\s*\\/>\n// <(area|base|br|col|hr|img|input|link|meta|source)\\s*(.*)\\/?>\n// <(area|base|br|col|hr|img|input|link|meta|source)\\s*(.*)\\/?>|<(?<tag>[^\\s]*)(.*)>(.*)</\\k<tag>>\nconst kAttributePattern = /(^|\\s)(id|class)\\s*=\\s*(\"([^\"]+)\"|'([^']+)'|(\\S+))/ig;\nconst kSelfClosingElements = {\n  area: true,\n  AREA: true,\n  base: true,\n  BASE: true,\n  br: true,\n  BR: true,\n  col: true,\n  COL: true,\n  hr: true,\n  HR: true,\n  img: true,\n  IMG: true,\n  input: true,\n  INPUT: true,\n  link: true,\n  LINK: true,\n  meta: true,\n  META: true,\n  source: true,\n  SOURCE: true,\n  embed: true,\n  EMBED: true,\n  param: true,\n  PARAM: true,\n  track: true,\n  TRACK: true,\n  wbr: true,\n  WBR: true\n};\nconst kElementsClosedByOpening = {\n  li: {\n    li: true,\n    LI: true\n  },\n  LI: {\n    li: true,\n    LI: true\n  },\n  p: {\n    p: true,\n    div: true,\n    P: true,\n    DIV: true\n  },\n  P: {\n    p: true,\n    div: true,\n    P: true,\n    DIV: true\n  },\n  b: {\n    div: true,\n    DIV: true\n  },\n  B: {\n    div: true,\n    DIV: true\n  },\n  td: {\n    td: true,\n    th: true,\n    TD: true,\n    TH: true\n  },\n  TD: {\n    td: true,\n    th: true,\n    TD: true,\n    TH: true\n  },\n  th: {\n    td: true,\n    th: true,\n    TD: true,\n    TH: true\n  },\n  TH: {\n    td: true,\n    th: true,\n    TD: true,\n    TH: true\n  },\n  h1: {\n    h1: true,\n    H1: true\n  },\n  H1: {\n    h1: true,\n    H1: true\n  },\n  h2: {\n    h2: true,\n    H2: true\n  },\n  H2: {\n    h2: true,\n    H2: true\n  },\n  h3: {\n    h3: true,\n    H3: true\n  },\n  H3: {\n    h3: true,\n    H3: true\n  },\n  h4: {\n    h4: true,\n    H4: true\n  },\n  H4: {\n    h4: true,\n    H4: true\n  },\n  h5: {\n    h5: true,\n    H5: true\n  },\n  H5: {\n    h5: true,\n    H5: true\n  },\n  h6: {\n    h6: true,\n    H6: true\n  },\n  H6: {\n    h6: true,\n    H6: true\n  }\n};\nconst kElementsClosedByClosing = {\n  li: {\n    ul: true,\n    ol: true,\n    UL: true,\n    OL: true\n  },\n  LI: {\n    ul: true,\n    ol: true,\n    UL: true,\n    OL: true\n  },\n  a: {\n    div: true,\n    DIV: true\n  },\n  A: {\n    div: true,\n    DIV: true\n  },\n  b: {\n    div: true,\n    DIV: true\n  },\n  B: {\n    div: true,\n    DIV: true\n  },\n  i: {\n    div: true,\n    DIV: true\n  },\n  I: {\n    div: true,\n    DIV: true\n  },\n  p: {\n    div: true,\n    DIV: true\n  },\n  P: {\n    div: true,\n    DIV: true\n  },\n  td: {\n    tr: true,\n    table: true,\n    TR: true,\n    TABLE: true\n  },\n  TD: {\n    tr: true,\n    table: true,\n    TR: true,\n    TABLE: true\n  },\n  th: {\n    tr: true,\n    table: true,\n    TR: true,\n    TABLE: true\n  },\n  TH: {\n    tr: true,\n    table: true,\n    TR: true,\n    TABLE: true\n  }\n};\nconst frameflag = 'documentfragmentcontainer';\nexport function parse(data) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    lowerCaseTagName: false,\n    comment: false\n  };\n  const elements = options.blockTextElements || {\n    script: true,\n    noscript: true,\n    style: true,\n    pre: true\n  };\n  const element_names = Object.keys(elements);\n  const kBlockTextElements = element_names.map(it => {\n    return new RegExp(it, 'i');\n  });\n  const kIgnoreElements = element_names.filter(it => {\n    return elements[it];\n  }).map(it => {\n    return new RegExp(it, 'i');\n  });\n  function element_should_be_ignore(tag) {\n    return kIgnoreElements.some(it => {\n      return it.test(tag);\n    });\n  }\n  function is_block_text_element(tag) {\n    return kBlockTextElements.some(it => {\n      return it.test(tag);\n    });\n  }\n  const root = new HTMLElement(null, {});\n  let currentParent = root;\n  const stack = [root];\n  let lastTextPos = -1;\n  let match;\n  // https://github.com/taoqf/node-html-parser/issues/38\n  data = `<${frameflag}>${data}</${frameflag}>`;\n  while (match = kMarkupPattern.exec(data)) {\n    if (lastTextPos > -1) {\n      if (lastTextPos + match[0].length < kMarkupPattern.lastIndex) {\n        // if has content\n        const text = data.substring(lastTextPos, kMarkupPattern.lastIndex - match[0].length);\n        currentParent.appendChild(new TextNode(text));\n      }\n    }\n    lastTextPos = kMarkupPattern.lastIndex;\n    if (match[2] === frameflag) {\n      continue;\n    }\n    if (match[0][1] === '!') {\n      // this is a comment\n      if (options.comment) {\n        // Only keep what is in between <!-- and -->\n        const text = data.substring(lastTextPos - 3, lastTextPos - match[0].length + 4);\n        currentParent.appendChild(new CommentNode(text));\n      }\n      continue;\n    }\n    if (options.lowerCaseTagName) {\n      match[2] = match[2].toLowerCase();\n    }\n    if (!match[1]) {\n      // not </ tags\n      const attrs = {};\n      for (let attMatch; attMatch = kAttributePattern.exec(match[3]);) {\n        attrs[attMatch[2].toLowerCase()] = attMatch[4] || attMatch[5] || attMatch[6];\n      }\n      const tagName = currentParent.rawTagName;\n      if (!match[4] && kElementsClosedByOpening[tagName]) {\n        if (kElementsClosedByOpening[tagName][match[2]]) {\n          stack.pop();\n          currentParent = arr_back(stack);\n        }\n      }\n      // ignore container tag we add above\n      // https://github.com/taoqf/node-html-parser/issues/38\n      currentParent = currentParent.appendChild(new HTMLElement(match[2], attrs, match[3]));\n      stack.push(currentParent);\n      if (is_block_text_element(match[2])) {\n        // a little test to find next </script> or </style> ...\n        const closeMarkup = `</${match[2]}>`;\n        const index = (() => {\n          if (options.lowerCaseTagName) {\n            return data.toLocaleLowerCase().indexOf(closeMarkup, kMarkupPattern.lastIndex);\n          }\n          return data.indexOf(closeMarkup, kMarkupPattern.lastIndex);\n        })();\n        if (element_should_be_ignore(match[2])) {\n          let text;\n          if (index === -1) {\n            // there is no matching ending for the text element.\n            text = data.substr(kMarkupPattern.lastIndex);\n          } else {\n            text = data.substring(kMarkupPattern.lastIndex, index);\n          }\n          if (text.length > 0) {\n            currentParent.appendChild(new TextNode(text));\n          }\n        }\n        if (index === -1) {\n          lastTextPos = kMarkupPattern.lastIndex = data.length + 1;\n        } else {\n          lastTextPos = kMarkupPattern.lastIndex = index + closeMarkup.length;\n          match[1] = 'true';\n        }\n      }\n    }\n    if (match[1] || match[4] || kSelfClosingElements[match[2]]) {\n      // </ or /> or <br> etc.\n      while (true) {\n        if (currentParent.rawTagName === match[2]) {\n          stack.pop();\n          currentParent = arr_back(stack);\n          break;\n        } else {\n          const tagName = currentParent.tagName;\n          // Trying to close current tag, and move on\n          if (kElementsClosedByClosing[tagName]) {\n            if (kElementsClosedByClosing[tagName][match[2]]) {\n              stack.pop();\n              currentParent = arr_back(stack);\n              continue;\n            }\n          }\n          // Use aggressive strategy to handle unmatching markups.\n          break;\n        }\n      }\n    }\n  }\n  const valid = Boolean(stack.length === 1);\n  if (!options.noFix) {\n    const response = root;\n    response.valid = valid;\n    while (stack.length > 1) {\n      // Handle each error elements.\n      const last = stack.pop();\n      const oneBefore = arr_back(stack);\n      if (last.parentNode && last.parentNode.parentNode) {\n        if (last.parentNode === oneBefore && last.tagName === oneBefore.tagName) {\n          // Pair error case <h3> <h3> handle : Fixes to <h3> </h3>\n          oneBefore.removeChild(last);\n          last.childNodes.forEach(child => {\n            oneBefore.parentNode.appendChild(child);\n          });\n          stack.pop();\n        } else {\n          // Single error  <div> <h3> </div> handle: Just removes <h3>\n          oneBefore.removeChild(last);\n          last.childNodes.forEach(child => {\n            oneBefore.appendChild(child);\n          });\n        }\n      } else {\n        // If it's final element just skip.\n      }\n    }\n    response.childNodes.forEach(node => {\n      if (node instanceof HTMLElement) {\n        node.parentNode = null;\n      }\n    });\n    return response;\n  }\n  const response = new TextNode(data);\n  response.valid = valid;\n  return response;\n}","map":{"version":3,"names":["decode","Node","NodeType","TextNode","Matcher","arr_back","CommentNode","kBlockElements","Map","set","HTMLElement","constructor","tagName","keyAttrs","rawAttrs","arguments","length","undefined","parentNode","classNames","nodeType","ELEMENT_NODE","rawTagName","childNodes","id","class","split","cls","join","remove","children","filter","child","removeChild","node","exchangeChild","oldNode","newNode","map","toUpperCase","rawText","reduce","pre","cur","text","structuredText","currentBlock","blocks","dfs","get","push","forEach","TEXT_NODE","isWhitespace","prependWhitespace","block","trim","replace","toString","tag","is_void","test","attrs","innerHTML","set_content","content","options","r","parse","outerHTML","trimRight","pattern","i","childNode","index","search","substr","structure","res","indention","write","str","repeat","idStr","classStr","removeWhitespace","o","querySelectorAll","selector","matcher","reset","includes","selectors","Array","from","result","p","c","add","Set","stack","state","el","pop","html_el","advance","matched","rewind","querySelector","appendChild","firstChild","lastChild","attributes","_attrs","rawAttributes","key","val","_rawAttrs","re","match","exec","removeAttribute","Object","keys","name","JSON","stringify","hasAttribute","getAttribute","setAttribute","value","Error","String","setAttributes","insertAdjacentHTML","where","html","idx","findIndex","splice","n","unshift","nextSibling","nextElementSibling","find","kMarkupPattern","kAttributePattern","kSelfClosingElements","area","AREA","base","BASE","br","BR","col","COL","hr","HR","img","IMG","input","INPUT","link","LINK","meta","META","source","SOURCE","embed","EMBED","param","PARAM","track","TRACK","wbr","WBR","kElementsClosedByOpening","li","LI","div","P","DIV","b","B","td","th","TD","TH","h1","H1","h2","H2","h3","H3","h4","H4","h5","H5","h6","H6","kElementsClosedByClosing","ul","ol","UL","OL","a","A","I","tr","table","TR","TABLE","frameflag","data","lowerCaseTagName","comment","elements","blockTextElements","script","noscript","style","element_names","kBlockTextElements","it","RegExp","kIgnoreElements","element_should_be_ignore","some","is_block_text_element","root","currentParent","lastTextPos","lastIndex","substring","toLowerCase","attMatch","closeMarkup","toLocaleLowerCase","indexOf","valid","Boolean","noFix","response","last","oneBefore"],"sources":["D:/CMK/2023_5/WebsiteBuiderTask/modify/grapesJs/node_modules/node-html-parser/dist/esm/nodes/html.js"],"sourcesContent":["import { decode } from 'he';\nimport Node from './node';\nimport NodeType from './type';\nimport TextNode from './text';\nimport Matcher from '../matcher';\nimport arr_back from '../back';\nimport CommentNode from './comment';\nconst kBlockElements = new Map();\nkBlockElements.set('DIV', true);\nkBlockElements.set('div', true);\nkBlockElements.set('P', true);\nkBlockElements.set('p', true);\n// ul: true,\n// ol: true,\nkBlockElements.set('LI', true);\nkBlockElements.set('li', true);\n// table: true,\n// tr: true,\nkBlockElements.set('TD', true);\nkBlockElements.set('td', true);\nkBlockElements.set('SECTION', true);\nkBlockElements.set('section', true);\nkBlockElements.set('BR', true);\nkBlockElements.set('br', true);\n/**\n * HTMLElement, which contains a set of children.\n *\n * Note: this is a minimalist implementation, no complete tree\n *   structure provided (no parentNode, nextSibling,\n *   previousSibling etc).\n * @class HTMLElement\n * @extends {Node}\n */\nexport default class HTMLElement extends Node {\n    /**\n     * Creates an instance of HTMLElement.\n     * @param keyAttrs\tid and class attribute\n     * @param [rawAttrs]\tattributes in string\n     *\n     * @memberof HTMLElement\n     */\n    constructor(tagName, keyAttrs, rawAttrs = '', parentNode = null) {\n        super();\n        this.rawAttrs = rawAttrs;\n        this.parentNode = parentNode;\n        this.classNames = [];\n        /**\n         * Node Type declaration.\n         */\n        this.nodeType = NodeType.ELEMENT_NODE;\n        this.rawTagName = tagName;\n        this.rawAttrs = rawAttrs || '';\n        this.parentNode = parentNode || null;\n        this.childNodes = [];\n        if (keyAttrs.id) {\n            this.id = keyAttrs.id;\n            if (!rawAttrs) {\n                this.rawAttrs = `id=\"${keyAttrs.id}\"`;\n            }\n        }\n        if (keyAttrs.class) {\n            this.classNames = keyAttrs.class.split(/\\s+/);\n            if (!rawAttrs) {\n                const cls = `class=\"${this.classNames.join(' ')}\"`;\n                if (this.rawAttrs) {\n                    this.rawAttrs += ` ${cls}`;\n                }\n                else {\n                    this.rawAttrs = cls;\n                }\n            }\n        }\n    }\n    /**\n     * Remove current element\n     */\n    remove() {\n        if (this.parentNode) {\n            const children = this.parentNode.childNodes;\n            this.parentNode.childNodes = children.filter((child) => {\n                return this !== child;\n            });\n        }\n    }\n    /**\n     * Remove Child element from childNodes array\n     * @param {HTMLElement} node     node to remove\n     */\n    removeChild(node) {\n        this.childNodes = this.childNodes.filter((child) => {\n            return (child !== node);\n        });\n    }\n    /**\n     * Exchanges given child with new child\n     * @param {HTMLElement} oldNode     node to exchange\n     * @param {HTMLElement} newNode     new node\n     */\n    exchangeChild(oldNode, newNode) {\n        const children = this.childNodes;\n        this.childNodes = children.map((child) => {\n            if (child === oldNode) {\n                return newNode;\n            }\n            return child;\n        });\n    }\n    get tagName() {\n        return this.rawTagName ? this.rawTagName.toUpperCase() : this.rawTagName;\n    }\n    /**\n     * Get escpaed (as-it) text value of current node and its children.\n     * @return {string} text content\n     */\n    get rawText() {\n        return this.childNodes.reduce((pre, cur) => {\n            return (pre += cur.rawText);\n        }, '');\n    }\n    /**\n     * Get unescaped text value of current node and its children.\n     * @return {string} text content\n     */\n    get text() {\n        return decode(this.rawText);\n    }\n    /**\n     * Get structured Text (with '\\n' etc.)\n     * @return {string} structured text\n     */\n    get structuredText() {\n        let currentBlock = [];\n        const blocks = [currentBlock];\n        function dfs(node) {\n            if (node.nodeType === NodeType.ELEMENT_NODE) {\n                if (kBlockElements.get(node.rawTagName)) {\n                    if (currentBlock.length > 0) {\n                        blocks.push(currentBlock = []);\n                    }\n                    node.childNodes.forEach(dfs);\n                    if (currentBlock.length > 0) {\n                        blocks.push(currentBlock = []);\n                    }\n                }\n                else {\n                    node.childNodes.forEach(dfs);\n                }\n            }\n            else if (node.nodeType === NodeType.TEXT_NODE) {\n                if (node.isWhitespace) {\n                    // Whitespace node, postponed output\n                    currentBlock.prependWhitespace = true;\n                }\n                else {\n                    let text = node.text;\n                    if (currentBlock.prependWhitespace) {\n                        text = ` ${text}`;\n                        currentBlock.prependWhitespace = false;\n                    }\n                    currentBlock.push(text);\n                }\n            }\n        }\n        dfs(this);\n        return blocks.map((block) => {\n            // Normalize each line's whitespace\n            return block.join('').trim().replace(/\\s{2,}/g, ' ');\n        })\n            .join('\\n').replace(/\\s+$/, ''); // trimRight;\n    }\n    toString() {\n        const tag = this.rawTagName;\n        if (tag) {\n            const is_void = /^(area|base|br|col|embed|hr|img|input|link|meta|param|source|track|wbr)$/i.test(tag);\n            const attrs = this.rawAttrs ? ` ${this.rawAttrs}` : '';\n            if (is_void) {\n                return `<${tag}${attrs}>`;\n            }\n            return `<${tag}${attrs}>${this.innerHTML}</${tag}>`;\n        }\n        return this.innerHTML;\n    }\n    get innerHTML() {\n        return this.childNodes.map((child) => {\n            return child.toString();\n        }).join('');\n    }\n    set_content(content, options = {}) {\n        if (content instanceof Node) {\n            content = [content];\n        }\n        else if (typeof content == 'string') {\n            const r = parse(content, options);\n            content = r.childNodes.length ? r.childNodes : [new TextNode(content)];\n        }\n        this.childNodes = content;\n    }\n    get outerHTML() {\n        return this.toString();\n    }\n    /**\n     * Trim element from right (in block) after seeing pattern in a TextNode.\n     * @param  {RegExp} pattern pattern to find\n     * @return {HTMLElement}    reference to current node\n     */\n    trimRight(pattern) {\n        for (let i = 0; i < this.childNodes.length; i++) {\n            const childNode = this.childNodes[i];\n            if (childNode.nodeType === NodeType.ELEMENT_NODE) {\n                childNode.trimRight(pattern);\n            }\n            else {\n                const index = childNode.rawText.search(pattern);\n                if (index > -1) {\n                    childNode.rawText = childNode.rawText.substr(0, index);\n                    // trim all following nodes.\n                    this.childNodes.length = i + 1;\n                }\n            }\n        }\n        return this;\n    }\n    /**\n     * Get DOM structure\n     * @return {string} strucutre\n     */\n    get structure() {\n        const res = [];\n        let indention = 0;\n        function write(str) {\n            res.push('  '.repeat(indention) + str);\n        }\n        function dfs(node) {\n            const idStr = node.id ? (`#${node.id}`) : '';\n            const classStr = node.classNames.length ? (`.${node.classNames.join('.')}`) : '';\n            write(node.rawTagName + idStr + classStr);\n            indention++;\n            node.childNodes.forEach((childNode) => {\n                if (childNode.nodeType === NodeType.ELEMENT_NODE) {\n                    dfs(childNode);\n                }\n                else if (childNode.nodeType === NodeType.TEXT_NODE) {\n                    if (!childNode.isWhitespace) {\n                        write('#text');\n                    }\n                }\n            });\n            indention--;\n        }\n        dfs(this);\n        return res.join('\\n');\n    }\n    /**\n     * Remove whitespaces in this sub tree.\n     * @return {HTMLElement} pointer to this\n     */\n    removeWhitespace() {\n        let o = 0;\n        this.childNodes.forEach((node) => {\n            if (node.nodeType === NodeType.TEXT_NODE) {\n                if (node.isWhitespace) {\n                    return;\n                }\n                node.rawText = node.rawText.trim();\n            }\n            else if (node.nodeType === NodeType.ELEMENT_NODE) {\n                node.removeWhitespace();\n            }\n            this.childNodes[o++] = node;\n        });\n        this.childNodes.length = o;\n        return this;\n    }\n    /**\n     * Query CSS selector to find matching nodes.\n     * @param  {string}         selector Simplified CSS selector\n     * @param  {Matcher}        selector A Matcher instance\n     * @return {HTMLElement[]}  matching elements\n     */\n    querySelectorAll(selector) {\n        let matcher;\n        if (selector instanceof Matcher) {\n            matcher = selector;\n            matcher.reset();\n        }\n        else {\n            if (selector.includes(',')) {\n                const selectors = selector.split(',');\n                return Array.from(selectors.reduce((pre, cur) => {\n                    const result = this.querySelectorAll(cur.trim());\n                    return result.reduce((p, c) => {\n                        return p.add(c);\n                    }, pre);\n                }, new Set()));\n            }\n            matcher = new Matcher(selector);\n        }\n        const stack = [];\n        return this.childNodes.reduce((res, cur) => {\n            stack.push([cur, 0, false]);\n            while (stack.length) {\n                const state = arr_back(stack); // get last element\n                const el = state[0];\n                if (state[1] === 0) {\n                    // Seen for first time.\n                    if (el.nodeType !== NodeType.ELEMENT_NODE) {\n                        stack.pop();\n                        continue;\n                    }\n                    const html_el = el;\n                    state[2] = matcher.advance(html_el);\n                    if (state[2]) {\n                        if (matcher.matched) {\n                            res.push(html_el);\n                            res.push(...(html_el.querySelectorAll(selector)));\n                            // no need to go further.\n                            matcher.rewind();\n                            stack.pop();\n                            continue;\n                        }\n                    }\n                }\n                if (state[1] < el.childNodes.length) {\n                    stack.push([el.childNodes[state[1]++], 0, false]);\n                }\n                else {\n                    if (state[2]) {\n                        matcher.rewind();\n                    }\n                    stack.pop();\n                }\n            }\n            return res;\n        }, []);\n    }\n    /**\n     * Query CSS Selector to find matching node.\n     * @param  {string}         selector Simplified CSS selector\n     * @param  {Matcher}        selector A Matcher instance\n     * @return {HTMLElement}    matching node\n     */\n    querySelector(selector) {\n        let matcher;\n        if (selector instanceof Matcher) {\n            matcher = selector;\n            matcher.reset();\n        }\n        else {\n            matcher = new Matcher(selector);\n        }\n        const stack = [];\n        for (const node of this.childNodes) {\n            stack.push([node, 0, false]);\n            while (stack.length) {\n                const state = arr_back(stack);\n                const el = state[0];\n                if (state[1] === 0) {\n                    // Seen for first time.\n                    if (el.nodeType !== NodeType.ELEMENT_NODE) {\n                        stack.pop();\n                        continue;\n                    }\n                    state[2] = matcher.advance(el);\n                    if (state[2]) {\n                        if (matcher.matched) {\n                            return el;\n                        }\n                    }\n                }\n                if (state[1] < el.childNodes.length) {\n                    stack.push([el.childNodes[state[1]++], 0, false]);\n                }\n                else {\n                    if (state[2]) {\n                        matcher.rewind();\n                    }\n                    stack.pop();\n                }\n            }\n        }\n        return null;\n    }\n    /**\n     * Append a child node to childNodes\n     * @param  {Node} node node to append\n     * @return {Node}      node appended\n     */\n    appendChild(node) {\n        // node.parentNode = this;\n        this.childNodes.push(node);\n        if (node instanceof HTMLElement) {\n            node.parentNode = this;\n        }\n        return node;\n    }\n    /**\n     * Get first child node\n     * @return {Node} first child node\n     */\n    get firstChild() {\n        return this.childNodes[0];\n    }\n    /**\n     * Get last child node\n     * @return {Node} last child node\n     */\n    get lastChild() {\n        return arr_back(this.childNodes);\n    }\n    /**\n     * Get attributes\n     * @return {Object} parsed and unescaped attributes\n     */\n    get attributes() {\n        if (this._attrs) {\n            return this._attrs;\n        }\n        this._attrs = {};\n        const attrs = this.rawAttributes;\n        for (const key in attrs) {\n            const val = attrs[key] || '';\n            this._attrs[key] = decode(val);\n        }\n        return this._attrs;\n    }\n    /**\n     * Get escaped (as-it) attributes\n     * @return {Object} parsed attributes\n     */\n    get rawAttributes() {\n        if (this._rawAttrs) {\n            return this._rawAttrs;\n        }\n        const attrs = {};\n        if (this.rawAttrs) {\n            const re = /\\b([a-z][a-z0-9-]*)(?:\\s*=\\s*(?:\"([^\"]*)\"|'([^']*)'|(\\S+)))?/ig;\n            let match;\n            while ((match = re.exec(this.rawAttrs))) {\n                attrs[match[1]] = match[2] || match[3] || match[4] || null;\n            }\n        }\n        this._rawAttrs = attrs;\n        return attrs;\n    }\n    removeAttribute(key) {\n        const attrs = this.rawAttributes;\n        delete attrs[key];\n        // Update this.attribute\n        if (this._attrs) {\n            delete this._attrs[key];\n        }\n        // Update rawString\n        this.rawAttrs = Object.keys(attrs).map((name) => {\n            const val = JSON.stringify(attrs[name]);\n            if (val === undefined || val === 'null') {\n                return name;\n            }\n            return `${name}=${val}`;\n        }).join(' ');\n    }\n    hasAttribute(key) {\n        return key in this.attributes;\n    }\n    /**\n     * Get an attribute\n     * @return {string} value of the attribute\n     */\n    getAttribute(key) {\n        return this.attributes[key];\n    }\n    /**\n     * Set an attribute value to the HTMLElement\n     * @param {string} key The attribute name\n     * @param {string} value The value to set, or null / undefined to remove an attribute\n     */\n    setAttribute(key, value) {\n        if (arguments.length < 2) {\n            throw new Error('Failed to execute \\'setAttribute\\' on \\'Element\\'');\n        }\n        const attrs = this.rawAttributes;\n        attrs[key] = String(value);\n        if (this._attrs) {\n            this._attrs[key] = decode(attrs[key]);\n        }\n        // Update rawString\n        this.rawAttrs = Object.keys(attrs).map((name) => {\n            const val = JSON.stringify(attrs[name]);\n            if (val === 'null' || val === '\"\"') {\n                return name;\n            }\n            return `${name}=${val}`;\n        }).join(' ');\n    }\n    /**\n     * Replace all the attributes of the HTMLElement by the provided attributes\n     * @param {Attributes} attributes the new attribute set\n     */\n    setAttributes(attributes) {\n        // Invalidate current this.attributes\n        if (this._attrs) {\n            delete this._attrs;\n        }\n        // Invalidate current this.rawAttributes\n        if (this._rawAttrs) {\n            delete this._rawAttrs;\n        }\n        // Update rawString\n        this.rawAttrs = Object.keys(attributes).map((name) => {\n            const val = attributes[name];\n            if (val === 'null' || val === '\"\"') {\n                return name;\n            }\n            return `${name}=${JSON.stringify(String(val))}`;\n        }).join(' ');\n    }\n    insertAdjacentHTML(where, html) {\n        if (arguments.length < 2) {\n            throw new Error('2 arguments required');\n        }\n        const p = parse(html);\n        if (where === 'afterend') {\n            const idx = this.parentNode.childNodes.findIndex((child) => {\n                return child === this;\n            });\n            this.parentNode.childNodes.splice(idx + 1, 0, ...p.childNodes);\n            p.childNodes.forEach((n) => {\n                if (n instanceof HTMLElement) {\n                    n.parentNode = this.parentNode;\n                }\n            });\n        }\n        else if (where === 'afterbegin') {\n            this.childNodes.unshift(...p.childNodes);\n        }\n        else if (where === 'beforeend') {\n            p.childNodes.forEach((n) => {\n                this.appendChild(n);\n            });\n        }\n        else if (where === 'beforebegin') {\n            const idx = this.parentNode.childNodes.findIndex((child) => {\n                return child === this;\n            });\n            this.parentNode.childNodes.splice(idx, 0, ...p.childNodes);\n            p.childNodes.forEach((n) => {\n                if (n instanceof HTMLElement) {\n                    n.parentNode = this.parentNode;\n                }\n            });\n        }\n        else {\n            throw new Error(`The value provided ('${where}') is not one of 'beforebegin', 'afterbegin', 'beforeend', or 'afterend'`);\n        }\n        // if (!where || html === undefined || html === null) {\n        // \treturn;\n        // }\n    }\n    get nextSibling() {\n        if (this.parentNode) {\n            const children = this.parentNode.childNodes;\n            let i = 0;\n            while (i < children.length) {\n                const child = children[i++];\n                if (this === child) {\n                    return children[i] || null;\n                }\n            }\n            return null;\n        }\n    }\n    get nextElementSibling() {\n        if (this.parentNode) {\n            const children = this.parentNode.childNodes;\n            let i = 0;\n            let find = false;\n            while (i < children.length) {\n                const child = children[i++];\n                if (find) {\n                    if (child instanceof HTMLElement) {\n                        return child || null;\n                    }\n                }\n                else if (this === child) {\n                    find = true;\n                }\n            }\n            return null;\n        }\n    }\n}\n// https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name\nconst kMarkupPattern = /<!--[^]*?(?=-->)-->|<(\\/?)([a-z][-.:0-9_a-z]*)\\s*([^>]*?)(\\/?)>/ig;\n// <(?<tag>[^\\s]*)(.*)>(.*)</\\k<tag>>\n// <([a-z][-.:0-9_a-z]*)\\s*\\/>\n// <(area|base|br|col|hr|img|input|link|meta|source)\\s*(.*)\\/?>\n// <(area|base|br|col|hr|img|input|link|meta|source)\\s*(.*)\\/?>|<(?<tag>[^\\s]*)(.*)>(.*)</\\k<tag>>\nconst kAttributePattern = /(^|\\s)(id|class)\\s*=\\s*(\"([^\"]+)\"|'([^']+)'|(\\S+))/ig;\nconst kSelfClosingElements = {\n    area: true,\n    AREA: true,\n    base: true,\n    BASE: true,\n    br: true,\n    BR: true,\n    col: true,\n    COL: true,\n    hr: true,\n    HR: true,\n    img: true,\n    IMG: true,\n    input: true,\n    INPUT: true,\n    link: true,\n    LINK: true,\n    meta: true,\n    META: true,\n    source: true,\n    SOURCE: true,\n    embed: true,\n    EMBED: true,\n    param: true,\n    PARAM: true,\n    track: true,\n    TRACK: true,\n    wbr: true,\n    WBR: true\n};\nconst kElementsClosedByOpening = {\n    li: { li: true, LI: true },\n    LI: { li: true, LI: true },\n    p: { p: true, div: true, P: true, DIV: true },\n    P: { p: true, div: true, P: true, DIV: true },\n    b: { div: true, DIV: true },\n    B: { div: true, DIV: true },\n    td: { td: true, th: true, TD: true, TH: true },\n    TD: { td: true, th: true, TD: true, TH: true },\n    th: { td: true, th: true, TD: true, TH: true },\n    TH: { td: true, th: true, TD: true, TH: true },\n    h1: { h1: true, H1: true },\n    H1: { h1: true, H1: true },\n    h2: { h2: true, H2: true },\n    H2: { h2: true, H2: true },\n    h3: { h3: true, H3: true },\n    H3: { h3: true, H3: true },\n    h4: { h4: true, H4: true },\n    H4: { h4: true, H4: true },\n    h5: { h5: true, H5: true },\n    H5: { h5: true, H5: true },\n    h6: { h6: true, H6: true },\n    H6: { h6: true, H6: true }\n};\nconst kElementsClosedByClosing = {\n    li: { ul: true, ol: true, UL: true, OL: true },\n    LI: { ul: true, ol: true, UL: true, OL: true },\n    a: { div: true, DIV: true },\n    A: { div: true, DIV: true },\n    b: { div: true, DIV: true },\n    B: { div: true, DIV: true },\n    i: { div: true, DIV: true },\n    I: { div: true, DIV: true },\n    p: { div: true, DIV: true },\n    P: { div: true, DIV: true },\n    td: { tr: true, table: true, TR: true, TABLE: true },\n    TD: { tr: true, table: true, TR: true, TABLE: true },\n    th: { tr: true, table: true, TR: true, TABLE: true },\n    TH: { tr: true, table: true, TR: true, TABLE: true }\n};\nconst frameflag = 'documentfragmentcontainer';\nexport function parse(data, options = { lowerCaseTagName: false, comment: false }) {\n    const elements = options.blockTextElements || {\n        script: true,\n        noscript: true,\n        style: true,\n        pre: true\n    };\n    const element_names = Object.keys(elements);\n    const kBlockTextElements = element_names.map((it) => {\n        return new RegExp(it, 'i');\n    });\n    const kIgnoreElements = element_names.filter((it) => {\n        return elements[it];\n    }).map((it) => {\n        return new RegExp(it, 'i');\n    });\n    function element_should_be_ignore(tag) {\n        return kIgnoreElements.some((it) => {\n            return it.test(tag);\n        });\n    }\n    function is_block_text_element(tag) {\n        return kBlockTextElements.some((it) => {\n            return it.test(tag);\n        });\n    }\n    const root = new HTMLElement(null, {});\n    let currentParent = root;\n    const stack = [root];\n    let lastTextPos = -1;\n    let match;\n    // https://github.com/taoqf/node-html-parser/issues/38\n    data = `<${frameflag}>${data}</${frameflag}>`;\n    while ((match = kMarkupPattern.exec(data))) {\n        if (lastTextPos > -1) {\n            if (lastTextPos + match[0].length < kMarkupPattern.lastIndex) {\n                // if has content\n                const text = data.substring(lastTextPos, kMarkupPattern.lastIndex - match[0].length);\n                currentParent.appendChild(new TextNode(text));\n            }\n        }\n        lastTextPos = kMarkupPattern.lastIndex;\n        if (match[2] === frameflag) {\n            continue;\n        }\n        if (match[0][1] === '!') {\n            // this is a comment\n            if (options.comment) {\n                // Only keep what is in between <!-- and -->\n                const text = data.substring(lastTextPos - 3, lastTextPos - match[0].length + 4);\n                currentParent.appendChild(new CommentNode(text));\n            }\n            continue;\n        }\n        if (options.lowerCaseTagName) {\n            match[2] = match[2].toLowerCase();\n        }\n        if (!match[1]) {\n            // not </ tags\n            const attrs = {};\n            for (let attMatch; (attMatch = kAttributePattern.exec(match[3]));) {\n                attrs[attMatch[2].toLowerCase()] = attMatch[4] || attMatch[5] || attMatch[6];\n            }\n            const tagName = currentParent.rawTagName;\n            if (!match[4] && kElementsClosedByOpening[tagName]) {\n                if (kElementsClosedByOpening[tagName][match[2]]) {\n                    stack.pop();\n                    currentParent = arr_back(stack);\n                }\n            }\n            // ignore container tag we add above\n            // https://github.com/taoqf/node-html-parser/issues/38\n            currentParent = currentParent.appendChild(new HTMLElement(match[2], attrs, match[3]));\n            stack.push(currentParent);\n            if (is_block_text_element(match[2])) {\n                // a little test to find next </script> or </style> ...\n                const closeMarkup = `</${match[2]}>`;\n                const index = (() => {\n                    if (options.lowerCaseTagName) {\n                        return data.toLocaleLowerCase().indexOf(closeMarkup, kMarkupPattern.lastIndex);\n                    }\n                    return data.indexOf(closeMarkup, kMarkupPattern.lastIndex);\n                })();\n                if (element_should_be_ignore(match[2])) {\n                    let text;\n                    if (index === -1) {\n                        // there is no matching ending for the text element.\n                        text = data.substr(kMarkupPattern.lastIndex);\n                    }\n                    else {\n                        text = data.substring(kMarkupPattern.lastIndex, index);\n                    }\n                    if (text.length > 0) {\n                        currentParent.appendChild(new TextNode(text));\n                    }\n                }\n                if (index === -1) {\n                    lastTextPos = kMarkupPattern.lastIndex = data.length + 1;\n                }\n                else {\n                    lastTextPos = kMarkupPattern.lastIndex = index + closeMarkup.length;\n                    match[1] = 'true';\n                }\n            }\n        }\n        if (match[1] || match[4] || kSelfClosingElements[match[2]]) {\n            // </ or /> or <br> etc.\n            while (true) {\n                if (currentParent.rawTagName === match[2]) {\n                    stack.pop();\n                    currentParent = arr_back(stack);\n                    break;\n                }\n                else {\n                    const tagName = currentParent.tagName;\n                    // Trying to close current tag, and move on\n                    if (kElementsClosedByClosing[tagName]) {\n                        if (kElementsClosedByClosing[tagName][match[2]]) {\n                            stack.pop();\n                            currentParent = arr_back(stack);\n                            continue;\n                        }\n                    }\n                    // Use aggressive strategy to handle unmatching markups.\n                    break;\n                }\n            }\n        }\n    }\n    const valid = Boolean(stack.length === 1);\n    if (!options.noFix) {\n        const response = root;\n        response.valid = valid;\n        while (stack.length > 1) {\n            // Handle each error elements.\n            const last = stack.pop();\n            const oneBefore = arr_back(stack);\n            if (last.parentNode && last.parentNode.parentNode) {\n                if (last.parentNode === oneBefore && last.tagName === oneBefore.tagName) {\n                    // Pair error case <h3> <h3> handle : Fixes to <h3> </h3>\n                    oneBefore.removeChild(last);\n                    last.childNodes.forEach((child) => {\n                        oneBefore.parentNode.appendChild(child);\n                    });\n                    stack.pop();\n                }\n                else {\n                    // Single error  <div> <h3> </div> handle: Just removes <h3>\n                    oneBefore.removeChild(last);\n                    last.childNodes.forEach((child) => {\n                        oneBefore.appendChild(child);\n                    });\n                }\n            }\n            else {\n                // If it's final element just skip.\n            }\n        }\n        response.childNodes.forEach((node) => {\n            if (node instanceof HTMLElement) {\n                node.parentNode = null;\n            }\n        });\n        return response;\n    }\n    const response = new TextNode(data);\n    response.valid = valid;\n    return response;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}