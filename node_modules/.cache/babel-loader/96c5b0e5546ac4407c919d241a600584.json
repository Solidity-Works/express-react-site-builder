{"ast":null,"code":"import _createForOfIteratorHelper from \"D:\\\\Dapp\\\\Clients\\\\site-builder\\\\grapesJs\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";\nimport _toConsumableArray from \"D:\\\\Dapp\\\\Clients\\\\site-builder\\\\grapesJs\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"D:\\\\Dapp\\\\Clients\\\\site-builder\\\\grapesJs\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:\\\\Dapp\\\\Clients\\\\site-builder\\\\grapesJs\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _inherits from \"D:\\\\Dapp\\\\Clients\\\\site-builder\\\\grapesJs\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport _createSuper from \"D:\\\\Dapp\\\\Clients\\\\site-builder\\\\grapesJs\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createSuper\";\nimport { decode } from 'he';\nimport Node from './node';\nimport NodeType from './type';\nimport TextNode from './text';\nimport Matcher from '../matcher';\nimport arr_back from '../back';\nimport CommentNode from './comment';\nvar kBlockElements = new Map();\nkBlockElements.set('DIV', true);\nkBlockElements.set('div', true);\nkBlockElements.set('P', true);\nkBlockElements.set('p', true);\n// ul: true,\n// ol: true,\nkBlockElements.set('LI', true);\nkBlockElements.set('li', true);\n// table: true,\n// tr: true,\nkBlockElements.set('TD', true);\nkBlockElements.set('td', true);\nkBlockElements.set('SECTION', true);\nkBlockElements.set('section', true);\nkBlockElements.set('BR', true);\nkBlockElements.set('br', true);\n/**\n * HTMLElement, which contains a set of children.\n *\n * Note: this is a minimalist implementation, no complete tree\n *   structure provided (no parentNode, nextSibling,\n *   previousSibling etc).\n * @class HTMLElement\n * @extends {Node}\n */\nvar HTMLElement = /*#__PURE__*/function (_Node) {\n  _inherits(HTMLElement, _Node);\n  var _super = _createSuper(HTMLElement);\n  /**\n   * Creates an instance of HTMLElement.\n   * @param keyAttrs\tid and class attribute\n   * @param [rawAttrs]\tattributes in string\n   *\n   * @memberof HTMLElement\n   */\n  function HTMLElement(tagName, keyAttrs) {\n    var _this;\n    var rawAttrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n    var parentNode = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    _classCallCheck(this, HTMLElement);\n    _this = _super.call(this);\n    _this.rawAttrs = rawAttrs;\n    _this.parentNode = parentNode;\n    _this.classNames = [];\n    /**\n     * Node Type declaration.\n     */\n    _this.nodeType = NodeType.ELEMENT_NODE;\n    _this.rawTagName = tagName;\n    _this.rawAttrs = rawAttrs || '';\n    _this.parentNode = parentNode || null;\n    _this.childNodes = [];\n    if (keyAttrs.id) {\n      _this.id = keyAttrs.id;\n      if (!rawAttrs) {\n        _this.rawAttrs = \"id=\\\"\".concat(keyAttrs.id, \"\\\"\");\n      }\n    }\n    if (keyAttrs.class) {\n      _this.classNames = keyAttrs.class.split(/\\s+/);\n      if (!rawAttrs) {\n        var cls = \"class=\\\"\".concat(_this.classNames.join(' '), \"\\\"\");\n        if (_this.rawAttrs) {\n          _this.rawAttrs += \" \".concat(cls);\n        } else {\n          _this.rawAttrs = cls;\n        }\n      }\n    }\n    return _this;\n  }\n  /**\n   * Remove current element\n   */\n  _createClass(HTMLElement, [{\n    key: \"remove\",\n    value: function remove() {\n      var _this2 = this;\n      if (this.parentNode) {\n        var children = this.parentNode.childNodes;\n        this.parentNode.childNodes = children.filter(function (child) {\n          return _this2 !== child;\n        });\n      }\n    }\n    /**\n     * Remove Child element from childNodes array\n     * @param {HTMLElement} node     node to remove\n     */\n  }, {\n    key: \"removeChild\",\n    value: function removeChild(node) {\n      this.childNodes = this.childNodes.filter(function (child) {\n        return child !== node;\n      });\n    }\n    /**\n     * Exchanges given child with new child\n     * @param {HTMLElement} oldNode     node to exchange\n     * @param {HTMLElement} newNode     new node\n     */\n  }, {\n    key: \"exchangeChild\",\n    value: function exchangeChild(oldNode, newNode) {\n      var children = this.childNodes;\n      this.childNodes = children.map(function (child) {\n        if (child === oldNode) {\n          return newNode;\n        }\n        return child;\n      });\n    }\n  }, {\n    key: \"tagName\",\n    get: function get() {\n      return this.rawTagName ? this.rawTagName.toUpperCase() : this.rawTagName;\n    }\n    /**\n     * Get escpaed (as-it) text value of current node and its children.\n     * @return {string} text content\n     */\n  }, {\n    key: \"rawText\",\n    get: function get() {\n      return this.childNodes.reduce(function (pre, cur) {\n        return pre += cur.rawText;\n      }, '');\n    }\n    /**\n     * Get unescaped text value of current node and its children.\n     * @return {string} text content\n     */\n  }, {\n    key: \"text\",\n    get: function get() {\n      return decode(this.rawText);\n    }\n    /**\n     * Get structured Text (with '\\n' etc.)\n     * @return {string} structured text\n     */\n  }, {\n    key: \"structuredText\",\n    get: function get() {\n      var currentBlock = [];\n      var blocks = [currentBlock];\n      function dfs(node) {\n        if (node.nodeType === NodeType.ELEMENT_NODE) {\n          if (kBlockElements.get(node.rawTagName)) {\n            if (currentBlock.length > 0) {\n              blocks.push(currentBlock = []);\n            }\n            node.childNodes.forEach(dfs);\n            if (currentBlock.length > 0) {\n              blocks.push(currentBlock = []);\n            }\n          } else {\n            node.childNodes.forEach(dfs);\n          }\n        } else if (node.nodeType === NodeType.TEXT_NODE) {\n          if (node.isWhitespace) {\n            // Whitespace node, postponed output\n            currentBlock.prependWhitespace = true;\n          } else {\n            var text = node.text;\n            if (currentBlock.prependWhitespace) {\n              text = \" \".concat(text);\n              currentBlock.prependWhitespace = false;\n            }\n            currentBlock.push(text);\n          }\n        }\n      }\n      dfs(this);\n      return blocks.map(function (block) {\n        // Normalize each line's whitespace\n        return block.join('').trim().replace(/\\s{2,}/g, ' ');\n      }).join('\\n').replace(/\\s+$/, ''); // trimRight;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var tag = this.rawTagName;\n      if (tag) {\n        var is_void = /^(area|base|br|col|embed|hr|img|input|link|meta|param|source|track|wbr)$/i.test(tag);\n        var attrs = this.rawAttrs ? \" \".concat(this.rawAttrs) : '';\n        if (is_void) {\n          return \"<\".concat(tag).concat(attrs, \">\");\n        }\n        return \"<\".concat(tag).concat(attrs, \">\").concat(this.innerHTML, \"</\").concat(tag, \">\");\n      }\n      return this.innerHTML;\n    }\n  }, {\n    key: \"innerHTML\",\n    get: function get() {\n      return this.childNodes.map(function (child) {\n        return child.toString();\n      }).join('');\n    }\n  }, {\n    key: \"set_content\",\n    value: function set_content(content) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      if (content instanceof Node) {\n        content = [content];\n      } else if (typeof content == 'string') {\n        var r = parse(content, options);\n        content = r.childNodes.length ? r.childNodes : [new TextNode(content)];\n      }\n      this.childNodes = content;\n    }\n  }, {\n    key: \"outerHTML\",\n    get: function get() {\n      return this.toString();\n    }\n    /**\n     * Trim element from right (in block) after seeing pattern in a TextNode.\n     * @param  {RegExp} pattern pattern to find\n     * @return {HTMLElement}    reference to current node\n     */\n  }, {\n    key: \"trimRight\",\n    value: function trimRight(pattern) {\n      for (var i = 0; i < this.childNodes.length; i++) {\n        var childNode = this.childNodes[i];\n        if (childNode.nodeType === NodeType.ELEMENT_NODE) {\n          childNode.trimRight(pattern);\n        } else {\n          var index = childNode.rawText.search(pattern);\n          if (index > -1) {\n            childNode.rawText = childNode.rawText.substr(0, index);\n            // trim all following nodes.\n            this.childNodes.length = i + 1;\n          }\n        }\n      }\n      return this;\n    }\n    /**\n     * Get DOM structure\n     * @return {string} strucutre\n     */\n  }, {\n    key: \"structure\",\n    get: function get() {\n      var res = [];\n      var indention = 0;\n      function write(str) {\n        res.push('  '.repeat(indention) + str);\n      }\n      function dfs(node) {\n        var idStr = node.id ? \"#\".concat(node.id) : '';\n        var classStr = node.classNames.length ? \".\".concat(node.classNames.join('.')) : '';\n        write(node.rawTagName + idStr + classStr);\n        indention++;\n        node.childNodes.forEach(function (childNode) {\n          if (childNode.nodeType === NodeType.ELEMENT_NODE) {\n            dfs(childNode);\n          } else if (childNode.nodeType === NodeType.TEXT_NODE) {\n            if (!childNode.isWhitespace) {\n              write('#text');\n            }\n          }\n        });\n        indention--;\n      }\n      dfs(this);\n      return res.join('\\n');\n    }\n    /**\n     * Remove whitespaces in this sub tree.\n     * @return {HTMLElement} pointer to this\n     */\n  }, {\n    key: \"removeWhitespace\",\n    value: function removeWhitespace() {\n      var _this3 = this;\n      var o = 0;\n      this.childNodes.forEach(function (node) {\n        if (node.nodeType === NodeType.TEXT_NODE) {\n          if (node.isWhitespace) {\n            return;\n          }\n          node.rawText = node.rawText.trim();\n        } else if (node.nodeType === NodeType.ELEMENT_NODE) {\n          node.removeWhitespace();\n        }\n        _this3.childNodes[o++] = node;\n      });\n      this.childNodes.length = o;\n      return this;\n    }\n    /**\n     * Query CSS selector to find matching nodes.\n     * @param  {string}         selector Simplified CSS selector\n     * @param  {Matcher}        selector A Matcher instance\n     * @return {HTMLElement[]}  matching elements\n     */\n  }, {\n    key: \"querySelectorAll\",\n    value: function querySelectorAll(selector) {\n      var _this4 = this;\n      var matcher;\n      if (selector instanceof Matcher) {\n        matcher = selector;\n        matcher.reset();\n      } else {\n        if (selector.includes(',')) {\n          var selectors = selector.split(',');\n          return Array.from(selectors.reduce(function (pre, cur) {\n            var result = _this4.querySelectorAll(cur.trim());\n            return result.reduce(function (p, c) {\n              return p.add(c);\n            }, pre);\n          }, new Set()));\n        }\n        matcher = new Matcher(selector);\n      }\n      var stack = [];\n      return this.childNodes.reduce(function (res, cur) {\n        stack.push([cur, 0, false]);\n        while (stack.length) {\n          var state = arr_back(stack); // get last element\n          var el = state[0];\n          if (state[1] === 0) {\n            // Seen for first time.\n            if (el.nodeType !== NodeType.ELEMENT_NODE) {\n              stack.pop();\n              continue;\n            }\n            var html_el = el;\n            state[2] = matcher.advance(html_el);\n            if (state[2]) {\n              if (matcher.matched) {\n                res.push(html_el);\n                res.push.apply(res, _toConsumableArray(html_el.querySelectorAll(selector)));\n                // no need to go further.\n                matcher.rewind();\n                stack.pop();\n                continue;\n              }\n            }\n          }\n          if (state[1] < el.childNodes.length) {\n            stack.push([el.childNodes[state[1]++], 0, false]);\n          } else {\n            if (state[2]) {\n              matcher.rewind();\n            }\n            stack.pop();\n          }\n        }\n        return res;\n      }, []);\n    }\n    /**\n     * Query CSS Selector to find matching node.\n     * @param  {string}         selector Simplified CSS selector\n     * @param  {Matcher}        selector A Matcher instance\n     * @return {HTMLElement}    matching node\n     */\n  }, {\n    key: \"querySelector\",\n    value: function querySelector(selector) {\n      var matcher;\n      if (selector instanceof Matcher) {\n        matcher = selector;\n        matcher.reset();\n      } else {\n        matcher = new Matcher(selector);\n      }\n      var stack = [];\n      var _iterator = _createForOfIteratorHelper(this.childNodes),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var node = _step.value;\n          stack.push([node, 0, false]);\n          while (stack.length) {\n            var state = arr_back(stack);\n            var el = state[0];\n            if (state[1] === 0) {\n              // Seen for first time.\n              if (el.nodeType !== NodeType.ELEMENT_NODE) {\n                stack.pop();\n                continue;\n              }\n              state[2] = matcher.advance(el);\n              if (state[2]) {\n                if (matcher.matched) {\n                  return el;\n                }\n              }\n            }\n            if (state[1] < el.childNodes.length) {\n              stack.push([el.childNodes[state[1]++], 0, false]);\n            } else {\n              if (state[2]) {\n                matcher.rewind();\n              }\n              stack.pop();\n            }\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return null;\n    }\n    /**\n     * Append a child node to childNodes\n     * @param  {Node} node node to append\n     * @return {Node}      node appended\n     */\n  }, {\n    key: \"appendChild\",\n    value: function appendChild(node) {\n      // node.parentNode = this;\n      this.childNodes.push(node);\n      if (node instanceof HTMLElement) {\n        node.parentNode = this;\n      }\n      return node;\n    }\n    /**\n     * Get first child node\n     * @return {Node} first child node\n     */\n  }, {\n    key: \"firstChild\",\n    get: function get() {\n      return this.childNodes[0];\n    }\n    /**\n     * Get last child node\n     * @return {Node} last child node\n     */\n  }, {\n    key: \"lastChild\",\n    get: function get() {\n      return arr_back(this.childNodes);\n    }\n    /**\n     * Get attributes\n     * @return {Object} parsed and unescaped attributes\n     */\n  }, {\n    key: \"attributes\",\n    get: function get() {\n      if (this._attrs) {\n        return this._attrs;\n      }\n      this._attrs = {};\n      var attrs = this.rawAttributes;\n      for (var key in attrs) {\n        var val = attrs[key] || '';\n        this._attrs[key] = decode(val);\n      }\n      return this._attrs;\n    }\n    /**\n     * Get escaped (as-it) attributes\n     * @return {Object} parsed attributes\n     */\n  }, {\n    key: \"rawAttributes\",\n    get: function get() {\n      if (this._rawAttrs) {\n        return this._rawAttrs;\n      }\n      var attrs = {};\n      if (this.rawAttrs) {\n        var re = /\\b([a-z][a-z0-9-]*)(?:\\s*=\\s*(?:\"([^\"]*)\"|'([^']*)'|(\\S+)))?/ig;\n        var match;\n        while (match = re.exec(this.rawAttrs)) {\n          attrs[match[1]] = match[2] || match[3] || match[4] || null;\n        }\n      }\n      this._rawAttrs = attrs;\n      return attrs;\n    }\n  }, {\n    key: \"removeAttribute\",\n    value: function removeAttribute(key) {\n      var attrs = this.rawAttributes;\n      delete attrs[key];\n      // Update this.attribute\n      if (this._attrs) {\n        delete this._attrs[key];\n      }\n      // Update rawString\n      this.rawAttrs = Object.keys(attrs).map(function (name) {\n        var val = JSON.stringify(attrs[name]);\n        if (val === undefined || val === 'null') {\n          return name;\n        }\n        return \"\".concat(name, \"=\").concat(val);\n      }).join(' ');\n    }\n  }, {\n    key: \"hasAttribute\",\n    value: function hasAttribute(key) {\n      return key in this.attributes;\n    }\n    /**\n     * Get an attribute\n     * @return {string} value of the attribute\n     */\n  }, {\n    key: \"getAttribute\",\n    value: function getAttribute(key) {\n      return this.attributes[key];\n    }\n    /**\n     * Set an attribute value to the HTMLElement\n     * @param {string} key The attribute name\n     * @param {string} value The value to set, or null / undefined to remove an attribute\n     */\n  }, {\n    key: \"setAttribute\",\n    value: function setAttribute(key, value) {\n      if (arguments.length < 2) {\n        throw new Error('Failed to execute \\'setAttribute\\' on \\'Element\\'');\n      }\n      var attrs = this.rawAttributes;\n      attrs[key] = String(value);\n      if (this._attrs) {\n        this._attrs[key] = decode(attrs[key]);\n      }\n      // Update rawString\n      this.rawAttrs = Object.keys(attrs).map(function (name) {\n        var val = JSON.stringify(attrs[name]);\n        if (val === 'null' || val === '\"\"') {\n          return name;\n        }\n        return \"\".concat(name, \"=\").concat(val);\n      }).join(' ');\n    }\n    /**\n     * Replace all the attributes of the HTMLElement by the provided attributes\n     * @param {Attributes} attributes the new attribute set\n     */\n  }, {\n    key: \"setAttributes\",\n    value: function setAttributes(attributes) {\n      // Invalidate current this.attributes\n      if (this._attrs) {\n        delete this._attrs;\n      }\n      // Invalidate current this.rawAttributes\n      if (this._rawAttrs) {\n        delete this._rawAttrs;\n      }\n      // Update rawString\n      this.rawAttrs = Object.keys(attributes).map(function (name) {\n        var val = attributes[name];\n        if (val === 'null' || val === '\"\"') {\n          return name;\n        }\n        return \"\".concat(name, \"=\").concat(JSON.stringify(String(val)));\n      }).join(' ');\n    }\n  }, {\n    key: \"insertAdjacentHTML\",\n    value: function insertAdjacentHTML(where, html) {\n      var _this5 = this;\n      if (arguments.length < 2) {\n        throw new Error('2 arguments required');\n      }\n      var p = parse(html);\n      if (where === 'afterend') {\n        var _this$parentNode$chil;\n        var idx = this.parentNode.childNodes.findIndex(function (child) {\n          return child === _this5;\n        });\n        (_this$parentNode$chil = this.parentNode.childNodes).splice.apply(_this$parentNode$chil, [idx + 1, 0].concat(_toConsumableArray(p.childNodes)));\n        p.childNodes.forEach(function (n) {\n          if (n instanceof HTMLElement) {\n            n.parentNode = _this5.parentNode;\n          }\n        });\n      } else if (where === 'afterbegin') {\n        var _this$childNodes;\n        (_this$childNodes = this.childNodes).unshift.apply(_this$childNodes, _toConsumableArray(p.childNodes));\n      } else if (where === 'beforeend') {\n        p.childNodes.forEach(function (n) {\n          _this5.appendChild(n);\n        });\n      } else if (where === 'beforebegin') {\n        var _this$parentNode$chil2;\n        var _idx = this.parentNode.childNodes.findIndex(function (child) {\n          return child === _this5;\n        });\n        (_this$parentNode$chil2 = this.parentNode.childNodes).splice.apply(_this$parentNode$chil2, [_idx, 0].concat(_toConsumableArray(p.childNodes)));\n        p.childNodes.forEach(function (n) {\n          if (n instanceof HTMLElement) {\n            n.parentNode = _this5.parentNode;\n          }\n        });\n      } else {\n        throw new Error(\"The value provided ('\".concat(where, \"') is not one of 'beforebegin', 'afterbegin', 'beforeend', or 'afterend'\"));\n      }\n      // if (!where || html === undefined || html === null) {\n      // \treturn;\n      // }\n    }\n  }, {\n    key: \"nextSibling\",\n    get: function get() {\n      if (this.parentNode) {\n        var children = this.parentNode.childNodes;\n        var i = 0;\n        while (i < children.length) {\n          var child = children[i++];\n          if (this === child) {\n            return children[i] || null;\n          }\n        }\n        return null;\n      }\n    }\n  }, {\n    key: \"nextElementSibling\",\n    get: function get() {\n      if (this.parentNode) {\n        var children = this.parentNode.childNodes;\n        var i = 0;\n        var find = false;\n        while (i < children.length) {\n          var child = children[i++];\n          if (find) {\n            if (child instanceof HTMLElement) {\n              return child || null;\n            }\n          } else if (this === child) {\n            find = true;\n          }\n        }\n        return null;\n      }\n    }\n  }]);\n  return HTMLElement;\n}(Node); // https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name\nexport { HTMLElement as default };\nvar kMarkupPattern = /<!--[^]*?(?=-->)-->|<(\\/?)([a-z][-.:0-9_a-z]*)\\s*([^>]*?)(\\/?)>/ig;\n// <(?<tag>[^\\s]*)(.*)>(.*)</\\k<tag>>\n// <([a-z][-.:0-9_a-z]*)\\s*\\/>\n// <(area|base|br|col|hr|img|input|link|meta|source)\\s*(.*)\\/?>\n// <(area|base|br|col|hr|img|input|link|meta|source)\\s*(.*)\\/?>|<(?<tag>[^\\s]*)(.*)>(.*)</\\k<tag>>\nvar kAttributePattern = /(^|\\s)(id|class)\\s*=\\s*(\"([^\"]+)\"|'([^']+)'|(\\S+))/ig;\nvar kSelfClosingElements = {\n  area: true,\n  AREA: true,\n  base: true,\n  BASE: true,\n  br: true,\n  BR: true,\n  col: true,\n  COL: true,\n  hr: true,\n  HR: true,\n  img: true,\n  IMG: true,\n  input: true,\n  INPUT: true,\n  link: true,\n  LINK: true,\n  meta: true,\n  META: true,\n  source: true,\n  SOURCE: true,\n  embed: true,\n  EMBED: true,\n  param: true,\n  PARAM: true,\n  track: true,\n  TRACK: true,\n  wbr: true,\n  WBR: true\n};\nvar kElementsClosedByOpening = {\n  li: {\n    li: true,\n    LI: true\n  },\n  LI: {\n    li: true,\n    LI: true\n  },\n  p: {\n    p: true,\n    div: true,\n    P: true,\n    DIV: true\n  },\n  P: {\n    p: true,\n    div: true,\n    P: true,\n    DIV: true\n  },\n  b: {\n    div: true,\n    DIV: true\n  },\n  B: {\n    div: true,\n    DIV: true\n  },\n  td: {\n    td: true,\n    th: true,\n    TD: true,\n    TH: true\n  },\n  TD: {\n    td: true,\n    th: true,\n    TD: true,\n    TH: true\n  },\n  th: {\n    td: true,\n    th: true,\n    TD: true,\n    TH: true\n  },\n  TH: {\n    td: true,\n    th: true,\n    TD: true,\n    TH: true\n  },\n  h1: {\n    h1: true,\n    H1: true\n  },\n  H1: {\n    h1: true,\n    H1: true\n  },\n  h2: {\n    h2: true,\n    H2: true\n  },\n  H2: {\n    h2: true,\n    H2: true\n  },\n  h3: {\n    h3: true,\n    H3: true\n  },\n  H3: {\n    h3: true,\n    H3: true\n  },\n  h4: {\n    h4: true,\n    H4: true\n  },\n  H4: {\n    h4: true,\n    H4: true\n  },\n  h5: {\n    h5: true,\n    H5: true\n  },\n  H5: {\n    h5: true,\n    H5: true\n  },\n  h6: {\n    h6: true,\n    H6: true\n  },\n  H6: {\n    h6: true,\n    H6: true\n  }\n};\nvar kElementsClosedByClosing = {\n  li: {\n    ul: true,\n    ol: true,\n    UL: true,\n    OL: true\n  },\n  LI: {\n    ul: true,\n    ol: true,\n    UL: true,\n    OL: true\n  },\n  a: {\n    div: true,\n    DIV: true\n  },\n  A: {\n    div: true,\n    DIV: true\n  },\n  b: {\n    div: true,\n    DIV: true\n  },\n  B: {\n    div: true,\n    DIV: true\n  },\n  i: {\n    div: true,\n    DIV: true\n  },\n  I: {\n    div: true,\n    DIV: true\n  },\n  p: {\n    div: true,\n    DIV: true\n  },\n  P: {\n    div: true,\n    DIV: true\n  },\n  td: {\n    tr: true,\n    table: true,\n    TR: true,\n    TABLE: true\n  },\n  TD: {\n    tr: true,\n    table: true,\n    TR: true,\n    TABLE: true\n  },\n  th: {\n    tr: true,\n    table: true,\n    TR: true,\n    TABLE: true\n  },\n  TH: {\n    tr: true,\n    table: true,\n    TR: true,\n    TABLE: true\n  }\n};\nvar frameflag = 'documentfragmentcontainer';\nexport function parse(data) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    lowerCaseTagName: false,\n    comment: false\n  };\n  var elements = options.blockTextElements || {\n    script: true,\n    noscript: true,\n    style: true,\n    pre: true\n  };\n  var element_names = Object.keys(elements);\n  var kBlockTextElements = element_names.map(function (it) {\n    return new RegExp(it, 'i');\n  });\n  var kIgnoreElements = element_names.filter(function (it) {\n    return elements[it];\n  }).map(function (it) {\n    return new RegExp(it, 'i');\n  });\n  function element_should_be_ignore(tag) {\n    return kIgnoreElements.some(function (it) {\n      return it.test(tag);\n    });\n  }\n  function is_block_text_element(tag) {\n    return kBlockTextElements.some(function (it) {\n      return it.test(tag);\n    });\n  }\n  var root = new HTMLElement(null, {});\n  var currentParent = root;\n  var stack = [root];\n  var lastTextPos = -1;\n  var match;\n  // https://github.com/taoqf/node-html-parser/issues/38\n  data = \"<\".concat(frameflag, \">\").concat(data, \"</\").concat(frameflag, \">\");\n  var _loop = function _loop() {\n    if (lastTextPos > -1) {\n      if (lastTextPos + match[0].length < kMarkupPattern.lastIndex) {\n        // if has content\n        var text = data.substring(lastTextPos, kMarkupPattern.lastIndex - match[0].length);\n        currentParent.appendChild(new TextNode(text));\n      }\n    }\n    lastTextPos = kMarkupPattern.lastIndex;\n    if (match[2] === frameflag) {\n      return \"continue\";\n    }\n    if (match[0][1] === '!') {\n      // this is a comment\n      if (options.comment) {\n        // Only keep what is in between <!-- and -->\n        var _text = data.substring(lastTextPos - 3, lastTextPos - match[0].length + 4);\n        currentParent.appendChild(new CommentNode(_text));\n      }\n      return \"continue\";\n    }\n    if (options.lowerCaseTagName) {\n      match[2] = match[2].toLowerCase();\n    }\n    if (!match[1]) {\n      // not </ tags\n      var attrs = {};\n      for (var attMatch; attMatch = kAttributePattern.exec(match[3]);) {\n        attrs[attMatch[2].toLowerCase()] = attMatch[4] || attMatch[5] || attMatch[6];\n      }\n      var tagName = currentParent.rawTagName;\n      if (!match[4] && kElementsClosedByOpening[tagName]) {\n        if (kElementsClosedByOpening[tagName][match[2]]) {\n          stack.pop();\n          currentParent = arr_back(stack);\n        }\n      }\n      // ignore container tag we add above\n      // https://github.com/taoqf/node-html-parser/issues/38\n      currentParent = currentParent.appendChild(new HTMLElement(match[2], attrs, match[3]));\n      stack.push(currentParent);\n      if (is_block_text_element(match[2])) {\n        // a little test to find next </script> or </style> ...\n        var closeMarkup = \"</\".concat(match[2], \">\");\n        var index = function () {\n          if (options.lowerCaseTagName) {\n            return data.toLocaleLowerCase().indexOf(closeMarkup, kMarkupPattern.lastIndex);\n          }\n          return data.indexOf(closeMarkup, kMarkupPattern.lastIndex);\n        }();\n        if (element_should_be_ignore(match[2])) {\n          var _text2;\n          if (index === -1) {\n            // there is no matching ending for the text element.\n            _text2 = data.substr(kMarkupPattern.lastIndex);\n          } else {\n            _text2 = data.substring(kMarkupPattern.lastIndex, index);\n          }\n          if (_text2.length > 0) {\n            currentParent.appendChild(new TextNode(_text2));\n          }\n        }\n        if (index === -1) {\n          lastTextPos = kMarkupPattern.lastIndex = data.length + 1;\n        } else {\n          lastTextPos = kMarkupPattern.lastIndex = index + closeMarkup.length;\n          match[1] = 'true';\n        }\n      }\n    }\n    if (match[1] || match[4] || kSelfClosingElements[match[2]]) {\n      // </ or /> or <br> etc.\n      while (true) {\n        if (currentParent.rawTagName === match[2]) {\n          stack.pop();\n          currentParent = arr_back(stack);\n          break;\n        } else {\n          var _tagName = currentParent.tagName;\n          // Trying to close current tag, and move on\n          if (kElementsClosedByClosing[_tagName]) {\n            if (kElementsClosedByClosing[_tagName][match[2]]) {\n              stack.pop();\n              currentParent = arr_back(stack);\n              continue;\n            }\n          }\n          // Use aggressive strategy to handle unmatching markups.\n          break;\n        }\n      }\n    }\n  };\n  while (match = kMarkupPattern.exec(data)) {\n    var _ret = _loop();\n    if (_ret === \"continue\") continue;\n  }\n  var valid = Boolean(stack.length === 1);\n  if (!options.noFix) {\n    var _response = root;\n    _response.valid = valid;\n    var _loop2 = function _loop2() {\n      // Handle each error elements.\n      var last = stack.pop();\n      var oneBefore = arr_back(stack);\n      if (last.parentNode && last.parentNode.parentNode) {\n        if (last.parentNode === oneBefore && last.tagName === oneBefore.tagName) {\n          // Pair error case <h3> <h3> handle : Fixes to <h3> </h3>\n          oneBefore.removeChild(last);\n          last.childNodes.forEach(function (child) {\n            oneBefore.parentNode.appendChild(child);\n          });\n          stack.pop();\n        } else {\n          // Single error  <div> <h3> </div> handle: Just removes <h3>\n          oneBefore.removeChild(last);\n          last.childNodes.forEach(function (child) {\n            oneBefore.appendChild(child);\n          });\n        }\n      } else {\n        // If it's final element just skip.\n      }\n    };\n    while (stack.length > 1) {\n      _loop2();\n    }\n    _response.childNodes.forEach(function (node) {\n      if (node instanceof HTMLElement) {\n        node.parentNode = null;\n      }\n    });\n    return _response;\n  }\n  var response = new TextNode(data);\n  response.valid = valid;\n  return response;\n}","map":{"version":3,"names":["decode","Node","NodeType","TextNode","Matcher","arr_back","CommentNode","kBlockElements","Map","set","HTMLElement","_Node","_inherits","_super","_createSuper","tagName","keyAttrs","_this","rawAttrs","arguments","length","undefined","parentNode","_classCallCheck","call","classNames","nodeType","ELEMENT_NODE","rawTagName","childNodes","id","concat","class","split","cls","join","_createClass","key","value","remove","_this2","children","filter","child","removeChild","node","exchangeChild","oldNode","newNode","map","get","toUpperCase","reduce","pre","cur","rawText","currentBlock","blocks","dfs","push","forEach","TEXT_NODE","isWhitespace","prependWhitespace","text","block","trim","replace","toString","tag","is_void","test","attrs","innerHTML","set_content","content","options","r","parse","trimRight","pattern","i","childNode","index","search","substr","res","indention","write","str","repeat","idStr","classStr","removeWhitespace","_this3","o","querySelectorAll","selector","_this4","matcher","reset","includes","selectors","Array","from","result","p","c","add","Set","stack","state","el","pop","html_el","advance","matched","apply","_toConsumableArray","rewind","querySelector","_iterator","_createForOfIteratorHelper","_step","s","n","done","err","e","f","appendChild","_attrs","rawAttributes","val","_rawAttrs","re","match","exec","removeAttribute","Object","keys","name","JSON","stringify","hasAttribute","attributes","getAttribute","setAttribute","Error","String","setAttributes","insertAdjacentHTML","where","html","_this5","_this$parentNode$chil","idx","findIndex","splice","_this$childNodes","unshift","_this$parentNode$chil2","find","default","kMarkupPattern","kAttributePattern","kSelfClosingElements","area","AREA","base","BASE","br","BR","col","COL","hr","HR","img","IMG","input","INPUT","link","LINK","meta","META","source","SOURCE","embed","EMBED","param","PARAM","track","TRACK","wbr","WBR","kElementsClosedByOpening","li","LI","div","P","DIV","b","B","td","th","TD","TH","h1","H1","h2","H2","h3","H3","h4","H4","h5","H5","h6","H6","kElementsClosedByClosing","ul","ol","UL","OL","a","A","I","tr","table","TR","TABLE","frameflag","data","lowerCaseTagName","comment","elements","blockTextElements","script","noscript","style","element_names","kBlockTextElements","it","RegExp","kIgnoreElements","element_should_be_ignore","some","is_block_text_element","root","currentParent","lastTextPos","_loop","lastIndex","substring","toLowerCase","attMatch","closeMarkup","toLocaleLowerCase","indexOf","_ret","valid","Boolean","noFix","response","_loop2","last","oneBefore"],"sources":["D:/Dapp/Clients/site-builder/grapesJs/node_modules/node-html-parser/dist/esm/nodes/html.js"],"sourcesContent":["import { decode } from 'he';\nimport Node from './node';\nimport NodeType from './type';\nimport TextNode from './text';\nimport Matcher from '../matcher';\nimport arr_back from '../back';\nimport CommentNode from './comment';\nconst kBlockElements = new Map();\nkBlockElements.set('DIV', true);\nkBlockElements.set('div', true);\nkBlockElements.set('P', true);\nkBlockElements.set('p', true);\n// ul: true,\n// ol: true,\nkBlockElements.set('LI', true);\nkBlockElements.set('li', true);\n// table: true,\n// tr: true,\nkBlockElements.set('TD', true);\nkBlockElements.set('td', true);\nkBlockElements.set('SECTION', true);\nkBlockElements.set('section', true);\nkBlockElements.set('BR', true);\nkBlockElements.set('br', true);\n/**\n * HTMLElement, which contains a set of children.\n *\n * Note: this is a minimalist implementation, no complete tree\n *   structure provided (no parentNode, nextSibling,\n *   previousSibling etc).\n * @class HTMLElement\n * @extends {Node}\n */\nexport default class HTMLElement extends Node {\n    /**\n     * Creates an instance of HTMLElement.\n     * @param keyAttrs\tid and class attribute\n     * @param [rawAttrs]\tattributes in string\n     *\n     * @memberof HTMLElement\n     */\n    constructor(tagName, keyAttrs, rawAttrs = '', parentNode = null) {\n        super();\n        this.rawAttrs = rawAttrs;\n        this.parentNode = parentNode;\n        this.classNames = [];\n        /**\n         * Node Type declaration.\n         */\n        this.nodeType = NodeType.ELEMENT_NODE;\n        this.rawTagName = tagName;\n        this.rawAttrs = rawAttrs || '';\n        this.parentNode = parentNode || null;\n        this.childNodes = [];\n        if (keyAttrs.id) {\n            this.id = keyAttrs.id;\n            if (!rawAttrs) {\n                this.rawAttrs = `id=\"${keyAttrs.id}\"`;\n            }\n        }\n        if (keyAttrs.class) {\n            this.classNames = keyAttrs.class.split(/\\s+/);\n            if (!rawAttrs) {\n                const cls = `class=\"${this.classNames.join(' ')}\"`;\n                if (this.rawAttrs) {\n                    this.rawAttrs += ` ${cls}`;\n                }\n                else {\n                    this.rawAttrs = cls;\n                }\n            }\n        }\n    }\n    /**\n     * Remove current element\n     */\n    remove() {\n        if (this.parentNode) {\n            const children = this.parentNode.childNodes;\n            this.parentNode.childNodes = children.filter((child) => {\n                return this !== child;\n            });\n        }\n    }\n    /**\n     * Remove Child element from childNodes array\n     * @param {HTMLElement} node     node to remove\n     */\n    removeChild(node) {\n        this.childNodes = this.childNodes.filter((child) => {\n            return (child !== node);\n        });\n    }\n    /**\n     * Exchanges given child with new child\n     * @param {HTMLElement} oldNode     node to exchange\n     * @param {HTMLElement} newNode     new node\n     */\n    exchangeChild(oldNode, newNode) {\n        const children = this.childNodes;\n        this.childNodes = children.map((child) => {\n            if (child === oldNode) {\n                return newNode;\n            }\n            return child;\n        });\n    }\n    get tagName() {\n        return this.rawTagName ? this.rawTagName.toUpperCase() : this.rawTagName;\n    }\n    /**\n     * Get escpaed (as-it) text value of current node and its children.\n     * @return {string} text content\n     */\n    get rawText() {\n        return this.childNodes.reduce((pre, cur) => {\n            return (pre += cur.rawText);\n        }, '');\n    }\n    /**\n     * Get unescaped text value of current node and its children.\n     * @return {string} text content\n     */\n    get text() {\n        return decode(this.rawText);\n    }\n    /**\n     * Get structured Text (with '\\n' etc.)\n     * @return {string} structured text\n     */\n    get structuredText() {\n        let currentBlock = [];\n        const blocks = [currentBlock];\n        function dfs(node) {\n            if (node.nodeType === NodeType.ELEMENT_NODE) {\n                if (kBlockElements.get(node.rawTagName)) {\n                    if (currentBlock.length > 0) {\n                        blocks.push(currentBlock = []);\n                    }\n                    node.childNodes.forEach(dfs);\n                    if (currentBlock.length > 0) {\n                        blocks.push(currentBlock = []);\n                    }\n                }\n                else {\n                    node.childNodes.forEach(dfs);\n                }\n            }\n            else if (node.nodeType === NodeType.TEXT_NODE) {\n                if (node.isWhitespace) {\n                    // Whitespace node, postponed output\n                    currentBlock.prependWhitespace = true;\n                }\n                else {\n                    let text = node.text;\n                    if (currentBlock.prependWhitespace) {\n                        text = ` ${text}`;\n                        currentBlock.prependWhitespace = false;\n                    }\n                    currentBlock.push(text);\n                }\n            }\n        }\n        dfs(this);\n        return blocks.map((block) => {\n            // Normalize each line's whitespace\n            return block.join('').trim().replace(/\\s{2,}/g, ' ');\n        })\n            .join('\\n').replace(/\\s+$/, ''); // trimRight;\n    }\n    toString() {\n        const tag = this.rawTagName;\n        if (tag) {\n            const is_void = /^(area|base|br|col|embed|hr|img|input|link|meta|param|source|track|wbr)$/i.test(tag);\n            const attrs = this.rawAttrs ? ` ${this.rawAttrs}` : '';\n            if (is_void) {\n                return `<${tag}${attrs}>`;\n            }\n            return `<${tag}${attrs}>${this.innerHTML}</${tag}>`;\n        }\n        return this.innerHTML;\n    }\n    get innerHTML() {\n        return this.childNodes.map((child) => {\n            return child.toString();\n        }).join('');\n    }\n    set_content(content, options = {}) {\n        if (content instanceof Node) {\n            content = [content];\n        }\n        else if (typeof content == 'string') {\n            const r = parse(content, options);\n            content = r.childNodes.length ? r.childNodes : [new TextNode(content)];\n        }\n        this.childNodes = content;\n    }\n    get outerHTML() {\n        return this.toString();\n    }\n    /**\n     * Trim element from right (in block) after seeing pattern in a TextNode.\n     * @param  {RegExp} pattern pattern to find\n     * @return {HTMLElement}    reference to current node\n     */\n    trimRight(pattern) {\n        for (let i = 0; i < this.childNodes.length; i++) {\n            const childNode = this.childNodes[i];\n            if (childNode.nodeType === NodeType.ELEMENT_NODE) {\n                childNode.trimRight(pattern);\n            }\n            else {\n                const index = childNode.rawText.search(pattern);\n                if (index > -1) {\n                    childNode.rawText = childNode.rawText.substr(0, index);\n                    // trim all following nodes.\n                    this.childNodes.length = i + 1;\n                }\n            }\n        }\n        return this;\n    }\n    /**\n     * Get DOM structure\n     * @return {string} strucutre\n     */\n    get structure() {\n        const res = [];\n        let indention = 0;\n        function write(str) {\n            res.push('  '.repeat(indention) + str);\n        }\n        function dfs(node) {\n            const idStr = node.id ? (`#${node.id}`) : '';\n            const classStr = node.classNames.length ? (`.${node.classNames.join('.')}`) : '';\n            write(node.rawTagName + idStr + classStr);\n            indention++;\n            node.childNodes.forEach((childNode) => {\n                if (childNode.nodeType === NodeType.ELEMENT_NODE) {\n                    dfs(childNode);\n                }\n                else if (childNode.nodeType === NodeType.TEXT_NODE) {\n                    if (!childNode.isWhitespace) {\n                        write('#text');\n                    }\n                }\n            });\n            indention--;\n        }\n        dfs(this);\n        return res.join('\\n');\n    }\n    /**\n     * Remove whitespaces in this sub tree.\n     * @return {HTMLElement} pointer to this\n     */\n    removeWhitespace() {\n        let o = 0;\n        this.childNodes.forEach((node) => {\n            if (node.nodeType === NodeType.TEXT_NODE) {\n                if (node.isWhitespace) {\n                    return;\n                }\n                node.rawText = node.rawText.trim();\n            }\n            else if (node.nodeType === NodeType.ELEMENT_NODE) {\n                node.removeWhitespace();\n            }\n            this.childNodes[o++] = node;\n        });\n        this.childNodes.length = o;\n        return this;\n    }\n    /**\n     * Query CSS selector to find matching nodes.\n     * @param  {string}         selector Simplified CSS selector\n     * @param  {Matcher}        selector A Matcher instance\n     * @return {HTMLElement[]}  matching elements\n     */\n    querySelectorAll(selector) {\n        let matcher;\n        if (selector instanceof Matcher) {\n            matcher = selector;\n            matcher.reset();\n        }\n        else {\n            if (selector.includes(',')) {\n                const selectors = selector.split(',');\n                return Array.from(selectors.reduce((pre, cur) => {\n                    const result = this.querySelectorAll(cur.trim());\n                    return result.reduce((p, c) => {\n                        return p.add(c);\n                    }, pre);\n                }, new Set()));\n            }\n            matcher = new Matcher(selector);\n        }\n        const stack = [];\n        return this.childNodes.reduce((res, cur) => {\n            stack.push([cur, 0, false]);\n            while (stack.length) {\n                const state = arr_back(stack); // get last element\n                const el = state[0];\n                if (state[1] === 0) {\n                    // Seen for first time.\n                    if (el.nodeType !== NodeType.ELEMENT_NODE) {\n                        stack.pop();\n                        continue;\n                    }\n                    const html_el = el;\n                    state[2] = matcher.advance(html_el);\n                    if (state[2]) {\n                        if (matcher.matched) {\n                            res.push(html_el);\n                            res.push(...(html_el.querySelectorAll(selector)));\n                            // no need to go further.\n                            matcher.rewind();\n                            stack.pop();\n                            continue;\n                        }\n                    }\n                }\n                if (state[1] < el.childNodes.length) {\n                    stack.push([el.childNodes[state[1]++], 0, false]);\n                }\n                else {\n                    if (state[2]) {\n                        matcher.rewind();\n                    }\n                    stack.pop();\n                }\n            }\n            return res;\n        }, []);\n    }\n    /**\n     * Query CSS Selector to find matching node.\n     * @param  {string}         selector Simplified CSS selector\n     * @param  {Matcher}        selector A Matcher instance\n     * @return {HTMLElement}    matching node\n     */\n    querySelector(selector) {\n        let matcher;\n        if (selector instanceof Matcher) {\n            matcher = selector;\n            matcher.reset();\n        }\n        else {\n            matcher = new Matcher(selector);\n        }\n        const stack = [];\n        for (const node of this.childNodes) {\n            stack.push([node, 0, false]);\n            while (stack.length) {\n                const state = arr_back(stack);\n                const el = state[0];\n                if (state[1] === 0) {\n                    // Seen for first time.\n                    if (el.nodeType !== NodeType.ELEMENT_NODE) {\n                        stack.pop();\n                        continue;\n                    }\n                    state[2] = matcher.advance(el);\n                    if (state[2]) {\n                        if (matcher.matched) {\n                            return el;\n                        }\n                    }\n                }\n                if (state[1] < el.childNodes.length) {\n                    stack.push([el.childNodes[state[1]++], 0, false]);\n                }\n                else {\n                    if (state[2]) {\n                        matcher.rewind();\n                    }\n                    stack.pop();\n                }\n            }\n        }\n        return null;\n    }\n    /**\n     * Append a child node to childNodes\n     * @param  {Node} node node to append\n     * @return {Node}      node appended\n     */\n    appendChild(node) {\n        // node.parentNode = this;\n        this.childNodes.push(node);\n        if (node instanceof HTMLElement) {\n            node.parentNode = this;\n        }\n        return node;\n    }\n    /**\n     * Get first child node\n     * @return {Node} first child node\n     */\n    get firstChild() {\n        return this.childNodes[0];\n    }\n    /**\n     * Get last child node\n     * @return {Node} last child node\n     */\n    get lastChild() {\n        return arr_back(this.childNodes);\n    }\n    /**\n     * Get attributes\n     * @return {Object} parsed and unescaped attributes\n     */\n    get attributes() {\n        if (this._attrs) {\n            return this._attrs;\n        }\n        this._attrs = {};\n        const attrs = this.rawAttributes;\n        for (const key in attrs) {\n            const val = attrs[key] || '';\n            this._attrs[key] = decode(val);\n        }\n        return this._attrs;\n    }\n    /**\n     * Get escaped (as-it) attributes\n     * @return {Object} parsed attributes\n     */\n    get rawAttributes() {\n        if (this._rawAttrs) {\n            return this._rawAttrs;\n        }\n        const attrs = {};\n        if (this.rawAttrs) {\n            const re = /\\b([a-z][a-z0-9-]*)(?:\\s*=\\s*(?:\"([^\"]*)\"|'([^']*)'|(\\S+)))?/ig;\n            let match;\n            while ((match = re.exec(this.rawAttrs))) {\n                attrs[match[1]] = match[2] || match[3] || match[4] || null;\n            }\n        }\n        this._rawAttrs = attrs;\n        return attrs;\n    }\n    removeAttribute(key) {\n        const attrs = this.rawAttributes;\n        delete attrs[key];\n        // Update this.attribute\n        if (this._attrs) {\n            delete this._attrs[key];\n        }\n        // Update rawString\n        this.rawAttrs = Object.keys(attrs).map((name) => {\n            const val = JSON.stringify(attrs[name]);\n            if (val === undefined || val === 'null') {\n                return name;\n            }\n            return `${name}=${val}`;\n        }).join(' ');\n    }\n    hasAttribute(key) {\n        return key in this.attributes;\n    }\n    /**\n     * Get an attribute\n     * @return {string} value of the attribute\n     */\n    getAttribute(key) {\n        return this.attributes[key];\n    }\n    /**\n     * Set an attribute value to the HTMLElement\n     * @param {string} key The attribute name\n     * @param {string} value The value to set, or null / undefined to remove an attribute\n     */\n    setAttribute(key, value) {\n        if (arguments.length < 2) {\n            throw new Error('Failed to execute \\'setAttribute\\' on \\'Element\\'');\n        }\n        const attrs = this.rawAttributes;\n        attrs[key] = String(value);\n        if (this._attrs) {\n            this._attrs[key] = decode(attrs[key]);\n        }\n        // Update rawString\n        this.rawAttrs = Object.keys(attrs).map((name) => {\n            const val = JSON.stringify(attrs[name]);\n            if (val === 'null' || val === '\"\"') {\n                return name;\n            }\n            return `${name}=${val}`;\n        }).join(' ');\n    }\n    /**\n     * Replace all the attributes of the HTMLElement by the provided attributes\n     * @param {Attributes} attributes the new attribute set\n     */\n    setAttributes(attributes) {\n        // Invalidate current this.attributes\n        if (this._attrs) {\n            delete this._attrs;\n        }\n        // Invalidate current this.rawAttributes\n        if (this._rawAttrs) {\n            delete this._rawAttrs;\n        }\n        // Update rawString\n        this.rawAttrs = Object.keys(attributes).map((name) => {\n            const val = attributes[name];\n            if (val === 'null' || val === '\"\"') {\n                return name;\n            }\n            return `${name}=${JSON.stringify(String(val))}`;\n        }).join(' ');\n    }\n    insertAdjacentHTML(where, html) {\n        if (arguments.length < 2) {\n            throw new Error('2 arguments required');\n        }\n        const p = parse(html);\n        if (where === 'afterend') {\n            const idx = this.parentNode.childNodes.findIndex((child) => {\n                return child === this;\n            });\n            this.parentNode.childNodes.splice(idx + 1, 0, ...p.childNodes);\n            p.childNodes.forEach((n) => {\n                if (n instanceof HTMLElement) {\n                    n.parentNode = this.parentNode;\n                }\n            });\n        }\n        else if (where === 'afterbegin') {\n            this.childNodes.unshift(...p.childNodes);\n        }\n        else if (where === 'beforeend') {\n            p.childNodes.forEach((n) => {\n                this.appendChild(n);\n            });\n        }\n        else if (where === 'beforebegin') {\n            const idx = this.parentNode.childNodes.findIndex((child) => {\n                return child === this;\n            });\n            this.parentNode.childNodes.splice(idx, 0, ...p.childNodes);\n            p.childNodes.forEach((n) => {\n                if (n instanceof HTMLElement) {\n                    n.parentNode = this.parentNode;\n                }\n            });\n        }\n        else {\n            throw new Error(`The value provided ('${where}') is not one of 'beforebegin', 'afterbegin', 'beforeend', or 'afterend'`);\n        }\n        // if (!where || html === undefined || html === null) {\n        // \treturn;\n        // }\n    }\n    get nextSibling() {\n        if (this.parentNode) {\n            const children = this.parentNode.childNodes;\n            let i = 0;\n            while (i < children.length) {\n                const child = children[i++];\n                if (this === child) {\n                    return children[i] || null;\n                }\n            }\n            return null;\n        }\n    }\n    get nextElementSibling() {\n        if (this.parentNode) {\n            const children = this.parentNode.childNodes;\n            let i = 0;\n            let find = false;\n            while (i < children.length) {\n                const child = children[i++];\n                if (find) {\n                    if (child instanceof HTMLElement) {\n                        return child || null;\n                    }\n                }\n                else if (this === child) {\n                    find = true;\n                }\n            }\n            return null;\n        }\n    }\n}\n// https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name\nconst kMarkupPattern = /<!--[^]*?(?=-->)-->|<(\\/?)([a-z][-.:0-9_a-z]*)\\s*([^>]*?)(\\/?)>/ig;\n// <(?<tag>[^\\s]*)(.*)>(.*)</\\k<tag>>\n// <([a-z][-.:0-9_a-z]*)\\s*\\/>\n// <(area|base|br|col|hr|img|input|link|meta|source)\\s*(.*)\\/?>\n// <(area|base|br|col|hr|img|input|link|meta|source)\\s*(.*)\\/?>|<(?<tag>[^\\s]*)(.*)>(.*)</\\k<tag>>\nconst kAttributePattern = /(^|\\s)(id|class)\\s*=\\s*(\"([^\"]+)\"|'([^']+)'|(\\S+))/ig;\nconst kSelfClosingElements = {\n    area: true,\n    AREA: true,\n    base: true,\n    BASE: true,\n    br: true,\n    BR: true,\n    col: true,\n    COL: true,\n    hr: true,\n    HR: true,\n    img: true,\n    IMG: true,\n    input: true,\n    INPUT: true,\n    link: true,\n    LINK: true,\n    meta: true,\n    META: true,\n    source: true,\n    SOURCE: true,\n    embed: true,\n    EMBED: true,\n    param: true,\n    PARAM: true,\n    track: true,\n    TRACK: true,\n    wbr: true,\n    WBR: true\n};\nconst kElementsClosedByOpening = {\n    li: { li: true, LI: true },\n    LI: { li: true, LI: true },\n    p: { p: true, div: true, P: true, DIV: true },\n    P: { p: true, div: true, P: true, DIV: true },\n    b: { div: true, DIV: true },\n    B: { div: true, DIV: true },\n    td: { td: true, th: true, TD: true, TH: true },\n    TD: { td: true, th: true, TD: true, TH: true },\n    th: { td: true, th: true, TD: true, TH: true },\n    TH: { td: true, th: true, TD: true, TH: true },\n    h1: { h1: true, H1: true },\n    H1: { h1: true, H1: true },\n    h2: { h2: true, H2: true },\n    H2: { h2: true, H2: true },\n    h3: { h3: true, H3: true },\n    H3: { h3: true, H3: true },\n    h4: { h4: true, H4: true },\n    H4: { h4: true, H4: true },\n    h5: { h5: true, H5: true },\n    H5: { h5: true, H5: true },\n    h6: { h6: true, H6: true },\n    H6: { h6: true, H6: true }\n};\nconst kElementsClosedByClosing = {\n    li: { ul: true, ol: true, UL: true, OL: true },\n    LI: { ul: true, ol: true, UL: true, OL: true },\n    a: { div: true, DIV: true },\n    A: { div: true, DIV: true },\n    b: { div: true, DIV: true },\n    B: { div: true, DIV: true },\n    i: { div: true, DIV: true },\n    I: { div: true, DIV: true },\n    p: { div: true, DIV: true },\n    P: { div: true, DIV: true },\n    td: { tr: true, table: true, TR: true, TABLE: true },\n    TD: { tr: true, table: true, TR: true, TABLE: true },\n    th: { tr: true, table: true, TR: true, TABLE: true },\n    TH: { tr: true, table: true, TR: true, TABLE: true }\n};\nconst frameflag = 'documentfragmentcontainer';\nexport function parse(data, options = { lowerCaseTagName: false, comment: false }) {\n    const elements = options.blockTextElements || {\n        script: true,\n        noscript: true,\n        style: true,\n        pre: true\n    };\n    const element_names = Object.keys(elements);\n    const kBlockTextElements = element_names.map((it) => {\n        return new RegExp(it, 'i');\n    });\n    const kIgnoreElements = element_names.filter((it) => {\n        return elements[it];\n    }).map((it) => {\n        return new RegExp(it, 'i');\n    });\n    function element_should_be_ignore(tag) {\n        return kIgnoreElements.some((it) => {\n            return it.test(tag);\n        });\n    }\n    function is_block_text_element(tag) {\n        return kBlockTextElements.some((it) => {\n            return it.test(tag);\n        });\n    }\n    const root = new HTMLElement(null, {});\n    let currentParent = root;\n    const stack = [root];\n    let lastTextPos = -1;\n    let match;\n    // https://github.com/taoqf/node-html-parser/issues/38\n    data = `<${frameflag}>${data}</${frameflag}>`;\n    while ((match = kMarkupPattern.exec(data))) {\n        if (lastTextPos > -1) {\n            if (lastTextPos + match[0].length < kMarkupPattern.lastIndex) {\n                // if has content\n                const text = data.substring(lastTextPos, kMarkupPattern.lastIndex - match[0].length);\n                currentParent.appendChild(new TextNode(text));\n            }\n        }\n        lastTextPos = kMarkupPattern.lastIndex;\n        if (match[2] === frameflag) {\n            continue;\n        }\n        if (match[0][1] === '!') {\n            // this is a comment\n            if (options.comment) {\n                // Only keep what is in between <!-- and -->\n                const text = data.substring(lastTextPos - 3, lastTextPos - match[0].length + 4);\n                currentParent.appendChild(new CommentNode(text));\n            }\n            continue;\n        }\n        if (options.lowerCaseTagName) {\n            match[2] = match[2].toLowerCase();\n        }\n        if (!match[1]) {\n            // not </ tags\n            const attrs = {};\n            for (let attMatch; (attMatch = kAttributePattern.exec(match[3]));) {\n                attrs[attMatch[2].toLowerCase()] = attMatch[4] || attMatch[5] || attMatch[6];\n            }\n            const tagName = currentParent.rawTagName;\n            if (!match[4] && kElementsClosedByOpening[tagName]) {\n                if (kElementsClosedByOpening[tagName][match[2]]) {\n                    stack.pop();\n                    currentParent = arr_back(stack);\n                }\n            }\n            // ignore container tag we add above\n            // https://github.com/taoqf/node-html-parser/issues/38\n            currentParent = currentParent.appendChild(new HTMLElement(match[2], attrs, match[3]));\n            stack.push(currentParent);\n            if (is_block_text_element(match[2])) {\n                // a little test to find next </script> or </style> ...\n                const closeMarkup = `</${match[2]}>`;\n                const index = (() => {\n                    if (options.lowerCaseTagName) {\n                        return data.toLocaleLowerCase().indexOf(closeMarkup, kMarkupPattern.lastIndex);\n                    }\n                    return data.indexOf(closeMarkup, kMarkupPattern.lastIndex);\n                })();\n                if (element_should_be_ignore(match[2])) {\n                    let text;\n                    if (index === -1) {\n                        // there is no matching ending for the text element.\n                        text = data.substr(kMarkupPattern.lastIndex);\n                    }\n                    else {\n                        text = data.substring(kMarkupPattern.lastIndex, index);\n                    }\n                    if (text.length > 0) {\n                        currentParent.appendChild(new TextNode(text));\n                    }\n                }\n                if (index === -1) {\n                    lastTextPos = kMarkupPattern.lastIndex = data.length + 1;\n                }\n                else {\n                    lastTextPos = kMarkupPattern.lastIndex = index + closeMarkup.length;\n                    match[1] = 'true';\n                }\n            }\n        }\n        if (match[1] || match[4] || kSelfClosingElements[match[2]]) {\n            // </ or /> or <br> etc.\n            while (true) {\n                if (currentParent.rawTagName === match[2]) {\n                    stack.pop();\n                    currentParent = arr_back(stack);\n                    break;\n                }\n                else {\n                    const tagName = currentParent.tagName;\n                    // Trying to close current tag, and move on\n                    if (kElementsClosedByClosing[tagName]) {\n                        if (kElementsClosedByClosing[tagName][match[2]]) {\n                            stack.pop();\n                            currentParent = arr_back(stack);\n                            continue;\n                        }\n                    }\n                    // Use aggressive strategy to handle unmatching markups.\n                    break;\n                }\n            }\n        }\n    }\n    const valid = Boolean(stack.length === 1);\n    if (!options.noFix) {\n        const response = root;\n        response.valid = valid;\n        while (stack.length > 1) {\n            // Handle each error elements.\n            const last = stack.pop();\n            const oneBefore = arr_back(stack);\n            if (last.parentNode && last.parentNode.parentNode) {\n                if (last.parentNode === oneBefore && last.tagName === oneBefore.tagName) {\n                    // Pair error case <h3> <h3> handle : Fixes to <h3> </h3>\n                    oneBefore.removeChild(last);\n                    last.childNodes.forEach((child) => {\n                        oneBefore.parentNode.appendChild(child);\n                    });\n                    stack.pop();\n                }\n                else {\n                    // Single error  <div> <h3> </div> handle: Just removes <h3>\n                    oneBefore.removeChild(last);\n                    last.childNodes.forEach((child) => {\n                        oneBefore.appendChild(child);\n                    });\n                }\n            }\n            else {\n                // If it's final element just skip.\n            }\n        }\n        response.childNodes.forEach((node) => {\n            if (node instanceof HTMLElement) {\n                node.parentNode = null;\n            }\n        });\n        return response;\n    }\n    const response = new TextNode(data);\n    response.valid = valid;\n    return response;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}