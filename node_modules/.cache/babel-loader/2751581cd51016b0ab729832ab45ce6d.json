{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\nvar _Object$defineProperty = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\nvar _slice = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/slice\"));\nvar _concat = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/concat\"));\nvar _includes = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/includes\"));\n\n/*!\n * XRegExp.matchRecursive 4.4.1\n * <xregexp.com>\n * Steven Levithan (c) 2009-present MIT License\n */\nvar _default = function _default(XRegExp) {\n  /**\n   * Returns a match detail object composed of the provided values.\n   *\n   * @private\n   */\n  function row(name, value, start, end) {\n    return {\n      name: name,\n      value: value,\n      start: start,\n      end: end\n    };\n  }\n  /**\n   * Returns an array of match strings between outermost left and right delimiters, or an array of\n   * objects with detailed match parts and position data. An error is thrown if delimiters are\n   * unbalanced within the data.\n   *\n   * @memberOf XRegExp\n   * @param {String} str String to search.\n   * @param {String} left Left delimiter as an XRegExp pattern.\n   * @param {String} right Right delimiter as an XRegExp pattern.\n   * @param {String} [flags] Any native or XRegExp flags, used for the left and right delimiters.\n   * @param {Object} [options] Lets you specify `valueNames` and `escapeChar` options.\n   * @returns {!Array} Array of matches, or an empty array.\n   * @example\n   *\n   * // Basic usage\n   * let str = '(t((e))s)t()(ing)';\n   * XRegExp.matchRecursive(str, '\\\\(', '\\\\)', 'g');\n   * // -> ['t((e))s', '', 'ing']\n   *\n   * // Extended information mode with valueNames\n   * str = 'Here is <div> <div>an</div></div> example';\n   * XRegExp.matchRecursive(str, '<div\\\\s*>', '</div>', 'gi', {\n   *   valueNames: ['between', 'left', 'match', 'right']\n   * });\n   * // -> [\n   * // {name: 'between', value: 'Here is ',       start: 0,  end: 8},\n   * // {name: 'left',    value: '<div>',          start: 8,  end: 13},\n   * // {name: 'match',   value: ' <div>an</div>', start: 13, end: 27},\n   * // {name: 'right',   value: '</div>',         start: 27, end: 33},\n   * // {name: 'between', value: ' example',       start: 33, end: 41}\n   * // ]\n   *\n   * // Omitting unneeded parts with null valueNames, and using escapeChar\n   * str = '...{1}.\\\\{{function(x,y){return {y:x}}}';\n   * XRegExp.matchRecursive(str, '{', '}', 'g', {\n   *   valueNames: ['literal', null, 'value', null],\n   *   escapeChar: '\\\\'\n   * });\n   * // -> [\n   * // {name: 'literal', value: '...',  start: 0, end: 3},\n   * // {name: 'value',   value: '1',    start: 4, end: 5},\n   * // {name: 'literal', value: '.\\\\{', start: 6, end: 9},\n   * // {name: 'value',   value: 'function(x,y){return {y:x}}', start: 10, end: 37}\n   * // ]\n   *\n   * // Sticky mode via flag y\n   * str = '<1><<<2>>><3>4<5>';\n   * XRegExp.matchRecursive(str, '<', '>', 'gy');\n   * // -> ['1', '<<2>>', '3']\n   */\n\n  XRegExp.matchRecursive = function (str, left, right, flags, options) {\n    flags = flags || '';\n    options = options || {};\n    var global = (0, _includes[\"default\"])(flags).call(flags, 'g');\n    var sticky = (0, _includes[\"default\"])(flags).call(flags, 'y'); // Flag `y` is controlled internally\n\n    var basicFlags = flags.replace(/y/g, '');\n    var _options = options,\n      escapeChar = _options.escapeChar;\n    var vN = options.valueNames;\n    var output = [];\n    var openTokens = 0;\n    var delimStart = 0;\n    var delimEnd = 0;\n    var lastOuterEnd = 0;\n    var outerStart;\n    var innerStart;\n    var leftMatch;\n    var rightMatch;\n    var esc;\n    left = XRegExp(left, basicFlags);\n    right = XRegExp(right, basicFlags);\n    if (escapeChar) {\n      var _context, _context2;\n      if (escapeChar.length > 1) {\n        throw new Error('Cannot use more than one escape character');\n      }\n      escapeChar = XRegExp.escape(escapeChar); // Example of concatenated `esc` regex:\n      // `escapeChar`: '%'\n      // `left`: '<'\n      // `right`: '>'\n      // Regex is: /(?:%[\\S\\s]|(?:(?!<|>)[^%])+)+/\n\n      esc = new RegExp((0, _concat[\"default\"])(_context = (0, _concat[\"default\"])(_context2 = \"(?:\".concat(escapeChar, \"[\\\\S\\\\s]|(?:(?!\")).call(_context2,\n      // Using `XRegExp.union` safely rewrites backreferences in `left` and `right`.\n      // Intentionally not passing `basicFlags` to `XRegExp.union` since any syntax\n      // transformation resulting from those flags was already applied to `left` and\n      // `right` when they were passed through the XRegExp constructor above.\n      XRegExp.union([left, right], '', {\n        conjunction: 'or'\n      }).source, \")[^\")).call(_context, escapeChar, \"])+)+\"),\n      // Flags `gy` not needed here\n      flags.replace(/[^imu]+/g, ''));\n    }\n    while (true) {\n      // If using an escape character, advance to the delimiter's next starting position,\n      // skipping any escaped characters in between\n      if (escapeChar) {\n        delimEnd += (XRegExp.exec(str, esc, delimEnd, 'sticky') || [''])[0].length;\n      }\n      leftMatch = XRegExp.exec(str, left, delimEnd);\n      rightMatch = XRegExp.exec(str, right, delimEnd); // Keep the leftmost match only\n\n      if (leftMatch && rightMatch) {\n        if (leftMatch.index <= rightMatch.index) {\n          rightMatch = null;\n        } else {\n          leftMatch = null;\n        }\n      } // Paths (LM: leftMatch, RM: rightMatch, OT: openTokens):\n      // LM | RM | OT | Result\n      // 1  | 0  | 1  | loop\n      // 1  | 0  | 0  | loop\n      // 0  | 1  | 1  | loop\n      // 0  | 1  | 0  | throw\n      // 0  | 0  | 1  | throw\n      // 0  | 0  | 0  | break\n      // The paths above don't include the sticky mode special case. The loop ends after the\n      // first completed match if not `global`.\n\n      if (leftMatch || rightMatch) {\n        delimStart = (leftMatch || rightMatch).index;\n        delimEnd = delimStart + (leftMatch || rightMatch)[0].length;\n      } else if (!openTokens) {\n        break;\n      }\n      if (sticky && !openTokens && delimStart > lastOuterEnd) {\n        break;\n      }\n      if (leftMatch) {\n        if (!openTokens) {\n          outerStart = delimStart;\n          innerStart = delimEnd;\n        }\n        ++openTokens;\n      } else if (rightMatch && openTokens) {\n        if (! --openTokens) {\n          if (vN) {\n            if (vN[0] && outerStart > lastOuterEnd) {\n              output.push(row(vN[0], (0, _slice[\"default\"])(str).call(str, lastOuterEnd, outerStart), lastOuterEnd, outerStart));\n            }\n            if (vN[1]) {\n              output.push(row(vN[1], (0, _slice[\"default\"])(str).call(str, outerStart, innerStart), outerStart, innerStart));\n            }\n            if (vN[2]) {\n              output.push(row(vN[2], (0, _slice[\"default\"])(str).call(str, innerStart, delimStart), innerStart, delimStart));\n            }\n            if (vN[3]) {\n              output.push(row(vN[3], (0, _slice[\"default\"])(str).call(str, delimStart, delimEnd), delimStart, delimEnd));\n            }\n          } else {\n            output.push((0, _slice[\"default\"])(str).call(str, innerStart, delimStart));\n          }\n          lastOuterEnd = delimEnd;\n          if (!global) {\n            break;\n          }\n        }\n      } else {\n        throw new Error('Unbalanced delimiter found in string');\n      } // If the delimiter matched an empty string, avoid an infinite loop\n\n      if (delimStart === delimEnd) {\n        ++delimEnd;\n      }\n    }\n    if (global && !sticky && vN && vN[0] && str.length > lastOuterEnd) {\n      output.push(row(vN[0], (0, _slice[\"default\"])(str).call(str, lastOuterEnd), lastOuterEnd, str.length));\n    }\n    return output;\n  };\n};\nexports[\"default\"] = _default;\nmodule.exports = exports.default;","map":{"version":3,"names":["_interopRequireDefault","require","_Object$defineProperty","exports","value","_slice","_concat","_includes","_default","XRegExp","row","name","start","end","matchRecursive","str","left","right","flags","options","global","call","sticky","basicFlags","replace","_options","escapeChar","vN","valueNames","output","openTokens","delimStart","delimEnd","lastOuterEnd","outerStart","innerStart","leftMatch","rightMatch","esc","_context","_context2","length","Error","escape","RegExp","concat","union","conjunction","source","exec","index","push","module","default"],"sources":["D:/Dapp/Clients/site-builder/grapesJs/node_modules/xregexp/lib/addons/matchrecursive.js"],"sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports[\"default\"] = void 0;\n\nvar _slice = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/slice\"));\n\nvar _concat = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/concat\"));\n\nvar _includes = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/includes\"));\n\n/*!\n * XRegExp.matchRecursive 4.4.1\n * <xregexp.com>\n * Steven Levithan (c) 2009-present MIT License\n */\nvar _default = function _default(XRegExp) {\n  /**\n   * Returns a match detail object composed of the provided values.\n   *\n   * @private\n   */\n  function row(name, value, start, end) {\n    return {\n      name: name,\n      value: value,\n      start: start,\n      end: end\n    };\n  }\n  /**\n   * Returns an array of match strings between outermost left and right delimiters, or an array of\n   * objects with detailed match parts and position data. An error is thrown if delimiters are\n   * unbalanced within the data.\n   *\n   * @memberOf XRegExp\n   * @param {String} str String to search.\n   * @param {String} left Left delimiter as an XRegExp pattern.\n   * @param {String} right Right delimiter as an XRegExp pattern.\n   * @param {String} [flags] Any native or XRegExp flags, used for the left and right delimiters.\n   * @param {Object} [options] Lets you specify `valueNames` and `escapeChar` options.\n   * @returns {!Array} Array of matches, or an empty array.\n   * @example\n   *\n   * // Basic usage\n   * let str = '(t((e))s)t()(ing)';\n   * XRegExp.matchRecursive(str, '\\\\(', '\\\\)', 'g');\n   * // -> ['t((e))s', '', 'ing']\n   *\n   * // Extended information mode with valueNames\n   * str = 'Here is <div> <div>an</div></div> example';\n   * XRegExp.matchRecursive(str, '<div\\\\s*>', '</div>', 'gi', {\n   *   valueNames: ['between', 'left', 'match', 'right']\n   * });\n   * // -> [\n   * // {name: 'between', value: 'Here is ',       start: 0,  end: 8},\n   * // {name: 'left',    value: '<div>',          start: 8,  end: 13},\n   * // {name: 'match',   value: ' <div>an</div>', start: 13, end: 27},\n   * // {name: 'right',   value: '</div>',         start: 27, end: 33},\n   * // {name: 'between', value: ' example',       start: 33, end: 41}\n   * // ]\n   *\n   * // Omitting unneeded parts with null valueNames, and using escapeChar\n   * str = '...{1}.\\\\{{function(x,y){return {y:x}}}';\n   * XRegExp.matchRecursive(str, '{', '}', 'g', {\n   *   valueNames: ['literal', null, 'value', null],\n   *   escapeChar: '\\\\'\n   * });\n   * // -> [\n   * // {name: 'literal', value: '...',  start: 0, end: 3},\n   * // {name: 'value',   value: '1',    start: 4, end: 5},\n   * // {name: 'literal', value: '.\\\\{', start: 6, end: 9},\n   * // {name: 'value',   value: 'function(x,y){return {y:x}}', start: 10, end: 37}\n   * // ]\n   *\n   * // Sticky mode via flag y\n   * str = '<1><<<2>>><3>4<5>';\n   * XRegExp.matchRecursive(str, '<', '>', 'gy');\n   * // -> ['1', '<<2>>', '3']\n   */\n\n\n  XRegExp.matchRecursive = function (str, left, right, flags, options) {\n    flags = flags || '';\n    options = options || {};\n    var global = (0, _includes[\"default\"])(flags).call(flags, 'g');\n    var sticky = (0, _includes[\"default\"])(flags).call(flags, 'y'); // Flag `y` is controlled internally\n\n    var basicFlags = flags.replace(/y/g, '');\n    var _options = options,\n        escapeChar = _options.escapeChar;\n    var vN = options.valueNames;\n    var output = [];\n    var openTokens = 0;\n    var delimStart = 0;\n    var delimEnd = 0;\n    var lastOuterEnd = 0;\n    var outerStart;\n    var innerStart;\n    var leftMatch;\n    var rightMatch;\n    var esc;\n    left = XRegExp(left, basicFlags);\n    right = XRegExp(right, basicFlags);\n\n    if (escapeChar) {\n      var _context, _context2;\n\n      if (escapeChar.length > 1) {\n        throw new Error('Cannot use more than one escape character');\n      }\n\n      escapeChar = XRegExp.escape(escapeChar); // Example of concatenated `esc` regex:\n      // `escapeChar`: '%'\n      // `left`: '<'\n      // `right`: '>'\n      // Regex is: /(?:%[\\S\\s]|(?:(?!<|>)[^%])+)+/\n\n      esc = new RegExp((0, _concat[\"default\"])(_context = (0, _concat[\"default\"])(_context2 = \"(?:\".concat(escapeChar, \"[\\\\S\\\\s]|(?:(?!\")).call(_context2, // Using `XRegExp.union` safely rewrites backreferences in `left` and `right`.\n      // Intentionally not passing `basicFlags` to `XRegExp.union` since any syntax\n      // transformation resulting from those flags was already applied to `left` and\n      // `right` when they were passed through the XRegExp constructor above.\n      XRegExp.union([left, right], '', {\n        conjunction: 'or'\n      }).source, \")[^\")).call(_context, escapeChar, \"])+)+\"), // Flags `gy` not needed here\n      flags.replace(/[^imu]+/g, ''));\n    }\n\n    while (true) {\n      // If using an escape character, advance to the delimiter's next starting position,\n      // skipping any escaped characters in between\n      if (escapeChar) {\n        delimEnd += (XRegExp.exec(str, esc, delimEnd, 'sticky') || [''])[0].length;\n      }\n\n      leftMatch = XRegExp.exec(str, left, delimEnd);\n      rightMatch = XRegExp.exec(str, right, delimEnd); // Keep the leftmost match only\n\n      if (leftMatch && rightMatch) {\n        if (leftMatch.index <= rightMatch.index) {\n          rightMatch = null;\n        } else {\n          leftMatch = null;\n        }\n      } // Paths (LM: leftMatch, RM: rightMatch, OT: openTokens):\n      // LM | RM | OT | Result\n      // 1  | 0  | 1  | loop\n      // 1  | 0  | 0  | loop\n      // 0  | 1  | 1  | loop\n      // 0  | 1  | 0  | throw\n      // 0  | 0  | 1  | throw\n      // 0  | 0  | 0  | break\n      // The paths above don't include the sticky mode special case. The loop ends after the\n      // first completed match if not `global`.\n\n\n      if (leftMatch || rightMatch) {\n        delimStart = (leftMatch || rightMatch).index;\n        delimEnd = delimStart + (leftMatch || rightMatch)[0].length;\n      } else if (!openTokens) {\n        break;\n      }\n\n      if (sticky && !openTokens && delimStart > lastOuterEnd) {\n        break;\n      }\n\n      if (leftMatch) {\n        if (!openTokens) {\n          outerStart = delimStart;\n          innerStart = delimEnd;\n        }\n\n        ++openTokens;\n      } else if (rightMatch && openTokens) {\n        if (! --openTokens) {\n          if (vN) {\n            if (vN[0] && outerStart > lastOuterEnd) {\n              output.push(row(vN[0], (0, _slice[\"default\"])(str).call(str, lastOuterEnd, outerStart), lastOuterEnd, outerStart));\n            }\n\n            if (vN[1]) {\n              output.push(row(vN[1], (0, _slice[\"default\"])(str).call(str, outerStart, innerStart), outerStart, innerStart));\n            }\n\n            if (vN[2]) {\n              output.push(row(vN[2], (0, _slice[\"default\"])(str).call(str, innerStart, delimStart), innerStart, delimStart));\n            }\n\n            if (vN[3]) {\n              output.push(row(vN[3], (0, _slice[\"default\"])(str).call(str, delimStart, delimEnd), delimStart, delimEnd));\n            }\n          } else {\n            output.push((0, _slice[\"default\"])(str).call(str, innerStart, delimStart));\n          }\n\n          lastOuterEnd = delimEnd;\n\n          if (!global) {\n            break;\n          }\n        }\n      } else {\n        throw new Error('Unbalanced delimiter found in string');\n      } // If the delimiter matched an empty string, avoid an infinite loop\n\n\n      if (delimStart === delimEnd) {\n        ++delimEnd;\n      }\n    }\n\n    if (global && !sticky && vN && vN[0] && str.length > lastOuterEnd) {\n      output.push(row(vN[0], (0, _slice[\"default\"])(str).call(str, lastOuterEnd), lastOuterEnd, str.length));\n    }\n\n    return output;\n  };\n};\n\nexports[\"default\"] = _default;\nmodule.exports = exports.default;"],"mappings":"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"},"metadata":{},"sourceType":"script"}