{"ast":null,"code":"import{each,isString}from'underscore';import{parse as nodeHtmlParser}from\"node-html-parser\";import XRegExp from\"xregexp\";window.nodeHtmlParser=nodeHtmlParser;/**\r\n * Parses an HTML string into its HTML and CSS component representation keeping case of tags and attributes. This\r\n * is necessary in case you want React compatible JSX tags in the template, in which case the react components must start\r\n * wih uppercase and also the camel casing of attributes is importane (ie. className vs classname)\r\n *\r\n * This function is based on src/parser/model/ParserHtml.js. For parsing we are using node-html-parser instead of\r\n * the browser's DOM to keep the case of tags and attributes. The code is mostly the same  as in ParserHtml.js\r\n * by maing the objects created by  node-html-parser compatible with the DOM representation.\r\n *\r\n * @param config usual grapesjs config\r\n * @returns parser function\r\n */export default(function(config){var TEXT_NODE='span';var c=config;var modelAttrStart='data-gjs-';return{compTypes:'',modelAttrStart:modelAttrStart,/**\r\n         * Extract component props from an attribute object\r\n         * @param {Object} attr\r\n         * @returns {Object} An object containing props and attributes without them\r\n         */splitPropsFromAttr:function splitPropsFromAttr(){var _this=this;var attr=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};var props={};var attrs={};each(attr,function(value,key){if(key.indexOf(_this.modelAttrStart)===0){var modelAttr=key.replace(modelAttrStart,'');var valueLen=value.length;var valStr=value&&isString(value);var firstChar=valStr&&value.substr(0,1);var lastChar=valStr&&value.substr(valueLen-1);value=value==='true'?true:value;value=value==='false'?false:value;// Try to parse JSON where it's possible\n// I can get false positive here (eg. a selector '[data-attr]')\n// so put it under try/catch and let fail silently\ntry{value=firstChar=='{'&&lastChar=='}'||firstChar=='['&&lastChar==']'?JSON.parse(value):value;}catch(e){}props[modelAttr]=value;}else{attrs[key]=value;}});return{props:props,attrs:attrs};},/**\r\n         * Given a string with html (jsx). Attributes having JSX expressions will be quoted to look like\r\n         * actual HTML attributes\r\n         * @param {*} html\r\n         * @return html with quoted JSX attributes\r\n         *\r\n         * https://stackoverflow.com/questions/546433/regular-expression-to-match-balanced-parentheses\r\n         */quoteJsxExpresionsInAttributes:function quoteJsxExpresionsInAttributes(html){var found=XRegExp.matchRecursive(html,\"{\",\"}\",\"g\");for(var i=0;i<found.length;i++){// (value) => \\`\\${(value) => < 10 ? \\`0\\${value}\\` : value)}\\`\n// --> {(value) => \\`\\${(value) => < 10 ? \\`0\\${value}\\` : value)}\\`}\nvar pattern=\"{\"+found[i]+\"}\";var lastStartPos=0;// Find pattern until we reach and of html\nwhile(true){var needsQuote=false;// get next match position\nvar matchPos=html.indexOf(pattern,lastStartPos);if(matchPos===-1){break;}// We will look back 1 and 2 characters\nvar oneCharBeforePos=matchPos-1;var twoCharBeforePos=matchPos-2;if(twoCharBeforePos>0&&oneCharBeforePos>0){// Need to quote if have sg like this:\n//   formatValue={(value) => \\`\\${(value) => < 10 ? \\`0\\${value}\\` : value)}\\`}\n// (ie: if patterns comes atfre and equals sime, but not =\")\n// But no need to quote if:\n//    formatValue=\"{(value) => \\`\\${(value) => < 10 ? \\`0\\${value}\\` : value)}\\`}\"\n//    <Timer.Days/>{this.model.attributes.displayLabels ? \" \"+this.model.attributes.labels.labelDays+\" \" : ', '}\nneedsQuote=html.substring(twoCharBeforePos,twoCharBeforePos+2)!=='=\"'&&html.substring(oneCharBeforePos,oneCharBeforePos+1)===\"=\";}// If need to quote: replace patterns with quoted version also escaping some HTML entities\nif(needsQuote){var replacement='\"{'+found[i].replace(\"<\",\"&lt;\").replace(\">\",\"&gt;\").replace(\"&\",\"&amp;\")+'}\"';html=html.replace(pattern,replacement);lastStartPos=matchPos+replacement.length;}else{lastStartPos=matchPos+pattern.length;}// No lastStartPos placed after the processed string\n}}return html;},/**\r\n         * Unquote attributes containg JSX previously quoted using quoteJsxExpresionsInAttributes\r\n         * @param html\r\n         */unquoteJsxExpresionsInAttributes:function unquoteJsxExpresionsInAttributes(html){var found=html.match(/=[\"']{.*}[\"']/g);if(!found){return html;}for(var i=0;i<found.length;i++){var pattern=found[i];var replacement=pattern.startsWith('=\"{')?pattern.replace('\"{',\"{\").replace('}\"',\"}\"):pattern.replace(\"{'\",\"{\").replace(\"}'\",\"}\");replacement=replacement.replace(\"&lt;\",\"<\").replace(\"&gt;\",\">\").replace(\"&amp;\",\"&\");html=html.replace(pattern,replacement);}return html;},/**\r\n         * Parse style string to object\r\n         * @param {string} str\r\n         * @return {Object}\r\n         * @example\r\n         * var stl = ParserHtml.parseStyle('color:black; width:100px; test:value;');\r\n         * console.log(stl);\r\n         * // {color: 'black', width: '100px', test: 'value'}\r\n         */parseStyle:function parseStyle(str){var result={};var decls=str.split(';');for(var i=0,len=decls.length;i<len;i++){var decl=decls[i].trim();if(!decl)continue;var prop=decl.split(':');result[prop[0].trim()]=prop.slice(1).join(':').trim();}return result;},/**\r\n         * Parse class string to array\r\n         * @param {string} str\r\n         * @return {Array<string>}\r\n         * @example\r\n         * var res = ParserHtml.parseClass('test1 test2 test3');\r\n         * console.log(res);\r\n         * // ['test1', 'test2', 'test3']\r\n         */parseClass:function parseClass(str){var result=[];var cls=str.split(' ');for(var i=0,len=cls.length;i<len;i++){var cl=cls[i].trim();if(!cl)continue;result.push(cl);}return result;},toAttrArray:function toAttrArray(obj){var attrArr=[];Object.keys(obj).map(function(key){attrArr.push({'nodeName':key,'nodeValue':obj[key]});});return attrArr;},/**\r\n         * Get data from the node element\r\n         * @param  {HTMLElement} el DOM element to traverse\r\n         * @return {Array<Object>}\r\n         */parseNode:function parseNode(el){var result=[];var nodes=el.childNodes;for(var i=0,len=nodes.length;i<len;i++){var node=nodes[i];// DOM copmatibility\nnode.nodeValue=node.rawText;node.content=node.rawText;// Make attrs compatible with DOM representation\nvar attrs=[];attrs=(typeof node.attributes=='object'?this.toAttrArray(node.attributes):node.attributes)||[];var attrsLen=attrs.length;var nodePrev=result[result.length-1];var nodeChild=node.childNodes.length;var ct=this.compTypes;var model={};if(ct){var obj='';var type=node.getAttribute&&node.getAttribute(\"\".concat(modelAttrStart,\"type\"));if(!type){type=node.attributes&&node.attributes[\"\".concat(modelAttrStart,\"type\")];}if(type){model={type:type};}else{for(var it=0;it<ct.length;it++){var compType=ct[it];obj=compType.model.isComponent(node);if(obj){if(typeof obj!=='object'){obj={type:compType.id};}break;}}model=obj;}}model.tagName=node.tagName;if(attrsLen){model.attributes={};}for(var j=0;j<attrsLen;j++){var nodeName=attrs[j].nodeName;var nodeValue=attrs[j].nodeValue;// if (nodeName == \"formatValue\") {\n//     debugger;\n// }\n// Isolate attributes\nif(nodeName=='style'){model.style=this.parseStyle(nodeValue);}else if(nodeName=='class'){model.classes=this.parseClass(nodeValue);}else if(nodeName=='contenteditable'){continue;}else if(nodeName.indexOf(modelAttrStart)===0){var modelAttr=nodeName.replace(modelAttrStart,'');var valueLen=nodeValue.length;var firstChar=nodeValue&&nodeValue.substr(0,1);var lastChar=nodeValue&&nodeValue.substr(valueLen-1);nodeValue=nodeValue==='true'?true:nodeValue;nodeValue=nodeValue==='false'?false:nodeValue;try{nodeValue=firstChar=='{'&&lastChar=='}'||firstChar=='['&&lastChar==']'?JSON.parse(nodeValue):nodeValue;}catch(e){}model[modelAttr]=nodeValue;}else{model.attributes[nodeName]=nodeValue;}}if(nodeChild&&!model.components){var firstChild=node.childNodes[0];firstChild.nodeValue=firstChild.rawText;if(nodeChild===1&&firstChild.nodeType===3){!model.type&&(model.type='text');model.content=firstChild.nodeValue;}else{model.components=this.parseNode(node);}}if(model.type=='textnode'){model.content=node.nodeValue;if(nodePrev&&nodePrev.type=='textnode'){nodePrev.content+=model.content;continue;}if(!config.keepEmptyTextNodes){var content=node.nodeValue;if(content!=' '&&!content.trim()){continue;}}}var comps=model.components;if(!model.type&&comps){var allTxt=1;var foundTextNode=0;for(var ci=0;ci<comps.length;ci++){var comp=comps[ci];var cType=comp.type;if(['text','textnode'].indexOf(cType)<0&&c.textTags.indexOf(comp.tagName)<0){allTxt=0;break;}if(cType=='textnode'){foundTextNode=1;}}if(allTxt&&foundTextNode){model.type='text';}}if(!model.tagName&&model.type!='textnode'){continue;}result.push(model);}return result;},/**\r\n         * Parse HTML string to a desired model object\r\n         * @param  {string} str HTML string\r\n         * @param  {ParserCss} parserCss In case there is style tags inside HTML\r\n         * @return {Object}\r\n         *\r\n         */parse:function parse(str,parserCss){console.log(\"html\",str,parserCss);var config=c.em&&c.em.get('Config')||{};var res={html:'',css:''};var quoted=this.quoteJsxExpresionsInAttributes(str);var wrappedInDiv=false;if(!quoted.startsWith('<')){quoted='<div>'+quoted+'</div>';wrappedInDiv=true;}var dom=nodeHtmlParser(quoted);var result=this.parseNode(dom);if(result.length==1){result=result[0];}if(wrappedInDiv){if(result.components){result=result.components;}else{delete result.tagName;result.type=\"textnode\";}}res.html=result;if(parserCss){var el=document.createElement('div');el.innerHTML=str;var styleStr='';var styles=el.querySelectorAll('style');var j=styles.length;while(j--){styleStr=styles[j].innerHTML+styleStr;styles[j].parentNode.removeChild(styles[j]);}if(styleStr)res.css=parserCss.parse(styleStr);}return res;}};});","map":{"version":3,"names":["each","isString","parse","nodeHtmlParser","XRegExp","window","config","TEXT_NODE","c","modelAttrStart","compTypes","splitPropsFromAttr","_this","attr","arguments","length","undefined","props","attrs","value","key","indexOf","modelAttr","replace","valueLen","valStr","firstChar","substr","lastChar","JSON","e","quoteJsxExpresionsInAttributes","html","found","matchRecursive","i","pattern","lastStartPos","needsQuote","matchPos","oneCharBeforePos","twoCharBeforePos","substring","replacement","unquoteJsxExpresionsInAttributes","match","startsWith","parseStyle","str","result","decls","split","len","decl","trim","prop","slice","join","parseClass","cls","cl","push","toAttrArray","obj","attrArr","Object","keys","map","parseNode","el","nodes","childNodes","node","nodeValue","rawText","content","attributes","attrsLen","nodePrev","nodeChild","ct","model","type","getAttribute","concat","it","compType","isComponent","id","tagName","j","nodeName","style","classes","components","firstChild","nodeType","keepEmptyTextNodes","comps","allTxt","foundTextNode","ci","comp","cType","textTags","parserCss","console","log","em","get","res","css","quoted","wrappedInDiv","dom","document","createElement","innerHTML","styleStr","styles","querySelectorAll","parentNode","removeChild"],"sources":["D:/Dapp/Clients/site-builder/grapesJs/src/Table/ParserHtmlCaseSensitive.js"],"sourcesContent":["import { each, isString } from 'underscore';\r\nimport { parse as nodeHtmlParser } from \"node-html-parser\";\r\nimport XRegExp from \"xregexp\";\r\n\r\nwindow.nodeHtmlParser = nodeHtmlParser;\r\n\r\n/**\r\n * Parses an HTML string into its HTML and CSS component representation keeping case of tags and attributes. This\r\n * is necessary in case you want React compatible JSX tags in the template, in which case the react components must start\r\n * wih uppercase and also the camel casing of attributes is importane (ie. className vs classname)\r\n *\r\n * This function is based on src/parser/model/ParserHtml.js. For parsing we are using node-html-parser instead of\r\n * the browser's DOM to keep the case of tags and attributes. The code is mostly the same  as in ParserHtml.js\r\n * by maing the objects created by  node-html-parser compatible with the DOM representation.\r\n *\r\n * @param config usual grapesjs config\r\n * @returns parser function\r\n */\r\nexport default config => {\r\n    var TEXT_NODE = 'span';\r\n    var c = config;\r\n    var modelAttrStart = 'data-gjs-';\r\n\r\n    return {\r\n        compTypes: '',\r\n\r\n        modelAttrStart,\r\n\r\n        /**\r\n         * Extract component props from an attribute object\r\n         * @param {Object} attr\r\n         * @returns {Object} An object containing props and attributes without them\r\n         */\r\n        splitPropsFromAttr(attr = {}) {\r\n            const props = {};\r\n            const attrs = {};\r\n\r\n            each(attr, (value, key) => {\r\n                if (key.indexOf(this.modelAttrStart) === 0) {\r\n                    const modelAttr = key.replace(modelAttrStart, '');\r\n                    const valueLen = value.length;\r\n                    const valStr = value && isString(value);\r\n                    const firstChar = valStr && value.substr(0, 1);\r\n                    const lastChar = valStr && value.substr(valueLen - 1);\r\n                    value = value === 'true' ? true : value;\r\n                    value = value === 'false' ? false : value;\r\n\r\n                    // Try to parse JSON where it's possible\r\n                    // I can get false positive here (eg. a selector '[data-attr]')\r\n                    // so put it under try/catch and let fail silently\r\n                    try {\r\n                        value =\r\n                            (firstChar == '{' && lastChar == '}') ||\r\n                            (firstChar == '[' && lastChar == ']')\r\n                                ? JSON.parse(value)\r\n                                : value;\r\n                    } catch (e) {}\r\n\r\n                    props[modelAttr] = value;\r\n                } else {\r\n                    attrs[key] = value;\r\n                }\r\n            });\r\n\r\n            return {\r\n                props,\r\n                attrs\r\n            };\r\n        },\r\n\r\n        /**\r\n         * Given a string with html (jsx). Attributes having JSX expressions will be quoted to look like\r\n         * actual HTML attributes\r\n         * @param {*} html\r\n         * @return html with quoted JSX attributes\r\n         *\r\n         * https://stackoverflow.com/questions/546433/regular-expression-to-match-balanced-parentheses\r\n         */\r\n        quoteJsxExpresionsInAttributes(html) {\r\n            let found = XRegExp.matchRecursive(html, \"{\", \"}\", \"g\");\r\n            for (let i = 0; i < found.length; i++) {\r\n                // (value) => \\`\\${(value) => < 10 ? \\`0\\${value}\\` : value)}\\`\r\n                // --> {(value) => \\`\\${(value) => < 10 ? \\`0\\${value}\\` : value)}\\`}\r\n                let pattern = \"{\" + found[i] + \"}\";\r\n                let lastStartPos = 0;\r\n                // Find pattern until we reach and of html\r\n                while (true) {\r\n                    let needsQuote = false;\r\n                    // get next match position\r\n                    let matchPos = html.indexOf(pattern, lastStartPos);\r\n                    if (matchPos === -1) {\r\n                        break;\r\n                    }\r\n                    // We will look back 1 and 2 characters\r\n                    let oneCharBeforePos = matchPos - 1;\r\n                    let twoCharBeforePos = matchPos - 2;\r\n                    if (twoCharBeforePos > 0 && oneCharBeforePos > 0) {\r\n                        // Need to quote if have sg like this:\r\n                        //   formatValue={(value) => \\`\\${(value) => < 10 ? \\`0\\${value}\\` : value)}\\`}\r\n                        // (ie: if patterns comes atfre and equals sime, but not =\")\r\n                        // But no need to quote if:\r\n                        //    formatValue=\"{(value) => \\`\\${(value) => < 10 ? \\`0\\${value}\\` : value)}\\`}\"\r\n                        //    <Timer.Days/>{this.model.attributes.displayLabels ? \" \"+this.model.attributes.labels.labelDays+\" \" : ', '}\r\n                        needsQuote =\r\n                            html.substring(twoCharBeforePos, twoCharBeforePos + 2) !== '=\"' &&\r\n                            html.substring(oneCharBeforePos, oneCharBeforePos + 1) === \"=\";\r\n                    }\r\n\r\n                    // If need to quote: replace patterns with quoted version also escaping some HTML entities\r\n                    if (needsQuote) {\r\n                        let replacement =\r\n                            '\"{' +\r\n                            found[i]\r\n                                .replace(\"<\", \"&lt;\")\r\n                                .replace(\">\", \"&gt;\")\r\n                                .replace(\"&\", \"&amp;\")\r\n                            + '}\"';\r\n                        html = html.replace(pattern, replacement);\r\n                        lastStartPos = matchPos + replacement.length;\r\n                    } else {\r\n                        lastStartPos = matchPos + pattern.length;\r\n                    }\r\n\r\n                    // No lastStartPos placed after the processed string\r\n                }\r\n            }\r\n            return html;\r\n        },\r\n\r\n\r\n\r\n        /**\r\n         * Unquote attributes containg JSX previously quoted using quoteJsxExpresionsInAttributes\r\n         * @param html\r\n         */\r\n        unquoteJsxExpresionsInAttributes(html) {\r\n            let found = html.match(/=[\"']{.*}[\"']/g);\r\n            if (!found) {\r\n                return html;\r\n            }\r\n            for (let i = 0; i < found.length; i++) {\r\n                let pattern = found[i];\r\n                let replacement = pattern.startsWith('=\"{')\r\n                    ? pattern.replace('\"{', \"{\").replace('}\"', \"}\")\r\n                    : pattern.replace(\"{'\", \"{\").replace(\"}'\", \"}\");\r\n                replacement = replacement\r\n                    .replace(\"&lt;\", \"<\")\r\n                    .replace(\"&gt;\", \">\")\r\n                    .replace(\"&amp;\", \"&\");\r\n                html = html.replace(pattern, replacement);\r\n            }\r\n            return html;\r\n        },\r\n\r\n\r\n        /**\r\n         * Parse style string to object\r\n         * @param {string} str\r\n         * @return {Object}\r\n         * @example\r\n         * var stl = ParserHtml.parseStyle('color:black; width:100px; test:value;');\r\n         * console.log(stl);\r\n         * // {color: 'black', width: '100px', test: 'value'}\r\n         */\r\n        parseStyle(str) {\r\n            var result = {};\r\n            var decls = str.split(';');\r\n            for (var i = 0, len = decls.length; i < len; i++) {\r\n                var decl = decls[i].trim();\r\n                if (!decl) continue;\r\n                var prop = decl.split(':');\r\n                result[prop[0].trim()] = prop\r\n                    .slice(1)\r\n                    .join(':')\r\n                    .trim();\r\n            }\r\n            return result;\r\n        },\r\n\r\n        /**\r\n         * Parse class string to array\r\n         * @param {string} str\r\n         * @return {Array<string>}\r\n         * @example\r\n         * var res = ParserHtml.parseClass('test1 test2 test3');\r\n         * console.log(res);\r\n         * // ['test1', 'test2', 'test3']\r\n         */\r\n        parseClass(str) {\r\n            const result = [];\r\n            const cls = str.split(' ');\r\n            for (let i = 0, len = cls.length; i < len; i++) {\r\n                const cl = cls[i].trim();\r\n                if (!cl) continue;\r\n                result.push(cl);\r\n            }\r\n            return result;\r\n        },\r\n\r\n        toAttrArray(obj){\r\n            var attrArr = [];\r\n            Object.keys(obj).map(key => {\r\n                attrArr.push({'nodeName':key, 'nodeValue':obj[key]})\r\n            })\r\n            return attrArr;\r\n        },\r\n\r\n        /**\r\n         * Get data from the node element\r\n         * @param  {HTMLElement} el DOM element to traverse\r\n         * @return {Array<Object>}\r\n         */\r\n        parseNode(el) {\r\n            const result = [];\r\n            const nodes = el.childNodes;\r\n\r\n            for (var i = 0, len = nodes.length; i < len; i++) {\r\n                const node = nodes[i];\r\n\r\n                // DOM copmatibility\r\n                node.nodeValue = node.rawText;\r\n                node.content = node.rawText;\r\n\r\n                // Make attrs compatible with DOM representation\r\n                let attrs = [];\r\n                    attrs = (typeof node.attributes == 'object'\r\n                        ? this.toAttrArray(node.attributes)\r\n                        :  node.attributes)\r\n                        || []\r\n                    const attrsLen = attrs.length;\r\n                const nodePrev = result[result.length - 1];\r\n                const nodeChild = node.childNodes.length;\r\n                const ct = this.compTypes;\r\n                let model = {};\r\n\r\n                if (ct) {\r\n                    let obj = '';\r\n                    let type =\r\n                        node.getAttribute && node.getAttribute(`${modelAttrStart}type`);\r\n                    if (!type) {\r\n                        type = node.attributes && node.attributes[`${modelAttrStart}type`];\r\n                    }\r\n\r\n                    if (type) {\r\n                        model = { type };\r\n                    } else {\r\n                       \r\n                        for (let it = 0; it < ct.length; it++) {\r\n                            const compType = ct[it];\r\n                            obj = compType.model.isComponent(node);\r\n\r\n                            if (obj) {\r\n                                if (typeof obj !== 'object') {\r\n                                    obj = { type: compType.id };\r\n                                }\r\n                                break;\r\n                            }\r\n                        }\r\n\r\n                        model = obj;\r\n                    }\r\n                }\r\n\r\n                model.tagName = node.tagName;\r\n\r\n                if (attrsLen) {\r\n                    model.attributes = {};\r\n                }\r\n\r\n                for (let j = 0; j < attrsLen; j++) {\r\n                    const nodeName = attrs[j].nodeName;\r\n                    let nodeValue = attrs[j].nodeValue;\r\n                    // if (nodeName == \"formatValue\") {\r\n                    //     debugger;\r\n                    // }\r\n\r\n                    // Isolate attributes\r\n                    if (nodeName == 'style') {\r\n                        model.style = this.parseStyle(nodeValue);\r\n                    } else if (nodeName == 'class') {\r\n                        model.classes = this.parseClass(nodeValue);\r\n                    } else if (nodeName == 'contenteditable') {\r\n                        continue;\r\n                    } else if (nodeName.indexOf(modelAttrStart) === 0) {\r\n                        const modelAttr = nodeName.replace(modelAttrStart, '');\r\n                        const valueLen = nodeValue.length;\r\n                        const firstChar = nodeValue && nodeValue.substr(0, 1);\r\n                        const lastChar = nodeValue && nodeValue.substr(valueLen - 1);\r\n                        nodeValue = nodeValue === 'true' ? true : nodeValue;\r\n                        nodeValue = nodeValue === 'false' ? false : nodeValue;\r\n\r\n                      \r\n                        try {\r\n                            nodeValue =\r\n                                (firstChar == '{' && lastChar == '}') ||\r\n                                (firstChar == '[' && lastChar == ']')\r\n                                    ? JSON.parse(nodeValue)\r\n                                    : nodeValue;\r\n                        } catch (e) {}\r\n\r\n                        model[modelAttr] = nodeValue;\r\n                    } else {\r\n                        model.attributes[nodeName] = nodeValue;\r\n                    }\r\n                }\r\n\r\n                if (nodeChild && !model.components) {\r\n                    const firstChild = node.childNodes[0];\r\n                    firstChild.nodeValue = firstChild.rawText;\r\n\r\n                    if (nodeChild === 1 && firstChild.nodeType === 3) {\r\n                        !model.type && (model.type = 'text');\r\n                        model.content = firstChild.nodeValue;\r\n                    } else {\r\n                        model.components = this.parseNode(node);\r\n                    }\r\n                }\r\n\r\n                if (model.type == 'textnode') {\r\n                    model.content = node.nodeValue;\r\n\r\n                    if (nodePrev && nodePrev.type == 'textnode') {\r\n                        nodePrev.content += model.content;\r\n                        continue;\r\n                    }\r\n\r\n                    if (!config.keepEmptyTextNodes) {\r\n                        const content = node.nodeValue;\r\n                        if (content != ' ' && !content.trim()) {\r\n                            continue;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                \r\n                const comps = model.components;\r\n                if (!model.type && comps) {\r\n                    let allTxt = 1;\r\n                    let foundTextNode = 0;\r\n\r\n                    for (let ci = 0; ci < comps.length; ci++) {\r\n                        const comp = comps[ci];\r\n                        const cType = comp.type;\r\n\r\n                        if (\r\n                            ['text', 'textnode'].indexOf(cType) < 0 &&\r\n                            c.textTags.indexOf(comp.tagName) < 0\r\n                        ) {\r\n                            allTxt = 0;\r\n                            break;\r\n                        }\r\n\r\n                        if (cType == 'textnode') {\r\n                            foundTextNode = 1;\r\n                        }\r\n                    }\r\n\r\n                    if (allTxt && foundTextNode) {\r\n                        model.type = 'text';\r\n                    }\r\n                }\r\n\r\n                if (!model.tagName && model.type != 'textnode') {\r\n                    continue;\r\n                }\r\n\r\n                result.push(model);\r\n            }\r\n\r\n            return result;\r\n        },\r\n\r\n        /**\r\n         * Parse HTML string to a desired model object\r\n         * @param  {string} str HTML string\r\n         * @param  {ParserCss} parserCss In case there is style tags inside HTML\r\n         * @return {Object}\r\n         *\r\n         */\r\n        parse(str, parserCss) {\r\n            console.log(\"html\", str, parserCss);\r\n\r\n            var config = (c.em && c.em.get('Config')) || {};\r\n            var res = { html: '', css: '' };\r\n\r\n            var quoted = this.quoteJsxExpresionsInAttributes(str);\r\n            let wrappedInDiv = false;\r\n            if (!quoted.startsWith('<')) {\r\n                quoted = '<div>'+quoted+'</div>';\r\n                wrappedInDiv = true;\r\n            }\r\n            const dom = nodeHtmlParser(quoted);\r\n            var result = this.parseNode(dom);\r\n\r\n            if (result.length == 1) {\r\n                result = result[0];\r\n            }\r\n\r\n            if (wrappedInDiv) {\r\n                if (result.components) {\r\n                    result = result.components;\r\n                }\r\n                \r\n                else {\r\n                    delete result.tagName;\r\n                    result.type = \"textnode\";\r\n                }\r\n            }\r\n            res.html = result;\r\n\r\n           \r\n            if (parserCss) {\r\n                var el = document.createElement('div');\r\n                el.innerHTML = str;\r\n                var styleStr = '';\r\n                var styles = el.querySelectorAll('style');\r\n                var j = styles.length;\r\n\r\n                while (j--) {\r\n                    styleStr = styles[j].innerHTML + styleStr;\r\n                    styles[j].parentNode.removeChild(styles[j]);\r\n                }\r\n\r\n                if (styleStr) res.css = parserCss.parse(styleStr);\r\n            }\r\n\r\n            return res;\r\n        }\r\n    };\r\n};"],"mappings":"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"},"metadata":{},"sourceType":"module"}